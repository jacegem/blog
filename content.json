{"meta":{"title":"Momentous for the future","subtitle":"Momentous for the future","description":"Momentous for the future","author":"Jace","url":"http://jacegem.github.io/blog"},"pages":[],"posts":[{"title":"[OpenCV-Python Tutorials] 21. Contours(윤곽선) 추가 기능","slug":"2018/OpenCV-Python-Tutorials-21-Contours-윤곽선-추가-기능","date":"2018-01-21T10:18:37.000Z","updated":"2018-01-05T10:22:36.133Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-21-Contours-윤곽선-추가-기능/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-21-Contours-윤곽선-추가-기능/","excerpt":"","text":"[OpenCV-Python Tutorials] 21. Contours(윤곽선) 추가 기능목표 볼록성 결함 및 그 결함을 찾는 방법. 점에서 다각형까지 최단 거리 찾기 다른 모양 맞추기 이론 및 코드1. 볼록성 결함윤곽선에 대한 두 번째 장에서 볼록한 선체가 무엇인지 보았습니다. 이 선체에서 물체가 이탈하면 볼록 결함으로 간주 될 수 있습니다. OpenCV에는 이것을 찾을 수있는 기성 함수가 제공됩니다 cv2.convexityDefects(). 기본 함수 호출은 다음과 같습니다. 12hull = cv2.convexHull(cnt,returnPoints = False)defects = cv2.convexityDefects(cnt,hull) convexity 결함을 찾기 위해 convex hull을 찾는 동안 returnPoints = False를 전달해야한다는 것을 기억하십시오. 각 행에 [시작점, 끝점, 가장 먼 지점, 가장 가까운 지점까지의 대략적인 거리] 값이 들어있는 배열을 반환합니다. 이미지를 사용하여 시각화 할 수 있습니다. 우리는 시작점과 끝점을 연결하는 선을 그린 다음 먼 지점에 원을 그립니다. 처음 세 개의 값은 cnt의 인덱스임을 기억하십시오. 그래서 우리는 그 값들을 cnt에서 가져와야 합니다. 1234567891011121314151617181920212223import cv2import numpy as npimg = cv2.imread('star.jpg')img_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(img_gray, 127, 255,0)contours,hierarchy = cv2.findContours(thresh,2,1)cnt = contours[0]hull = cv2.convexHull(cnt,returnPoints = False)defects = cv2.convexityDefects(cnt,hull)for i in range(defects.shape[0]): s,e,f,d = defects[i,0] start = tuple(cnt[s][0]) end = tuple(cnt[e][0]) far = tuple(cnt[f][0]) cv2.line(img,start,end,[0,255,0],2) cv2.circle(img,far,5,[0,0,255],-1)cv2.imshow('img',img)cv2.waitKey(0)cv2.destroyAllWindows() 결과 2. 점 다각형 테스트이 함수는 이미지의 점과 윤곽 사이의 최단 거리를 찾습니다. 거리가 윤곽선 외부에 있을 때 음수이고, 점이 내부에 있을 때 양수이고, 점이 윤곽선 위에 있으면 0입니다. 예를 들어 다음과 같이 점 (50,50)을 확인할 수 있습니다. 1dist = cv2.pointPolygonTest(cnt,(50,50),True) 함수에서 세 번째 인수는 measureDist입니다. Ture이면 부호가 있는 거리를 찾습니다. False이면 점이 내부 또는 외부인지 윤곽선위에 있는지 찾습니다 (각각 +1, -1, 0을 반환). 거리를 찾고 싶지 않다면 세 번째 인수가 False임을 확인하십시오. 왜냐하면 시간이 많이 소요되는 프로세스이기 때문입니다. 따라서 False로 설정하면 약 2-3 배의 속도 향상을 얻을 수 있습니다. 3. 도형 맞추기OpenCV에는 두 개의 도형 또는 두 개의 윤곽선을 비교하고 유사성을 나타내는 메트릭을 반환하는 cv2.matchShapes() 함수가 있습니다. 결과가 낮을수록 더 일치합니다. hu-moment 값을 기반으로 계산됩니다. 다른 측정 방법은 문서에 설명되어 있습니다. 123456789101112131415import cv2import numpy as npimg1 = cv2.imread('star.jpg',0)img2 = cv2.imread('star2.jpg',0)ret, thresh = cv2.threshold(img1, 127, 255,0)ret, thresh2 = cv2.threshold(img2, 127, 255,0)contours,hierarchy = cv2.findContours(thresh,2,1)cnt1 = contours[0]contours,hierarchy = cv2.findContours(thresh2,2,1)cnt2 = contours[0]ret = cv2.matchShapes(cnt1,cnt2,1,0.0)print ret 아래에 주어진 다른 모양으로 일치하는 모양을 시도하였습니다. 결과는 다음과 같습니다. 이미지 A와 이미지 A(일치) = 0.0 이미지 A와 이미지 B = 0.001946 이미지 A와 이미지 C = 0.326911 이미지의 회전이 비교에 많은 영향을 미치지 않습니다. Hu-Moments은 translation, 회전 및 크기에 영향을 받지 않는 seven moments입니다. 일곱 번째 것은 왜곡 불변입니다. 이러한 값은 cv2.HuMoments() 함수를 사용하여 찾을 수 있습니다. 연습 문제 cv2.pointPolygonTest()에 대한 설명서를 확인하십시오. 빨간색과 파란색으로 멋진 이미지를 찾을 수 있습니다. 모든 픽셀에서 흰색 곡선까지의 거리를 나타냅니다. 곡선 안에있는 모든 픽셀은 거리에 따라 파란색입니다. 마찬가지로 외부 포인트는 빨간색입니다. 윤곽선 모서리는 흰색으로 표시됩니다. 문제는 간단합니다. 그런 거리 표현을 만드는 코드를 작성하십시오. cv2.matchShapes()를 사용하여 숫자 나 문자의 이미지를 비교하십시오. (OCR을 향한 간단한 단계 일 것입니다) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 20. Contours(윤곽선) 속성","slug":"2018/OpenCV-Python-Tutorials-20-Contours-윤곽선-속성","date":"2018-01-20T10:18:19.000Z","updated":"2018-01-05T10:33:54.717Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-20-Contours-윤곽선-속성/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-20-Contours-윤곽선-속성/","excerpt":"","text":"[OpenCV-Python Tutorials] 20. Contours(윤곽선) 속성여기서는 Solidity, Equivalent Diameter, Mask image, Mean Intensity 등과 같은 객체에서 자주 사용되는 속성을 추출하는 방법을 배웁니다. 더 많은 기능은 Matlab regionprops 문서에서 찾을 수 있습니다. (주의 : Centroid, Area, Perimeter 등은 이전 장에서 보았습니다) 1. 종횡비 (Aspect Ratio)이것은 객체의 경계 사각형의 너비와 높이의 비율입니다. $$Aspect \\; Ratio = \\frac{Width}{Height}$$ 12x,y,w,h = cv2.boundingRect(cnt)aspect_ratio = float(w)/h 2. 범위 (Extent)Extent는 윤곽선 영역과 경계 사각형 영역의 비율입니다. $$Extent = \\frac{Object \\; Area}{Bounding \\; Rectangle \\; Area}$$ 3. 견고성 (Solidity)Solidity는 Contour 영역과 볼록한 선체 영역의 비율입니다. $$Solidity = \\frac{Contour \\; Area}{Convex \\; Hull \\; Area}$$ 1234area = cv2.contourArea(cnt)hull = cv2.convexHull(cnt)hull_area = cv2.contourArea(hull)solidity = float(area)/hull_area 4. 등가 지름 (Equivalent Diameter)등가 지름은 윤곽 영역과 동일한 영역의 원의 직경입니다. $$Equivalent \\; Diameter = \\sqrt{\\frac{4 \\times Contour \\; Area}{\\pi}}$$ 12area = cv2.contourArea(cnt)equi_diameter = np.sqrt(4*area/np.pi) 5. 오리엔테이션Orientation은 객체가 향하는 각도입니다. 다음 방법은 주요 축과 보조 축 길이를 제공합니다. 1(x,y),(MA,ma),angle = cv2.fitEllipse(cnt) 6. 마스크와 픽셀 포인트어떤 경우에는 그 대상을 구성하는 모든 점이 필요할 수도 있습니다. 다음과 같이 수행 할 수 있습니다. 1234mask = np.zeros(imgray.shape,np.uint8)cv2.drawContours(mask,[cnt],0,255,-1)pixelpoints = np.transpose(np.nonzero(mask))#pixelpoints = cv2.findNonZero(mask) 여기에는 Numpy 함수를 사용하는 방법과 OpenCV 함수를 사용하는 두 가지 방법 (마지막 주석 처리 된 줄)이 있습니다.결과도 동일하지만 약간의 차이가 있습니다.Numpy는 (행, 열) 형식으로 좌표를 제공하고 OpenCV는 (x, y) 형식으로 좌표를 제공합니다. row = x 및 column = y입니다. 7. 최대 값, 최소값 및 위치이 매개 변수는 마스크 이미지를 사용하여 찾을 수 있습니다. 1min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(imgray,mask = mask) 9. 익스트림 포인트Extreme Points는 객체의 가장 위쪽, 가장 아래쪽, 가장 오른쪽 및 가장 왼쪽의 점을 의미합니다. 1234leftmost = tuple(cnt[cnt[:,:,0].argmin()][0])rightmost = tuple(cnt[cnt[:,:,0].argmax()][0])topmost = tuple(cnt[cnt[:,:,1].argmin()][0])bottommost = tuple(cnt[cnt[:,:,1].argmax()][0]) 예를 들어 인도지도에 적용하면 다음과 같은 결과가 나타납니다. 연습문제아직 MATLAB 지역 프로젝트 문서에 남아있는 몇 가지 기능이 있습니다. 그것들을 구현해 보세요. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 19. Contours(윤곽선) 특징","slug":"2018/OpenCV-Python-Tutorials-19-Contours-윤곽선-특징","date":"2018-01-19T10:17:53.000Z","updated":"2018-01-05T10:22:27.467Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-19-Contours-윤곽선-특징/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-19-Contours-윤곽선-특징/","excerpt":"","text":"[OpenCV-Python Tutorials] 19. Contours(윤곽선) 특징목표 면적, 둘레, 중심, 경계 상자 등 윤곽선의 다른 특징 윤곽선과 관련된 다양한 기능 1. MomentsImage moments은 물체의 중심, 물체의 면적 등과 같은 일부 기능을 계산하는 데 도움이 됩니다. 함수 cv2.moments()는 모든 moment 값의 사전을 계산합니다. 아래를 참조하십시오 : 12345678910import cv2import numpy as npimg = cv2.imread('star.jpg',0)ret,thresh = cv2.threshold(img,127,255,0)contours,hierarchy = cv2.findContours(thresh, 1, 2)cnt = contours[0]M = cv2.moments(cnt)print M 이 moments부터 면적, 중심 등 유용한 데이터를 추출 할 수 있습니다. Centroid는 $$Cx = \\frac{M{10}}{M_{00}}$$ 및 $$Cy = \\frac{M{01}}{M_{00}}$$ 로 부터 얻을 수 있습니다. 이 작업은 다음과 같이 수행 할 수 있습니다. 12cx = int(M['m10']/M['m00'])cy = int(M['m01']/M['m00']) 2. Contour Area(영역)Contour 영역은 함수 cv2.contourArea() 또는 moments M[&#39;m00&#39;]에 의해 주어집니다. 1area = cv2.contourArea(cnt) 3. Contour Perimeter(경계선)arc length 라고도 합니다. cv2.arcLength() 함수를 사용하여 찾을 수 있습니다. 두 번째 인수는 True로 전달 된 경우 닫힌 contour가 되며 아닌 경우에는 곡선이 됩니다. 1perimeter = cv2.arcLength(cnt,True) 4. Contour Approximation(근사)우리가 지정한 정밀도에 따라 Contour 모양을 정점 수가 적은 다른 모양으로 근사합니다. Douglas-Peucker 알고리즘의 구현입니다. 아래에 표시된 첫 이미지처럼 나쁜 모양인 경우 이미지의 사각형을 찾으려고 노력하지만, 이미지의 몇 가지 문제에 대한 완전한 사각형을 얻을 수 없습니다. 이때 이 함수를 사용하여 형상을 근사 할 수 있습니다. 이 두 번째 인수는 epsilon이라 불리며, 엡실론은 윤곽에서 근사 된 윤곽까지의 최대 거리입니다. 정밀도 매개 변수입니다. 올바른 출력을 얻기 위해서는 현명한 epsilon의 선택이 필요합니다. 12epsilon = 0.1*cv2.arcLength(cnt,True)approx = cv2.approxPolyDP(cnt,epsilon,True) 아래의 두 번째 이미지는 녹색 선은 epsilon = 10% of arc length의 추세선을 보여줍니다. 제 3의 이미지는 epsilon = 1% of the arc length에서 같은 것을 나타낸 것입니다. 세번째 인수는 곡선이 닫혀 있는지 여부를 지정합니다. 5. Convex HullConvex Hull은 contour approximation와 비슷해 보이지만 그렇지 않습니다. (같은 결과를 얻을지도 모릅니다.) 여기에서는 cv2.convexHull() 함수 곡선에 볼록 결함을 확인하고 수정합니다. 일반적으로 볼록한 곡선은 항상 불룩 또는 적어도 평탄한 곡선입니다. 그리고 안쪽으로 부풀어 오른 경우는 볼록 결함이라고 합니다. 예를 들어, 다음 단계의 이미지를 확인하십시오. 빨간색 선은 손의 볼록 선체를 보여줍니다. 양면 화살표 표시는 등고선에서 선체의 국부적인 최대 편차인 볼록 결함을 나타냅니다. 구문에 대해 약간 논의 할 사항이 있습니다. 1hull = cv2.convexHull(points[, hull[, clockwise[, returnPoints]] 인수 상세 정보 : point: 포인트는 우리가 전달하는 윤곽입니다. hull: 선체는 출력이지만, 일반적으로 피합니다. clockwise: 시계 방향 : 방향 플래그. True이면 출력 볼록 선체는 시계 방향입니다. 그렇지 않으면 시계 반대 방향입니다. returnPoints : 기본적으로 True입니다. 다음 선체 점의 좌표를 반환합니다. False이면 선체 점에 대응하는 윤곽 점의 인덱스를 돌려줍니다. 따라서 위의 이미지처럼 볼록 선체를 얻으려면 다음과 같이하면 됩니다. 1hull = cv2.convexHull(cnt) 그러나 convexity 결함을 찾으려면 eturnPoints = False를 전달해야 합니다. 이를 이해하기 위해 위의 사각형 이미지를 사용합니다. 처음에는 그 윤곽선을 cnt로 찾았습니다. 이제 returnPoints = True로 볼록한 선체를 발견했습니다. 다음 값을 얻었습니다 : [[234 202]], [[51 202]], [[514 79]], [499] 직사각형의 점. 이제 returnPoints = False로 동일하게 수행하면 [[129], [67], [0], [142]] 결과를 얻습니다. 이것들은 등고선의 대응점의 색인입니다. 예를 들어, 첫 번째 값을 확인하십시오 : cnt [129] = [[234, 202]] 이는 첫 번째 결과와 같습니다 (다른 것들도 마찬가지입니다). 그러나 convexity 결함을 찾으려면 eturnPoints = False를 전달해야 합니다. 그것을 이해하기 위해서는 위의 사각형 이미지를 다룹니다. 처음에는 그 윤곽선을 cnt로 찾았습니다. returnPoints = True로 볼록 선체를 찾아내어 사각형의 점 값을 얻었습니다. [[[234 202], [51 202], [51 79], [234 79]]] . 이번에는 returnPoints = False 처럼하면 결과는 [[[129] [67] [0] [142]]]입니다. 이들은 등고선의 대응점의 인덱스입니다. 예를 들어, 첫 번째 결과와 같은 cnt[129] = [[234,202]]의 첫 번째 값을 확인합니다 (다른 경우도 마찬가지). 볼록 결함에 대해 논의 할 때 다시 그것을 볼 것입니다. 6. Convexity 확인cv2.isContourConvex()는 커브가 볼록인지 여부를 확인하는 기능이 있습니다. True 또는 False를 반환합니다. Not a big deal. 1k = cv2.isContourConvex(cnt) 7. 경계 사각형경계 사각형은 2 가지가 있습니다. 7.a. 직선 경계 사각형그것은 직사각형이며 객체의 회전을 고려하지 않습니다. 따라서 경계 사각형의 영역은 최소가 되지 않습니다. 이것은 cv2.boundingRect() 함수를 통해 찾을 수 있습니다. (x, y)를 직사각형의 왼쪽 위 좌표로 하고 (w, h)를 폭과 높이로 합니다. 12x,y,w,h = cv2.boundingRect(cnt)img = cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html#moments https://acidsound.github.io/transplus/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 18. Contours(윤곽선) 시작하기","slug":"2018/OpenCV-Python-Tutorials-18-Contours-윤곽선-시작하기","date":"2018-01-18T10:17:33.000Z","updated":"2018-01-05T10:27:23.609Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-18-Contours-윤곽선-시작하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-18-Contours-윤곽선-시작하기/","excerpt":"","text":"[OpenCV-Python Tutorials] 18. Contours(윤곽선) 시작하기목표 Contours(윤곽선)이 무엇인지에 대한 이해 등고선 찾기, 등고선 그리기 함수: cv2.findContours(), cv2.drawContours() contours(윤곽)이란?윤곽선은 동일한 색상 또는 강도를 갖는 모든 연속 점 (경계를 따라)을 결합하는 곡선으로 간단히 설명 할 수 있습니다. 윤곽선은 형상 분석 및 객체 감지 및 인식에 유용한 도구입니다. 정확성을 높이려면 이진 이미지를 사용하십시오. 따라서 윤곽선을 찾기 전에 임계점 또는 canny edge detection를 적용하십시오. findContours 함수는 소스 이미지를 수정합니다. 따라서 윤곽선을 찾은 후에도 소스 이미지를 원한다면 이미 다른 변수에 저장하십시오. OpenCV에서 윤곽선을 찾는 것은 검정 배경에서 흰색 물체를 찾는 것과 같습니다. 그러므로 찾을 물체는 흰색이어야하고 배경은 검은색이어야 합니다. 이진 이미지의 윤곽선을 찾는 방법을 살펴 보겠습니다. 1234567import numpy as npimport cv2im = cv2.imread('test.jpg')imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)ret,thresh = cv2.threshold(imgray,127,255,0)image, contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) cv2.findContours() 함수에는 세 개의 인수가 있습니다. 첫 번째는 소스 이미지이고, 두 번째는 등고선 검색 모드이고, 세 번째는 등고선 근사 방법입니다. 그리고 이미지, contours 및 계층을 출력합니다. contours은 이미지의 모든 윤곽을 파이썬으로 나타낸 목록입니다. 각각의 개별 윤곽은 객체의 경계 지점의 (x, y) 좌표의 객체 배열입니다. 나중에 두 번째 및 세 번째 인수와 계층 구조에 대해 자세히 설명합니다. 그때까지는 코드 예제에서 주어진 값이 모든 이미지에서 잘 작동합니다. contours(윤곽)을 그리는 방법?contours을 그리려면 cv2.drawContours 함수가 사용됩니다. 또한 경계 지점이 있는 경우 모든 모양을 그리는 데 사용할 수 있습니다. 첫 번째 인수는 소스 이미지이고, 두 번째 인수는 파이썬 목록으로 전달되어야하는 contours이며, 세 번째 인수는 contours 색인입니다 (개별 윤곽선을 그리는 데 유용합니다. 모든 윤곽선을 그리려면 -1을 전달합니다.) 나머지 인수는 색상, 두께 등입니다. 이미지에 모든 윤곽선을 그리려면 : 1img = cv2.drawContours(img, contours, -1, (0,255,0), 3) 개별 윤곽선을 그리려면 4 번째 윤곽선을 말하십시오. 1img = cv2.drawContours(img, contours, 3, (0,255,0), 3) 하지만 대부분의 경우 아래의 메소드가 유용합니다. 12cnt = contours[4]img = cv2.drawContours(img, [cnt], 0, (0,255,0), 3) 마지막 두 가지 방법은 동일하지만 앞으로 나아갈 때 마지막 방법이 더 유용하다는 것을 알 수 있습니다. Contour 근사 방법이것은 cv2.findContours 함수의 세 번째 인수입니다. 그것은 실제로 무엇을 나타낼까요? 위에서 우리는 contours 이 동일한 강도를 지닌 모양의 경계라고 이야기했습니다. 도형 경계의 (x, y) 좌표를 저장합니다. 그러나 그것은 모든 좌표를 저장할까요? 윤곽 근사법으로 지정됩니다. cv2.CHAIN_APPROX_NONE를 넘겨 주면 모든 경계 지점이 저장됩니다. 그러나 실제로 모든 포인트가 필요할까요? 예를 들어, 직선의 윤곽을 발견했습니다. 그 라인을 나타 내기 위해 라인의 모든 포인트가 필요할까요? 아닙니다. 우리는 그 선의 두 종점만 있으면 됩니다. 이것이 cv2.CHAIN_APPROX_SIMPLE의 기능입니다. 모든 중복 점을 제거하고 윤곽을 압축하여 메모리를 절약합니다. 아래 사각형 이미지는 이 기법을 보여줍니다. 등고선 배열(파란색으로 그려 짐)의 모든 좌표에 원을 그립니다. 첫 번째 이미지는 cv2.CHAIN_APPROX_NONE (734개의 점)으로 얻은 점을 표시하고 두 번째 이미지는 cv2.CHAIN_APPROX_SIMPLE (4개의 점만)으로 표시합니다. 얼마나 많은 메모리가 절약되는지 확인하시기 바랍니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_begin/py_contours_begin.html#contours-getting-started","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 17. 이미지 피라미드","slug":"2018/OpenCV-Python-Tutorials-17-이미지-피라미드","date":"2018-01-17T10:17:09.000Z","updated":"2018-01-05T10:17:14.489Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-17-이미지-피라미드/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-17-이미지-피라미드/","excerpt":"","text":"[OpenCV-Python Tutorials] 17. 이미지 피라미드목표 이미지 피라미드에 대해 알아보겠습니다. Image 피라미드를 사용하여 새로운 이미지를 만들어볼게요 함수: cv2.pyrUp(), cv2.pyrDown() 이론일반적으로 우리는 일정한 크기의 이미지로 작업했습니다. 그러나 어떤 경우에는 같은 이미지의 다른 해상도의 이미지로 작업해야 합니다. 예를 들어, 얼굴과 같은 이미지에서 무언가를 검색하는 동안 이미지에 어떤 크기의 물체가 나타날지 확신 할 수 없습니다. 이 경우, 우리는 해상도가 다른 일련의 이미지를 만들고 모든 이미지에서 객체를 검색해야합니다. 서로 다른 해상도의 이미지 세트를 Image Pyramids라고 부릅니다. 왜냐하면 피라미드처럼 맨 아래에 가장 큰 이미지가 가장 큰 이미지가 있는 스택에 보관되어 있기 때문입니다. 이미지 피라미드에는 두 가지 종류가 있습니다. 가우시안 피라미드 라플라시안 피라미드 Gaussian 피라미드의 높은 레벨(저해상도)은 낮은 레벨(고해상도) 이미지에서 연속적인 행과 열을 제거하여 생성합니다. 이렇게 하면, $$ M \\times N $$ 이미지는 $$M/2 \\times N/2$$ 이미지가 됩니다. 따라서 면적은 원래 면적의 1/4로 줄어 듭니다. 그것은 옥타브라고 합니다. 피라미드에서 위쪽으로 갈수록 같은 패턴이 계속됩니다 (즉, 해상도가 감소합니다). 마찬가지로 확장하면서 면적은 각 단계에서 4 배가 됩니다. cv2.pyrDown() 및 cv2.pyrUp() 함수를 사용하여 가우시안 피라미드를 찾을 수 있습니다. 1234567891011121314151617import cv2img = cv2.imread('model.jpg')titles = ['orginal', 'level1', 'level2', 'level3']images = []images.append(img)for i in range(3): img = cv2.pyrDown(img) images.append(img)for i in range(4): cv2.imshow(titles[i], images[i])cv2.waitKey(0)cv2.destroyAllWindows() 아래는 이미지 피라미드의 4 단계입니다. 이제 cv2.pyrUp() 함수를 사용하여 이미지 피라미드로 이동할 수 있습니다. 1higher_reso2 = cv2.pyrUp(lower_reso) 1234567891011121314151617import cv2img = cv2.imread('small.jpg')titles = ['orginal', 'level1', 'level2', 'level3']images = []images.append(img)for i in range(3): img = cv2.pyrUp(img) images.append(img)for i in range(4): cv2.imshow(titles[i], images[i])cv2.waitKey(0)cv2.destroyAllWindows() Laplacian 피라미드는 Gaussian Pyramids에서 형성됩니다. 거기에 대한 독점적인 기능은 없습니다. Laplacian 피라미드 이미지는 가장자리 이미지와 같습니다. 요소의 대부분은 0입니다. 이미지 압축에 사용됩니다. 라플라시안 피라미드의 레벨은 가우시안 피라미드의 해당 레벨과 가우시안 피라미드의 상위 레벨 확장 버전의 차이에 의해 형성됩니다. Laplacian 레벨의 세 가지 레벨은 아래와 같이 보일 것입니다 (내용을 향상시키기 위해 대비가 조정 됨). 123456789101112131415161718192021import cv2img = cv2.imread('large.jpg')titles = ['orginal', 'level1', 'level2', 'level3']images = []images.append(img)for i in range(3): img = cv2.pyrDown(img) images.append(img)for i in range(3): resize = cv2.resize(images[i] , dsize=(images[i+1].shape[1], images[i+1].shape[0]) , interpolation=cv2.INTER_CUBIC) images[i] = cv2.subtract(resize, images[i+1]) cv2.imshow(titles[i], images[i])cv2.waitKey(0)cv2.destroyAllWindows() 피라미드를 사용한 이미지 블렌딩피라미드의 한 응용 프로그램은 이미지 블렌딩입니다. 예를 들어, 이미지 바느질에서는 두 이미지를 함께 쌓아야 하지만 이미지간에 불연속성으로 인해 잘 보이지 않을 수 있습니다. 이 경우 피라미드로 이미지 블렌딩을 하면 이미지에 많은 데이터를 남기지 않고도 원활한 혼합이 가능합니다. 하나의 고전적인 예는 Orange와 Apple의 두 과일을 혼합 한 것입니다. 지금 하고 있는 것을 이해하기 위해 지금 결과를 확인해보세요 추가 리소스의 첫 번째 참조를 확인하십시오. 이미지 블렌딩, Laplacian Pyramids 등의 전체 다이어그램 세부 정보가 있습니다. 간단히 말해서 다음과 같이 수행됩니다. 사과와 오렌지의 두 이미지 로드 사과와 오렌지에 대한 가우시안 피라미드를 찾으십시오 (이 예제에서는 레벨 수가 6입니다). 가우시안 피라미드에서 라플라시안 피라미드를 찾으십시오. 이제 Laplacian Pyramids의 각 레벨에서 사과의 왼쪽 절반과 오렌지의 오른쪽 절반에 합칩니다. 마지막으로이 공동 이미지 피라미드에서 원래 이미지를 재구성하십시오. 전체 코드는 다음과 같습니다. (간단히하기 위해 각 단계가 별도로 수행되므로 더 많은 메모리가 필요할 수 있습니다. 원하는 경우 최적화 할 수 있습니다). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import cv2import numpy as npA = cv2.imread('resize_a.jpg')B = cv2.imread('resize_b.jpg')B = cv2.resize(B, dsize=(A.shape[1], A.shape[0]), interpolation=cv2.INTER_CUBIC)# generate Gaussian pyramid for AG = A.copy()gpA = [G]for i in range(6): G = cv2.pyrDown(G) gpA.append(G)# generate Gaussian pyramid for BG = B.copy()gpB = [G]for i in range(6): G = cv2.pyrDown(G) gpB.append(G)# generate Laplacian Pyramid for AlpA = [gpA[5]]for i in range(5, 0, -1): GE = cv2.pyrUp(gpA[i]) L = cv2.subtract(gpA[i - 1], GE) lpA.append(L)# generate Laplacian Pyramid for BlpB = [gpB[5]]for i in range(5, 0, -1): GE = cv2.pyrUp(gpB[i]) L = cv2.subtract(gpB[i - 1], GE) lpB.append(L)# Now add left and right halves of images in each levelLS = []for la, lb in zip(lpA, lpB): rows, cols, dpt = la.shape ls = np.hstack((la[:, 0:int(cols / 2)], lb[:, int(cols / 2):])) LS.append(ls)# now reconstructls_ = LS[0]for i in range(1, 6): ls_ = cv2.pyrUp(ls_) ls_ = cv2.add(ls_, LS[i])# image with direct connecting each halfreal = np.hstack((A[:, :int(cols / 2)], B[:, int(cols / 2):]))cv2.imwrite('Pyramid_blending2.jpg', ls_)cv2.imwrite('Direct_blending.jpg', real) 두 이미지의 크기가 동일해야 합니다.ls = np.hstack((la[:, 0:int(cols / 2)], lb[:, int(cols / 2):])) 에서 정수값이 입력되야 하므로, int() 를 사용하였습니다. Additional Resources Image Blending 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_pyramids/py_pyramids.html https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220508552078&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 16. Canny Edge Detection","slug":"2018/OpenCV-Python-Tutorials-16-Canny-Edge-Detection","date":"2018-01-16T10:16:50.000Z","updated":"2018-01-05T10:33:53.782Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-16-Canny-Edge-Detection/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-16-Canny-Edge-Detection/","excerpt":"","text":"[OpenCV-Python Tutorials] 16. Canny Edge Detection목표 Canny edge detection의 개념 OpenCV 함수 : cv2.Canny() 이론Canny Edge Detection은 널리 사용 되는 가장자리 감지 알고리즘입니다. 이것은 1986 년 John F. Canny가 개발했습니다. 이것은 다중 단계 알고리즘이며 각 단계를 거치게 됩니다. Noise 제거가장자리 감지는 이미지의 노이즈에 영향 받기 쉽기 때문에 5x5 가우스 필터를 사용하여 이미지의 노이즈를 제거해야 합니다. 이전 장에서 이미 살펴 보았습니다. 이미지의 강도 기울기 찾기 (Finding Intensity Gradient of the Image)Smoothened 이미지는 Sobel 커널로 수평 및 수직 방향으로 필터링되어 수평 방향 $$(G_x)$$ 및 수직 방향 $$(G_y)$$에서 1차 미분을 얻습니다. 이 두 이미지에서 다음과 같이 에지 기울기와 각 픽셀의 방향을 찾을 수 있습니다. $$\\begin{array}{r}Edge_Gradient \\; (G) = \\sqrt{G_x^2 + G_y^2}\\Angle \\; (\\theta) = \\tan^{-1} \\bigg(\\frac{G_y}{G_x}\\bigg)\\end{array}$$ 기울기 방향은 항상 가장자리에 수직입니다. 수직, 수평 및 대각선 방향을 나타내는 4 개의 각도 중 하나로 반올림됩니다. Non-maximum 억제그레디언트의 크기와 방향을 얻은 후 가장자리를 구성하지 않을 수 있는 원치 않는 픽셀을 제거하기 위해 이미지의 전체 스캔이 수행됩니다. 이를 위해, 모든 픽셀에서 픽셀은 그라디언트 방향에서 인접 픽셀의 로컬 최대 값인지 확인합니다. 아래 이미지를 확인하십시오. 점 A는 가장자리에 있습니다 (수직 방향). 경사 방향은 가장자리에 수직입니다. 점 B와 C는 기울기 방향입니다. 따라서 점 A와 점 B를 사용하여 점 A와 점 B를 확인하여 극대점을 찾습니다. 그렇다면 다음 단계로 간주되며, 그렇지 않으면 억제됩니다 (0으로 설정). 간단히 말해서, 결과는 “얇은 가장자리”가 있는 이진 이미지입니다. Hysteresis Thresholding이 단계에서는 모든 가장자리가 실제로 가장자리인지 아닌지를 결정 합니다. 이를 위해 두 개의 임계값 인 minVal과 maxVal이 필요합니다. 강도 기울기가 maxVal보다 큰 모서리는 모서리이어야 하며 minVal보다 작은 모서리는 반드시 모서리가 아니므로 버려야 합니다. 이 두 임계 값 사이에있는 사람들은 연결 상태에 따라 가장자리 또는 비 가장자리로 분류됩니다. 픽셀이 &quot;확실한&quot;픽셀에 연결되면 가장자리의 일부로 간주됩니다. 그렇지 않으면 삭제됩니다. 아래 이미지를 참조하십시오. 가장자리 A는 maxVal보다 높으므로 “확실한 가장자리”로 간주됩니다. 에지 C는 maxVal보다 낮지만 에지 A에 연결되므로 유효한 에지로 간주되어 전체 곡선을 얻습니다. 그러나 가장자리 B는 minVal보다 크고 가장자리 C와 동일한 영역에 있지만 어떤 “확실한 가장자리”에도 연결되어 있지 않으므로 삭제됩니다. 따라서 올바른 결과를 얻으려면 minVal 및 maxVal을 선택해야한다는 것이 매우 중요합니다. 이 단계는 또한 가장자리가 긴 선이라고 가정 할 때 작은 픽셀 노이즈를 제거합니다. 그래서 우리가 마침내 얻을 수있는 것은 이미지의 강한 가장자리입니다. OpenCV에서 Canny Edge DetectionOpenCV는 위의 모든 것을 단일 함수, cv2.Canny()에 넣습니다. 우리는 그것을 어떻게 사용하는지 볼 것입니다. 첫 번째 인자는 우리의 입력 이미지입니다. 두 번째 및 세 번째 인수는 각각 minVal 및 maxVal입니다. 세 번째 인수는 조리개 값입니다. 그것은 이미지 구배 찾기에 사용되는 Sobel 커널의 크기입니다. 기본적으로 3입니다. 마지막 인수는 그라디언트 크기를 찾는 방정식을 지정하는 L2gradient입니다. True이면 위에서 언급 한 방정식을 사용합니다. 기본값은 False이며, $$Edge_Gradient \\; (G) = |G_x| + |G_y|$$. 를 사용합니다. 12345678910111213import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('messi5.jpg',0)edges = cv2.Canny(img,100,200)plt.subplot(121),plt.imshow(img,cmap = 'gray')plt.title('Original Image'), plt.xticks([]), plt.yticks([])plt.subplot(122),plt.imshow(edges,cmap = 'gray')plt.title('Edge Image'), plt.xticks([]), plt.yticks([])plt.show() 결과: 추가 리소스 위키피디아의 Canny Edge Detector Canny Edge Detection Tutorial (Bill Green, 2002) 연습 문제 두 개의 트랙 바를 사용하여 임계 값을 변경할 수있는 Canny 가장자리 감지를 찾으려면 작은 응용 프로그램을 작성하십시오. 이렇게 하면 임계 값의 영향을 이해할 수 있습니다. 123456789101112131415161718192021222324252627import cv2img = cv2.imread('canny.jpg')img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)cv2.namedWindow('image')def nothing(x): pass# create trackbars for color changecv2.createTrackbar('threshold1', 'image', 0, 255, nothing)cv2.createTrackbar('threshold2', 'image', 0, 255, nothing)while True: threshold1 = cv2.getTrackbarPos('threshold1', 'image') threshold2 = cv2.getTrackbarPos('threshold2', 'image') edges = cv2.Canny(img, threshold1, threshold2) cv2.imshow('image', edges) k = cv2.waitKey(1) &amp; 0xFF if k == 27: breakcv2.destroyAllWindows() threshold1, threshold2 의 값을 변경시키면서 Canny Edge Detection의 변화를 확인 할 수 있습니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220507996391&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 15. 이미지 Gradients","slug":"2018/OpenCV-Python-Tutorials-15-이미지-Gradients","date":"2018-01-15T10:16:32.000Z","updated":"2018-01-05T10:33:53.814Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-15-이미지-Gradients/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-15-이미지-Gradients/","excerpt":"","text":"[OpenCV-Python Tutorials] 15. 이미지 Gradients목표 Image gradients, edges 찾기 cv2.Sobel(), cv2.Scharr(), cv2.Laplacian() 이론OpenCV는 Sobel, Scharr 및 Laplacian의 세 가지 유형의 그래디언트 필터 또는 하이 패스 필터를 제공합니다. 이것들을 각각 알아보겠습니다. 1. Sobel과 Scharr DerivativesSobel 연산자는 Gaussian smoothing 과 미분 연산으로 노이즈에 더 강합니다. yorder 및 xorder 인수에 의해 각각 파생 될 방향을 수직 또는 수평으로 지정할 수 있습니다. ksize 인수로 커널의 크기를 지정할 수도 있습니다. ksize = -1 인 경우 3x3 Scharr 필터가 사용되어 3x3 Sobel 필터보다 우수한 결과를 제공합니다. 사용된 커널에 대한 문서를 참조하십시오. 2. 라플라시안 파생릴랙스에 의해 주어진 이미지의 라플라시안을 계산합니다. $$\\Delta src = \\frac{\\partial ^2{src}}{\\partial x^2} + \\frac{\\partial ^2{src}}{\\partial y^2}$$ 여기서 각 파생물은 Sobel 파생을 사용하여 발견됩니다. ksize = 1이면 다음 커널이 필터링에 사용됩니다. $$kernel = \\begin{bmatrix} 0 &amp; 1 &amp; 0 \\\\ 1 &amp; -4 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\end{bmatrix}$$ 코드아래의 코드는 모든 다이어그램의 연산자를 보여줍니다. 모든 커널은 5x5 크기입니다. 출력 이미지의 깊이는 -1을 전달하여 np.uint8 유형으로 결과를 얻습니다. 12345678910111213141516171819import cv2from matplotlib import pyplot as pltimg = cv2.imread('kakuro.png')laplacian = cv2.Laplacian(img, cv2.CV_64F)sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)plt.subplot(2, 2, 1), plt.imshow(img, cmap='gray')plt.title('Original'), plt.xticks([]), plt.yticks([])plt.subplot(2, 2, 2), plt.imshow(laplacian, cmap='gray')plt.title('Laplacian'), plt.xticks([]), plt.yticks([])plt.subplot(2, 2, 3), plt.imshow(sobelx, cmap='gray')plt.title('Sobel X'), plt.xticks([]), plt.yticks([])plt.subplot(2, 2, 4), plt.imshow(sobely, cmap='gray')plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])plt.show() 결과: 하나의 중요한 문제!마지막 예에서 출력 데이터 유형은 cv2.CV_8U 또는 np.uint8입니다. 하지만 약간의 문제가 있습니다. 화이트 투 블랙 (Black to White) 전환은 네거티브 (Negative) 슬로프 (Negative Slope)로 간주되는 반면, 블랙 투 화이트 전환은 포지티브 슬로프 (Positive Slope) (양의 값을 가짐)로 취해진다. 따라서 데이터를 np.uint8로 변환하면 모든 음의 기울기가 0이됩니다. 간단한 말로, 당신은 그 가장자리를 놓치게됩니다. 두 모서리를 모두 감지하려면 출력 데이터 유형을 cv2.CV_16S, cv2.CV_64F 등의 상위 형식으로 유지하고 절대 값을 취한 다음 다시 cv2.CV_8U로 변환하십시오. 아래 코드는 수평 소벨 (Sobel) 필터와 결과의 차이에 대한이 절차를 보여줍니다. 12345678910111213141516171819202122import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('box.png', 0)# Output dtype = cv2.CV_8Usobelx8u = cv2.Sobel(img, cv2.CV_8U, 1, 0, ksize=5)# Output dtype = cv2.CV_64F. Then take its absolute and convert to cv2.CV_8Usobelx64f = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)abs_sobel64f = np.absolute(sobelx64f)sobel_8u = np.uint8(abs_sobel64f)plt.subplot(1, 3, 1), plt.imshow(img, cmap='gray')plt.title('Original'), plt.xticks([]), plt.yticks([])plt.subplot(1, 3, 2), plt.imshow(sobelx8u, cmap='gray')plt.title('Sobel CV_8U'), plt.xticks([]), plt.yticks([])plt.subplot(1, 3, 3), plt.imshow(sobel_8u, cmap='gray')plt.title('Sobel abs(CV_64F)'), plt.xticks([]), plt.yticks([])plt.show() 아래의 결과를 확인하십시오 : 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_gradients/py_gradients.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 14. 형태론적 변환","slug":"2018/OpenCV-Python-Tutorials-14-형태론적-변환","date":"2018-01-14T10:15:58.000Z","updated":"2018-01-05T10:16:08.579Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-14-형태론적-변환/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-14-형태론적-변환/","excerpt":"","text":"[OpenCV-Python Tutorials] 14. 형태론적 변환목표이 장에서는 Erosion, Dilation, Opening, Closing과 같은 다른 형태학적인 작동을 배울 것입니다. cv2.erode(), cv2.dilate(), cv2.morphologyEx() 등과 같은 다른 함수를 보게 될 것입니다. 이론형태학적 변형은 이미지 모양을 기반으로 한 몇 가지 간단한 작업입니다. 일반적으로 이진 이미지에서 수행됩니다. 그것은 두 개의 입력이 필요합니다. 하나는 우리의 원래 이미지이고, 두 번째는 구조 요소 또는 커널이라고 불리며 동작의 성격을 결정합니다. 두 가지 기본 형태학 연산자는 Erosion과 Dilation입니다. 그런 다음 Opening, Closing, Gradient 등과 같은 변형 된 형태도 작용합니다. 우리는 다음 이미지를 통해 하나씩 살펴볼 것입니다. 1. ErosionErosion의 기본 아이디어는 토양 침식과 같습니다. 전경 물체의 경계를 부식시킵니다 (항상 전경을 흰색으로 유지하려고 노력합니다). 그러면 어떻게 됩니까? 커널은 2D 컨볼루션 에서 처럼 이미지를 따라 슬라이드합니다. 원래 이미지의 픽셀 (1 또는 0)은 커널 아래의 모든 픽셀이 1 인 경우에만 1로 간주되고, 그렇지 않으면 침식 (0으로 설정)됩니다. 그렇다면 경계 근처의 모든 픽셀은 커널의 크기에 따라 버려집니다. 따라서 전경 물체의 두께나 크기가 줄어들거나 단순히 이미지의 흰색 영역이 줄어 듭니다. 작은 흰색 노이즈를 없애고 (색상 공간 장에서 보았듯이) 연결된 두 객체를 분리하는 등의 작업에 유용합니다. 여기 예를 들어 5x5 커널에 1x5 커널을 사용할 것입니다. 그것이 어떻게 작동하는지 살펴보겠습니다. 12345678910import cv2import numpy as npimg = cv2.imread('snow.jpg', 0)kernel = np.ones((5, 5), np.uint8)erosion = cv2.erode(img, kernel, iterations=1)cv2.imshow('erosion', erosion)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 2. Dilation그것은 Erosion의 정반대입니다. 여기서, 커널 아래의 적어도 하나의 픽셀이 ‘1’이면 픽셀 요소는 ‘1’이다. 따라서 이미지의 흰색 영역이 증가하거나 전경 오브젝트의 크기가 커집니다. 일반적으로 노이즈 제거와 같은 경우에는 erosion 후에 Dilation를 사용합니다. 왜냐하면 erosion은 백색 잡음을 제거하지만 또한 우리의 대상 객체 또한 축소시킵니다. 그런 다음에 dilate 합니다. 노이즈는 사라지므로 되살아 나지는 않습니다. 또한 객체의 깨진 부분을 결합하는 데 유용합니다. 1dilation = cv2.dilate(img,kernel,iterations = 1) 12345678910import cv2import numpy as npimg = cv2.imread('snow.jpg', 0)kernel = np.ones((5, 5), np.uint8)dilation = cv2.dilate(img,kernel,iterations = 1)cv2.imshow('dilation', dilation)cv2.waitKey(0)cv2.destroyAllWindows() 결과 3. Opening오프닝은 erosion과 dilation의 또 다른 이름입니다. 위에서 설명했듯이 노이즈를 제거하는데 유용합니다. 여기서는 cv2.morphologyEx() 함수를 사용합니다. 1opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel) 12345678910import cv2import numpy as npimg = cv2.imread('snow.jpg', 0)kernel = np.ones((5, 5), np.uint8)opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)cv2.imshow('opening', opening)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 4. ClosingClosing은 Opening과 반대입니다. 전경 오브젝트 내부의 작은 구멍이나 오브젝트의 작은 검은 점을 닫을 때 유용합니다. 1closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel) 12345678910import cv2import numpy as npimg = cv2.imread('snow.jpg', 0)kernel = np.ones((5, 5), np.uint8)closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)cv2.imshow('closing', closing)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 5. Morphological Gradient (형태학 기울기)그것은 이미지의 dilation과 erosion의 차이입니다. 결과는 객체의 윤곽선처럼 보입니다. 1gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel) 12345678910import cv2import numpy as npimg = cv2.imread('snow.jpg', 0)kernel = np.ones((5, 5), np.uint8)gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)cv2.imshow('gradient', gradient)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 6. Top Hat그것은 입력 이미지와 Opening 이미지의 차이입니다. 아래 예제는 9x9 커널에 대해 수행됩니다. 1tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel) 12345678910import cv2import numpy as npimg = cv2.imread('snow.jpg', 0)kernel = np.ones((5, 5), np.uint8)tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)cv2.imshow('tophat', tophat)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 7. Black Hat입력 이미지와 closing 이미지의 차이입니다. 1blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel) 12345678910import cv2import numpy as npimg = cv2.imread('snow.jpg', 0)kernel = np.ones((5, 5), np.uint8)blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)cv2.imshow('blackhat', blackhat)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 구조 요소Numpy의 도움을 받아 앞의 예제에서 수동으로 구조 요소를 만들었습니다. 사각형 모양입니다. 그러나 어떤 경우에는 타원형 / 원형 커널이 필요할 수 있습니다. 그래서 이 목적을 위해 OpenCV는 cv2.getStructuringElement() 함수를 가지고 있습니다. 커널의 모양과 크기 만 전달하면 원하는 커널을 얻을 수 있습니다. 1234567891011121314151617181920212223# Rectangular Kernel&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))array([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], dtype=uint8)# Elliptical Kernel&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5))array([[0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0]], dtype=uint8)# Cross-shaped Kernel&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_CROSS,(5,5))array([[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], dtype=uint8) 추가 리소스 HIPR2에서의 형태론적 조작 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_morphological_ops/py_morphological_ops.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 13. 이미지 Smoothing","slug":"2018/OpenCV-Python-Tutorials-13-이미지-Smoothing","date":"2018-01-13T10:15:42.000Z","updated":"2018-01-05T10:33:53.815Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-13-이미지-Smoothing/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-13-이미지-Smoothing/","excerpt":"","text":"[OpenCV-Python Tutorials] 13. 이미지 Smoothing목표배울 내용 다양한 저역 통과 필터로 이미지를 흐리게 처리. 이미지에 맞춤 필터 적용 (2D convolution) 2D Convolution (이미지 필터링)1차원 신호의 경우 이미지는 다양한 저역 통과 필터 (LPF), 고역 통과 필터 (HPF) 등으로 필터링 할 수도 있습니다. LPF는 노이즈를 제거하거나 이미지를 흐리게 합니다. HPF 필터는 이미지의 가장자리를 찾는 데 도움이 됩니다. OpenCV는 이미지로 커널을 컨볼루션하는 함수, cv2.filter2D()를 제공합니다. 예를 들어 이미지에 대한 평균화 필터를 시도해 보겠습니다. 5x5 평균 필터 커널은 다음과 같이 정의 할 수 있습니다. $$K = \\frac{1}{25} \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\end{bmatrix}$$ 위의 커널로 필터링하면 다음과 같은 결과가 발생합니다. 각 픽셀은 5x5 윈도우 픽셀의 가운데에 위치하며 이 창에 속하는 모든 픽셀을 더한 다음 결과를 25로 나눕니다. 해당 창 내부의 픽셀 값 중 이 작업은 출력 필터링 된 이미지를 생성하기 위해 이미지의 모든 픽셀에 대해 수행됩니다. 이 코드를 실행하고 결과를 확인하십시오. 123456789101112131415161718import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('model.jpg')img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)size = 50kernel = np.ones((size, size), np.float32) / (size * size)dst = cv2.filter2D(img, -1, kernel)cv2.imwrite('model_output.png', cv2.cvtColor(dst, cv2.COLOR_RGB2BGR))plt.subplot(121), plt.imshow(img), plt.title('Original')plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(dst), plt.title('Averaging')plt.xticks([]), plt.yticks([])plt.show() 결과: 변환 결과를 차이나게 만들기 위해서, 50 X 50 으로 변경하였습니다. 이미지 블러링 (이미지 스무딩)이미지 블러링은 이미지를 저역 통과 필터 커널과 컨볼루션함으로써 달성됩니다. 소음을 제거 할 때 유용합니다. 이 필터를 적용하면 이미지에서 고주파 콘텐츠 (예 : 노이즈, 가장자리)가 실제로 흐려져 가장자리가 흐려집니다. (모서리를 흐리게 하지 않는 흐림 기법이 있습니다.) OpenCV는 주로 네 가지 유형의 흐림 기술을 제공합니다. 1. 평균화이는 정규화된 상자 필터로 이미지를 컨벌루션하여 수행됩니다. 커널 영역 아래의 모든 픽셀의 평균을 취하고 중심 요소를 평균으로 바꿉니다. 이것은 cv2.blur() 또는 cv2.boxFilter() 함수에 의해 수행됩니다. 커널에 대한 자세한 내용은 문서를 확인하십시오. 커널의 너비와 높이를 지정해야합니다. 3x3 정규화 된 상자 필터는 다음과 같습니다. $$K = \\frac{1}{9} \\begin{bmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix}$$ 정규화된 상자 필터를 사용하지 않으려면 cv2.boxFilter()를 사용하고 normalize = False 인수를 함수에 전달합니다. 아래의 샘플 데모를 5x5 크기의 커널로 확인하십시오. 12345678910111213import cv2from matplotlib import pyplot as pltimg = cv2.imread('image.jpg')img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)blur = cv2.blur(img, (5, 5))plt.subplot(121), plt.imshow(img), plt.title('Original')plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(blur), plt.title('Blurred')plt.xticks([]), plt.yticks([])plt.show() 결과: 2. 가우시안 필터링이러한 접근법에서, 동일한 필터 계수로 구성된 박스 필터 대신에, 가우시안 커널이 사용된다. 함수 cv2.GaussianBlur()로 끝납니다. 커널의 너비와 높이를 지정해야 합니다. 커널의 너비와 높이는 양수이면서 홀수여야 합니다. X와 Y 방향의 표준 편차 sigmaX와 sigmaY를 각각 지정해야 합니다. sigmaX 만 지정된 경우 sigmaY는 sigmaX와 동일하게 취급됩니다. 둘 다 0으로 주어지면 커널 크기로부터 계산됩니다. 가우시안 필터링은 이미지에서 가우스 노이즈를 제거하는 데 매우 효과적입니다. 원하는 경우, 함수 cv2.getGaussianKernel()을 사용하여 가우스 커널을 생성 할 수 있습니다. 위의 코드는 가우시안 블러링으로 수정될 수 있습니다. 1blur = cv2.GaussianBlur(img,(5,5),0) 12345678910111213import cv2from matplotlib import pyplot as pltimg = cv2.imread('happy.png')img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)blur = cv2.GaussianBlur(img,(5,5),0)plt.subplot(121), plt.imshow(img), plt.title('Original')plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(blur), plt.title('Blurred')plt.xticks([]), plt.yticks([])plt.show() 결과: 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 12. 이미지의 기하학적 변환","slug":"2018/OpenCV-Python-Tutorials-12-이미지의-기하학적-변환","date":"2018-01-12T10:15:26.000Z","updated":"2018-01-05T10:33:53.815Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-12-이미지의-기하학적-변환/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-12-이미지의-기하학적-변환/","excerpt":"","text":"[OpenCV-Python Tutorials] 12. 이미지의 기하학적 변환목표 translation, 회전, affine 변환 등과 같은 이미지에 다른 기하학적 변환을 적용하는 방법을 배웁니다. 다음 함수를 볼 수 있습니다 : cv2.getPerspectiveTransform 변환OpenCV는 모든 종류의 변형을 가질 수 있는 두 가지 변환 함수, cv2.warpAffine 및 cv2.warpPerspective를 제공합니다. cv2.warpPerspective는 3x3 변환 행렬을 입력으로 받는 반면 cv2.warpAffine은 2x3 변환 행렬을 사용합니다. 스케일링크기 조절은 단지 이미지의 크기를 조절하는 것입니다. OpenCV는 이 목적을 위해 함수 cv2.resize()를 제공합니다. 이미지의 크기는 수동으로 지정하거나 배율 인수를 지정할 수 있습니다. 다른 보간 방법이 사용됩니다. 바람직한 보간 방법은 축소를 위한 cv2.INTER_AREA와 확대를 위한 cv2.INTER_CUBIC(느림) &amp; cv2.INTER_LINEAR입니다. 기본값으로, 모든 사이즈 변경을 위해 사용되는 보간 법은 cv2.INTER_LINEAR입니다. 다음 방법 중 하나를 사용하여 입력 이미지의 크기를 조정할 수 있습니다. 12345678910import cv2import numpy as npimg = cv2.imread('messi5.jpg')res = cv2.resize(img,None,fx=2, fy=2, interpolation = cv2.INTER_CUBIC)#ORheight, width = img.shape[:2]res = cv2.resize(img,(2*width, 2*height), interpolation = cv2.INTER_CUBIC) cv2.resize() 함수의 파라미터 src: 스케일링할 이미지 dsize: 변경할 사이즈. 가로, 세로 형태의 tuple fx – 가로 사이즈의 배수. 2배로 크게하려면 2. 반으로 줄이려면 0.5 fy – 세로 사이즈의 배수 interpolation – 보간법 코드12345678910111213import cv2from matplotlib import pyplot as pltimg = cv2.imread('beach.jpg')res1 = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)height, width = img.shape[:2]res2 = cv2.resize(img, (int(0.5 * width), int(0.5 * height)), interpolation=cv2.INTER_CUBIC)plt.subplot(1, 2, 1), plt.imshow(cv2.cvtColor(res1, cv2.COLOR_BGR2RGB)), plt.title('res1')plt.subplot(1, 2, 2), plt.imshow(cv2.cvtColor(res2, cv2.COLOR_BGR2RGB)), plt.title('res2')plt.show() matplotlib를 사용하여 표출할 경우에는 cv2.cvtColor(IMAGE, cv2.COLOR_BGR2RGB)를 호출하여 BGR 을 RGB로 변경해주어야 합니다. 변환변환은 물체의 위치를 이동시키는 것입니다. $$(x, y)$$ 방향의 변화를 알고 있다면 $$(t_x, t_y)$$, 다음과 같이 변환 행렬 $$\\textbf{M}$$을 만들 수 있습니다 : $$M = \\begin{bmatrix} 1 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; t_y \\end{bmatrix}$$ np.float32 유형의 Numpy 배열로 만들고 cv2.warpAffine() 함수로 전달할 수 있습니다. 아래 (100,50) 이동하는 아래 예를 참조하세요. 1234567891011121314import cv2import numpy as npimg = cv2.imread('model.jpg', 1)rows, cols = img.shape[:2]M = np.float32([[1, 0, 100], [0, 1, 50]])dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow('Original', img)cv2.imshow('warpAffine', dst)cv2.waitKey(0)cv2.destroyAllWindows() cv2.warpAffine() 함수의 세 번째 인수는 출력 이미지의 크기이며, 너비, 높이 형태여야 합니다. width = 열 수 및 height = 행 수를 기억하세요. 아래 결과를 확인하세요: 회전각도 $$\\theta$$에 대한 이미지의 회전은 형태의 변환 행렬에 의해 이루어진다. $$M = \\begin{bmatrix} cos\\theta &amp; -sin\\theta \\\\ sin\\theta &amp; cos\\theta \\end{bmatrix}$$ 그러나 OpenCV는 조정 가능한 회전 중심으로 크기가 조정 된 회전을 제공하므로 원하는 위치에서 회전 할 수 있습니다. 수정된 변환 행렬은 아래 수식에 의해 주어진다. $$\\begin{bmatrix} \\alpha &amp; \\beta &amp; (1- \\alpha ) \\cdot center.x - \\beta \\cdot center.y \\\\ - \\beta &amp; \\alpha &amp; \\beta \\cdot center.x + (1- \\alpha ) \\cdot center.y \\end{bmatrix}$$ where: $$\\begin{array}{l} \\alpha = scale \\cdot \\cos \\theta , \\\\ \\beta = scale \\cdot \\sin \\theta \\end{array}$$ 이 변환 행렬을 찾기 위해 OpenCV는 cv2.getRotationMatrix2D 함수를 제공합니다. 크기 조정없이 중앙을 기준으로 이미지를 90도 회전시키는 아래 예제를 확인하십시오. 12345678910111213import cv2img = cv2.imread('rotate.jpg', 1)rows, cols = img.shape[:2]M = cv2.getRotationMatrix2D((cols / 2, rows / 2), 90, 1)dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow('Original', img)cv2.imshow('warpAffine', dst)cv2.waitKey(0)cv2.destroyAllWindows() 결과보기 : Affine 변환Affine 변환에서 원본 이미지의 모든 평행선은 출력 이미지에서 여전히 평행합니다. 변환 행렬을 찾으려면 입력 이미지와 출력 이미지의 해당 위치에서 세 점이 필요합니다. 그런 다음 cv2.getAffineTransform은 cv2.warpAffine에 전달 될 2x3 행렬을 작성합니다. 아래 예제를 확인하고 선택한 점(녹색으로 표시)을 확인하십시오. 1234567891011121314151617import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('affine.jpg')rows, cols, ch = img.shape[:3]pts1 = np.float32([[50, 50], [200, 50], [50, 200]])pts2 = np.float32([[10, 100], [200, 50], [100, 250]])M = cv2.getAffineTransform(pts1, pts2)dst = cv2.warpAffine(img, M, (cols, rows))plt.subplot(121), plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)), plt.title('Input')plt.subplot(122), plt.imshow(cv2.cvtColor(dst, cv2.COLOR_BGR2RGB)), plt.title('Output')plt.show() 결과보기 : 원근법 변환원근감 변환의 경우 3x3 변환 행렬이 필요합니다. 직선은 변환 후에도 직선으로 유지됩니다. 이 변환 행렬을 찾으려면 입력 이미지와 출력 이미지의 해당 점에 4 포인트가 필요합니다. 이 4 점 중 3 점은 동일 선상에 있지 않아야 합니다. 그러면 변환 행렬은 함수 cv2.getPerspectiveTransform에서 찾을 수 있습니다. 그런 다음이 3x3 변환 행렬로 cv2.warpPerspective를 적용하십시오. 아래 코드를 참조하십시오. 123456789101112131415161718import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread('sudoku.jpg')rows, cols, ch = img.shape[:3]# pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389, 390]])pts1 = np.float32([[101, 131], [500, 114], [66, 504], [544, 489]])pts2 = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])M = cv2.getPerspectiveTransform(pts1, pts2)dst = cv2.warpPerspective(img, M, (300, 300))plt.subplot(121), plt.imshow(img), plt.title('Input')plt.subplot(122), plt.imshow(dst), plt.title('Output')plt.show() 결과: np.float32([[101, 131], [500, 114], [66, 504], [544, 489]]) 에서 배열은 좌상, 우상, 좌하, 우하 의 순으로 포인트를 나열한 것입니다. 추가 리소스 컴퓨터 비전 : 알고리즘 및 응용, Richard Szeliski (“Computer Vision: Algorithms and Applications”, Richard Szeliski) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html http://opencv-python.readthedocs.io/en/latest/# https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220504966397&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 11. 이미지 임계값","slug":"2018/OpenCV-Python-Tutorials-11-이미지-임계값","date":"2018-01-11T10:15:03.000Z","updated":"2018-01-05T10:33:53.858Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-11-이미지-임계값/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-11-이미지-임계값/","excerpt":"","text":"[OpenCV-Python Tutorials] 11. 이미지 임계값목표 이 튜토리얼에서는 Simple thresholding, Adaptive thresholding, Otsu의 thresholding 등을 배웁니다. cv2.threshold, cv2.adaptiveThreshold 등의 함수를 배웁니다. 단순 임계값여기서 문제는 간단합니다. 픽셀 값이 임계 값보다 크면 하나의 값 (흰색 일 수 있음)이 지정되고, 그렇지 않으면 다른 값 (검정 일 수 있음)이 지정됩니다. 사용 된 함수는 cv2.threshold입니다. 첫 번째 인수는 원본 이미지이며 그레이 스케일 이미지여야만 합니다. 두 번째 인수는 픽셀 값을 분류하는 데 사용되는 임계 값입니다. 세 번째 인수는 픽셀 값이 임계 값보다 크거나 (때로는 작지 만) 주어질 값을 나타내는 maxVal입니다. OpenCV는 다양한 스타일의 임계 값을 제공하며 함수의 네 번째 매개 변수에 의해 결정됩니다. 다른 유형은 다음과 같습니다. cv2.THRESH_BINARY cv2.THRESH_BINARY_INV cv2.THRESH_TRUNC cv2.THRESH_TOZERO cv2.THRESH_TOZERO_INV 문서는 각 유형의 의미를 명확히 설명합니다. 문서를 확인하십시오. 2 개의 출력이 얻어진다. 첫 번째는 나중에 설명 할 retval입니다. 두 번째 출력은 임계값 이미지입니다. 코드: 12345678910111213141516171819import cv2from matplotlib import pyplot as pltimg = cv2.imread('gradient.jpg', 0)ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)titles = ['Original Image', 'BINARY', 'BINARY_INV', 'TRUNC', 'TOZERO', 'TOZERO_INV']images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]for i in range(6): plt.subplot(2, 3, i + 1), plt.imshow(images[i], 'gray') plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 여러 이미지를 플롯하기 위해 plt.subplot() 함수를 사용했습니다. 자세한 내용은 Matplotlib 문서를 확인하십시오. 결과는 다음과 같습니다. 123def threshold(src, thresh, maxval, type, dst=None): # real signature unknown; restored from __doc__ \"\"\" threshold(src, thresh, maxval, type[, dst]) -&gt; retval, dst \"\"\" pass 적응형 임계값이전 섹션에서는 임계 값으로 전역 값을 사용했습니다. 그러나 이미지가 다른 영역에서 다른 조명 조건을 갖는 모든 조건에서 좋지 않을 수 있습니다. 이 경우 적응형 임계값을 찾습니다. 이 알고리즘은 이미지의 작은 영역에 대한 임계값을 계산합니다. 따라서 동일한 이미지의 서로 다른 영역에 대해 서로 다른 임계값을 얻을 수 있으며 다양한 조명을 사용하여 이미지를 더 나은 결과를 얻을 수 있습니다. 3 개의 &#39;특수&#39;입력 매개 변수와 하나의 출력 인수만 있습니다. 적응 방법 - 임계 값 계산 방법을 결정합니다. cv2.ADAPTIVE_THRESH_MEAN_C : 임계값은 인접 지역의 평균입니다. cv2.ADAPTIVE_THRESH_GAUSSIAN_C : 임계값은 가중치 가우시안 윈도우인 이웃값의 가중치 합입니다. Block Size - 인접 지역의 크기를 결정합니다. C - 계산 된 평균 또는 가중 평균에서 빼는 상수입니다. 아래 코드는 다양한 조명을 사용하는 이미지의 전역 임계값과 적응 임계값을 비교합니다. 1234567891011121314151617181920import cv2from matplotlib import pyplot as pltimg = cv2.imread('sunrise.jpg', 0)img = cv2.medianBlur(img, 5)ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)titles = ['Original Image', 'Global Thresholding (v = 127)', 'Adaptive Mean Thresholding', 'Adaptive Gaussian Thresholding']images = [img, th1, th2, th3]for i in range(4): plt.subplot(2, 2, i + 1), plt.imshow(images[i], 'gray') plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 123def adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C, dst=None): # real signature unknown; restored from __doc__ \"\"\" adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) -&gt; dst \"\"\" pass Otsu 이선화첫 번째 섹션에서는 retVal이라는 두 번째 매개 변수가 있다고 말씀드렸습니다. 오츠(Otsu)의 바이너리화(Binarization)를 할 때 사용됩니다. 무엇일까요? 전역 thresholding에서는 임계값에 임의의 값을 사용했습니다. 그렇다면 우리가 선택한 가치가 얼마나 좋은지 알 수 있습니까? 답은 시행 착오 방법입니다. 그러나 bimodal 이미지를 고려하십시오 (간단히 말하면, bimodal 이미지는 히스토그램에 두 개의 피크가 있는 이미지입니다). 그 이미지의 경우, 우리는 임계값으로 그 피크의 중간에서 값을 취할 수 있습니다. 맞습니까? Otsu 이진화가 그것이다. 따라서 간단한 말로, bimodal 이미지의 이미지 히스토그램으로부터 임계값을 자동으로 계산합니다. (bimodal이 아닌 이미지의 경우 이진화가 정확하지 않습니다.) 이를 위해 우리의 cv2.threshold() 함수가 사용되었지만 여분의 플래그인 cv2.THRESH_OTSU를 전달합니다. 임계값의 경우 단순히 0을 전달하십시오. 그런 다음 알고리즘은 최적임계 값을 찾아서 두 번째 출력인 retVal로 반환합니다. Otsu thresholding이 사용되지 않으면 retVal은 사용 된 임계값과 같습니다. 아래 예제를 확인하십시오. 입력 이미지는 잡음이 많은 이미지입니다. 첫 번째 경우에는 전역 임계값을 127로 적용했습니다. 두 번째 경우에는 Otsu의 임계값을 직접 적용했습니다. 세 번째 경우에는 노이즈를 제거하기 위해 5x5 가우시안 커널로 이미지를 필터링한 다음 Otsu thresholding을 적용했습니다. 노이즈 필터링이 어떻게 결과를 향상시키는 확인하십시오. 12345678910111213141516171819202122232425262728293031import cv2from matplotlib import pyplot as pltimg = cv2.imread('model.jpg', 0)# global thresholdingret1, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# Otsu's thresholdingret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# Otsu's thresholding after Gaussian filteringblur = cv2.GaussianBlur(img, (5, 5), 0)ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# plot all the images and their histogramsimages = [img, 0, th1, img, 0, th2, blur, 0, th3]titles = ['Original Noisy Image', 'Histogram', 'Global Thresholding (v=127)', 'Original Noisy Image', 'Histogram', \"Otsu's Thresholding\", 'Gaussian filtered Image', 'Histogram', \"Otsu's Thresholding\"]for i in range(3): plt.subplot(3, 3, i * 3 + 1), plt.imshow(images[i * 3], 'gray') plt.title(titles[i * 3]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 2), plt.hist(images[i * 3].ravel(), 256) plt.title(titles[i * 3 + 1]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 3), plt.imshow(images[i * 3 + 2], 'gray') plt.title(titles[i * 3 + 2]), plt.xticks([]), plt.yticks([])plt.show() 결과: Otsu 이진화 동작 방법이 섹션에서는 실제로 작동하는 방법을 보여주기 위해 Python이 Otsu의 이진화를 구현하는 방법을 보여줍니다. 관심이 없으면 이것을 건너 뛸 수 있습니다. Otsu의 알고리즘은 bimodal 이미지로 작업하기 때문에 관계에 의해 주어진 가중 클래스 내 분산을 최소화하는 임계 값 (t)을 찾으려고합니다. $$\\sigma_w^2(t) = q_1(t)\\sigma_1^2(t)+q_2(t)\\sigma_2^2(t)$$ where $$\\begin{array}{l}q1(t) = \\sum{i=1}^{t} P(i) \\quad \\&amp; \\quad q1(t) = \\sum{i=t+1}^{I} P(i) \\mu1(t) = \\sum{i=1}^{t} \\frac{iP(i)}{q_1(t)} \\quad \\&amp; \\quad \\mu2(t) = \\sum{i=t+1}^{I} \\frac{iP(i)}{q_2(t)} \\sigma1^2(t) = \\sum{i=1}^{t} [i-\\mu_1(t)]^2 \\frac{P(i)}{q_1(t)} \\quad \\&amp; \\quad \\sigma2^2(t) = \\sum{i=t+1}^{I} [i-\\mu_1(t)]^2 \\frac{P(i)}{q_2(t)}\\end{array}$$ 실제로 두 개의 피크 사이에있는 t의 값을 찾음으로써 두 클래스에 대한 분산이 최소가 되도록 합니다. 다음과 같이 간단하게 파이썬으로 구현할 수 있습니다 : 1234567891011121314151617181920212223242526272829303132333435import cv2import numpy as npimg = cv2.imread('model.jpg', 0)blur = cv2.GaussianBlur(img, (5, 5), 0)# find normalized_histogram, and its cumulative distribution functionhist = cv2.calcHist([blur], [0], None, [256], [0, 256])hist_norm = hist.ravel() / hist.max()Q = hist_norm.cumsum()bins = np.arange(256)fn_min = np.infthresh = -1for i in range(1, 256): p1, p2 = np.hsplit(hist_norm, [i]) # probabilities q1, q2 = Q[i], Q[255] - Q[i] # cum sum of classes b1, b2 = np.hsplit(bins, [i]) # weights # finding means and variances m1, m2 = np.sum(p1 * b1) / q1, np.sum(p2 * b2) / q2 v1, v2 = np.sum(((b1 - m1) ** 2) * p1) / q1, np.sum(((b2 - m2) ** 2) * p2) / q2 # calculates the minimization function fn = v1 * q1 + v2 * q2 if fn &lt; fn_min: fn_min = fn thresh = i# find otsu's threshold value with OpenCV functionret, otsu = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)print(thresh, ret) (일부 기능은 여기에서 새로 추가되었지만 다음 장에서 설명 할 것입니다.) 추가 리소스디지털 이미지 프로세싱, Rafael C. Gonzalez 연습 문제Otsu의 이진화에 사용할 수있는 최적화가 있습니다. 검색하고 구현할 수 있습니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html https://pixabay.com","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 10. 색상 공간 변경하기","slug":"2018/OpenCV-Python-Tutorials-10-색상-공간-변경하기","date":"2018-01-10T10:14:45.000Z","updated":"2018-01-05T10:14:53.707Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-10-색상-공간-변경하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-10-색상-공간-변경하기/","excerpt":"","text":"[OpenCV-Python Tutorials] 10. 색상 공간 변경하기목표 이 튜토리얼에서는 BGR $$\\leftrightarrow$$ Gray, BGR $$\\leftrightarrow$$ HSV 등과 같이 한 색상 공간에서 다른 색상 공간으로 이미지를 변환하는 방법을 배웁니다. 그 외에도 비디오에서 채색 된 객체를 추출하는 응용 프로그램을 만듭니다. 다음 함수를 배울 것입니다 : cv2.cvtColor(), cv2.inRange() 등등. 색 공간 변경하기OpenCV에는 150 가지 이상의 색 공간 변환 방법이 있습니다. 그러나 우리는 가장 널리 사용되는 두 가지를 살펴볼 것입니다. BGR $$\\leftrightarrow$$ Gray와 BGR $$\\leftrightarrow$$ HSV. 색상 변환을 위해 함수 cv2.cvtColor(input_image, flag)를 사용합니다. 여기서 flag는 변환 유형을 결정합니다. BGR $$\\rightarrow$$ 회색 변환의 경우 우리는 플래그 cv2.COLOR_BGR2GRAY를 사용합니다. 마찬가지로 BGR $$\\rightarrow$$ HSV에 대해서도 플래그 cv2.COLOR_BGR2HSV를 사용합니다. 다른 플래그를 얻으려면 Python 터미널에서 다음 명령을 실행하십시오. 1234567import cv2flags = [i for i in dir(cv2) if i.startswith('COLOR_')]print(flags)# 출력 : ['COLOR_BAYER_BG2BGR', 'COLOR_BAYER_BG2BGR_EA', 'COLOR_BAYER_BG2BGR_VNG', 'COLOR_BAYER_BG2GRAY', 'COLOR_BAYER_BG2RGB', 'COLOR_BAYER_BG2RGB_EA', 'COLOR_BAYER_BG2RGB_VNG', 'COLOR_BAYER_GB2BGR', 'COLOR_BAYER_GB2BGR_EA', 'COLOR_BAYER_GB2BGR_VNG', 'COLOR_BAYER_GB2GRAY', 'COLOR_BAYER_GB2RGB', 'COLOR_BAYER_GB2RGB_EA', 'COLOR_BAYER_GB2RGB_VNG', 'COLOR_BAYER_GR2BGR', 'COLOR_BAYER_GR2BGR_EA', 'COLOR_BAYER_GR2BGR_VNG', 'COLOR_BAYER_GR2GRAY', 'COLOR_BAYER_GR2RGB', 'COLOR_BAYER_GR2RGB_EA', 'COLOR_BAYER_GR2RGB_VNG', 'COLOR_BAYER_RG2BGR', 'COLOR_BAYER_RG2BGR_EA', 'COLOR_BAYER_RG2BGR_VNG', 'COLOR_BAYER_RG2GRAY', 'COLOR_BAYER_RG2RGB', 'COLOR_BAYER_RG2RGB_EA', 'COLOR_BAYER_RG2RGB_VNG', 'COLOR_BGR2BGR555', 'COLOR_BGR2BGR565', 'COLOR_BGR2BGRA', 'COLOR_BGR2GRAY', 'COLOR_BGR2HLS', 'COLOR_BGR2HLS_FULL', 'COLOR_BGR2HSV', 'COLOR_BGR2HSV_FULL', 'COLOR_BGR2LAB', 'COLOR_BGR2LUV', 'COLOR_BGR2Lab', 'COLOR_BGR2Luv', 'COLOR_BGR2RGB', 'COLOR_BGR2RGBA', 'COLOR_BGR2XYZ', 'COLOR_BGR2YCR_CB', 'COLOR_BGR2YCrCb', 'COLOR_BGR2YUV', 'COLOR_BGR2YUV_I420', 'COLOR_BGR2YUV_IYUV', 'COLOR_BGR2YUV_YV12', 'COLOR_BGR5552BGR', 'COLOR_BGR5552BGRA', 'COLOR_BGR5552GRAY', 'COLOR_BGR5552RGB', 'COLOR_BGR5552RGBA', 'COLOR_BGR5652BGR', 'COLOR_BGR5652BGRA', 'COLOR_BGR5652GRAY', 'COLOR_BGR5652RGB', 'COLOR_BGR5652RGBA', 'COLOR_BGRA2BGR', 'COLOR_BGRA2BGR555', 'COLOR_BGRA2BGR565', 'COLOR_BGRA2GRAY', 'COLOR_BGRA2RGB', 'COLOR_BGRA2RGBA', 'COLOR_BGRA2YUV_I420', 'COLOR_BGRA2YUV_IYUV', 'COLOR_BGRA2YUV_YV12', 'COLOR_BayerBG2BGR', 'COLOR_BayerBG2BGR_EA', 'COLOR_BayerBG2BGR_VNG', 'COLOR_BayerBG2GRAY', 'COLOR_BayerBG2RGB', 'COLOR_BayerBG2RGB_EA', 'COLOR_BayerBG2RGB_VNG', 'COLOR_BayerGB2BGR', 'COLOR_BayerGB2BGR_EA', 'COLOR_BayerGB2BGR_VNG', 'COLOR_BayerGB2GRAY', 'COLOR_BayerGB2RGB', 'COLOR_BayerGB2RGB_EA', 'COLOR_BayerGB2RGB_VNG', 'COLOR_BayerGR2BGR', 'COLOR_BayerGR2BGR_EA', 'COLOR_BayerGR2BGR_VNG', 'COLOR_BayerGR2GRAY', 'COLOR_BayerGR2RGB', 'COLOR_BayerGR2RGB_EA', 'COLOR_BayerGR2RGB_VNG', 'COLOR_BayerRG2BGR', 'COLOR_BayerRG2BGR_EA', 'COLOR_BayerRG2BGR_VNG', 'COLOR_BayerRG2GRAY', 'COLOR_BayerRG2RGB', 'COLOR_BayerRG2RGB_EA', 'COLOR_BayerRG2RGB_VNG', 'COLOR_COLORCVT_MAX', 'COLOR_GRAY2BGR', 'COLOR_GRAY2BGR555', 'COLOR_GRAY2BGR565', 'COLOR_GRAY2BGRA', 'COLOR_GRAY2RGB', 'COLOR_GRAY2RGBA', 'COLOR_HLS2BGR', 'COLOR_HLS2BGR_FULL', 'COLOR_HLS2RGB', 'COLOR_HLS2RGB_FULL', 'COLOR_HSV2BGR', 'COLOR_HSV2BGR_FULL', 'COLOR_HSV2RGB', 'COLOR_HSV2RGB_FULL', 'COLOR_LAB2BGR', 'COLOR_LAB2LBGR', 'COLOR_LAB2LRGB', 'COLOR_LAB2RGB', 'COLOR_LBGR2LAB', 'COLOR_LBGR2LUV', 'COLOR_LBGR2Lab', 'COLOR_LBGR2Luv', 'COLOR_LRGB2LAB', 'COLOR_LRGB2LUV', 'COLOR_LRGB2Lab', 'COLOR_LRGB2Luv', 'COLOR_LUV2BGR', 'COLOR_LUV2LBGR', 'COLOR_LUV2LRGB', 'COLOR_LUV2RGB', 'COLOR_Lab2BGR', 'COLOR_Lab2LBGR', 'COLOR_Lab2LRGB', 'COLOR_Lab2RGB', 'COLOR_Luv2BGR', 'COLOR_Luv2LBGR', 'COLOR_Luv2LRGB', 'COLOR_Luv2RGB', 'COLOR_M_RGBA2RGBA', 'COLOR_RGB2BGR', 'COLOR_RGB2BGR555', 'COLOR_RGB2BGR565', 'COLOR_RGB2BGRA', 'COLOR_RGB2GRAY', 'COLOR_RGB2HLS', 'COLOR_RGB2HLS_FULL', 'COLOR_RGB2HSV', 'COLOR_RGB2HSV_FULL', 'COLOR_RGB2LAB', 'COLOR_RGB2LUV', 'COLOR_RGB2Lab', 'COLOR_RGB2Luv', 'COLOR_RGB2RGBA', 'COLOR_RGB2XYZ', 'COLOR_RGB2YCR_CB', 'COLOR_RGB2YCrCb', 'COLOR_RGB2YUV', 'COLOR_RGB2YUV_I420', 'COLOR_RGB2YUV_IYUV', 'COLOR_RGB2YUV_YV12', 'COLOR_RGBA2BGR', 'COLOR_RGBA2BGR555', 'COLOR_RGBA2BGR565', 'COLOR_RGBA2BGRA', 'COLOR_RGBA2GRAY', 'COLOR_RGBA2M_RGBA', 'COLOR_RGBA2RGB', 'COLOR_RGBA2YUV_I420', 'COLOR_RGBA2YUV_IYUV', 'COLOR_RGBA2YUV_YV12', 'COLOR_RGBA2mRGBA', 'COLOR_XYZ2BGR', 'COLOR_XYZ2RGB', 'COLOR_YCR_CB2BGR', 'COLOR_YCR_CB2RGB', 'COLOR_YCrCb2BGR', 'COLOR_YCrCb2RGB', 'COLOR_YUV2BGR', 'COLOR_YUV2BGRA_I420', 'COLOR_YUV2BGRA_IYUV', 'COLOR_YUV2BGRA_NV12', 'COLOR_YUV2BGRA_NV21', 'COLOR_YUV2BGRA_UYNV', 'COLOR_YUV2BGRA_UYVY', 'COLOR_YUV2BGRA_Y422', 'COLOR_YUV2BGRA_YUNV', 'COLOR_YUV2BGRA_YUY2', 'COLOR_YUV2BGRA_YUYV', 'COLOR_YUV2BGRA_YV12', 'COLOR_YUV2BGRA_YVYU', 'COLOR_YUV2BGR_I420', 'COLOR_YUV2BGR_IYUV', 'COLOR_YUV2BGR_NV12', 'COLOR_YUV2BGR_NV21', 'COLOR_YUV2BGR_UYNV', 'COLOR_YUV2BGR_UYVY', 'COLOR_YUV2BGR_Y422', 'COLOR_YUV2BGR_YUNV', 'COLOR_YUV2BGR_YUY2', 'COLOR_YUV2BGR_YUYV', 'COLOR_YUV2BGR_YV12', 'COLOR_YUV2BGR_YVYU', 'COLOR_YUV2GRAY_420', 'COLOR_YUV2GRAY_I420', 'COLOR_YUV2GRAY_IYUV', 'COLOR_YUV2GRAY_NV12', 'COLOR_YUV2GRAY_NV21', 'COLOR_YUV2GRAY_UYNV', 'COLOR_YUV2GRAY_UYVY', 'COLOR_YUV2GRAY_Y422', 'COLOR_YUV2GRAY_YUNV', 'COLOR_YUV2GRAY_YUY2', 'COLOR_YUV2GRAY_YUYV', 'COLOR_YUV2GRAY_YV12', 'COLOR_YUV2GRAY_YVYU', 'COLOR_YUV2RGB', 'COLOR_YUV2RGBA_I420', 'COLOR_YUV2RGBA_IYUV', 'COLOR_YUV2RGBA_NV12', 'COLOR_YUV2RGBA_NV21', 'COLOR_YUV2RGBA_UYNV', 'COLOR_YUV2RGBA_UYVY', 'COLOR_YUV2RGBA_Y422', 'COLOR_YUV2RGBA_YUNV', 'COLOR_YUV2RGBA_YUY2', 'COLOR_YUV2RGBA_YUYV', 'COLOR_YUV2RGBA_YV12', 'COLOR_YUV2RGBA_YVYU', 'COLOR_YUV2RGB_I420', 'COLOR_YUV2RGB_IYUV', 'COLOR_YUV2RGB_NV12', 'COLOR_YUV2RGB_NV21', 'COLOR_YUV2RGB_UYNV', 'COLOR_YUV2RGB_UYVY', 'COLOR_YUV2RGB_Y422', 'COLOR_YUV2RGB_YUNV', 'COLOR_YUV2RGB_YUY2', 'COLOR_YUV2RGB_YUYV', 'COLOR_YUV2RGB_YV12', 'COLOR_YUV2RGB_YVYU', 'COLOR_YUV420P2BGR', 'COLOR_YUV420P2BGRA', 'COLOR_YUV420P2GRAY', 'COLOR_YUV420P2RGB', 'COLOR_YUV420P2RGBA', 'COLOR_YUV420SP2BGR', 'COLOR_YUV420SP2BGRA', 'COLOR_YUV420SP2GRAY', 'COLOR_YUV420SP2RGB', 'COLOR_YUV420SP2RGBA', 'COLOR_YUV420p2BGR', 'COLOR_YUV420p2BGRA', 'COLOR_YUV420p2GRAY', 'COLOR_YUV420p2RGB', 'COLOR_YUV420p2RGBA', 'COLOR_YUV420sp2BGR', 'COLOR_YUV420sp2BGRA', 'COLOR_YUV420sp2GRAY', 'COLOR_YUV420sp2RGB', 'COLOR_YUV420sp2RGBA', 'COLOR_mRGBA2RGBA'] HSV의 경우 색조 범위는 [0,179], 채도 범위는 [0,255], 값 범위는 [0,255]입니다. 서로 다른 소프트웨어는 서로 다른 가늠자를 사용합니다. 따라서 OpenCV 값을 비교하는 경우이 범위를 정규화 해야 합니다. 객체 추적이제 우리는 BGR 이미지를 HSV로 변환하는 방법을 알고 있습니다. 이 도구를 사용하여 색상이 지정된 객체를 추출 할 수 있습니다. HSV에서는 RGB 색상 공간보다 색상을 표현하는 것이 더 쉽습니다. 우리의 응용 프로그램에서 우리는 파란색 객체를 추출하려고합니다. 그래서 여기에 방법이 있습니다 : 비디오의 각 프레임 가져 오기 BGR에서 HSV 색 공간으로 변환 우리는 파란색 범위의 HSV 이미지를 임계값으로 설정합니다. 이제 파란색 물체 만 추출하면 우리가 원하는 이미지를 만들 수 있습니다. 아래 코드에 자세히 설명되어 있습니다 : 1234567891011121314151617181920212223242526272829303132import cv2import numpy as npfile = 'blue_light.mp4'cap = cv2.VideoCapture(file)while True: # Take each frame _, frame = cap.read() # Convert BGR to HSV hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) # define range of blue color in HSV lower_blue = np.array([110, 50, 50]) upper_blue = np.array([130, 255, 255]) # Threshold the HSV image to get only blue colors mask = cv2.inRange(hsv, lower_blue, upper_blue) # Bitwise-AND mask and original image res = cv2.bitwise_and(frame, frame, mask=mask) cv2.imshow('frame', frame) cv2.imshow('mask', mask) cv2.imshow('res', res) k = cv2.waitKey(5) &amp; 0xFF if k == 27: breakcv2.destroyAllWindows() 아래 이미지는 파란색 물체의 추적을 보여줍니다. 이미지에 약간의 노이즈가 있습니다. 나중 챕터에서 제거하는 방법을 살펴볼 것입니다. 이것은 객체 추적에서 가장 간단한 방법입니다. 윤곽선의 기능을 익히면이 물체의 중심을 찾아 객체를 추적하는 데 사용할 수 있고 카메라 앞에 손을 움직여 다이어그램을 그릴 수 있습니다. 추적 할 HSV 값은 어떻게 찾을까요?이것은 stackoverflow.com 에 있는 일반적인 질문입니다. 그것은 매우 간단하며 동일한 함수, cv2.cvtColor()를 사용할 수 있습니다. 이미지를 전달하는 대신 원하는 BGR 값을 전달하면 됩니다. 예를 들어, Green의 HSV 값을 찾으려면 Python 터미널에서 다음 명령을 시도하십시오. 12345678import cv2import numpy as npgreen = np.uint8([[[0, 255, 0]]])hsv_green = cv2.cvtColor(green, cv2.COLOR_BGR2HSV)print(hsv_green)# 출력 : [[[ 60 255 255]]] 이제 [H-10, 100,100]과 [H + 10, 255, 255]를 하한선과 상한선으로 취합니다. 이 방법 외에도 GIMP 또는 온라인 변환기와 같은 이미지 편집 도구를 사용하여 이러한 값을 찾을 수 있지만 HSV 범위를 조정하는 것을 잊지 마십시오. 연습 문제예를 들어 적색, 청색, 녹색 물체를 동시에 추출하기 위해 하나 이상의 색상이 있는 물체를 추출하는 방법을 찾으십시오. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 09 성능 측정 및 개선 기법","slug":"2018/OpenCV-Python-Tutorials-09-성능-측정-및-개선-기법","date":"2018-01-09T10:14:25.000Z","updated":"2018-01-05T10:14:33.360Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-09-성능-측정-및-개선-기법/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-09-성능-측정-및-개선-기법/","excerpt":"","text":"[OpenCV-Python Tutorials] 09 성능 측정 및 개선 기법목표이미지 처리에서는 초당 많은 작업을 처리하기 때문에 코드가 올바른 솔루션을 제공 할 뿐만 아니라 가장 빠른 방식으로 제공되어야 합니다. 따라서 이 장에서는 다음과 같은 내용을 배울 수 있습니다. 코드의 성능을 측정합니다. 코드의 성능을 향상시키기 위한 몇 가지 팁. cv2.getTickCount, cv2.getTickFrequency 등의 함수를 확인합니다. OpenCV 외에도 Python은 실행 시간을 측정하는 데 유용한 모듈 시간을 제공합니다. 다른 모듈 프로파일은 코드의 각 함수가 얼마나 많은 시간을 사용하는지, 얼마나 많은 시간이 함수가 호출되었는지 등과 같은 코드에 대한 자세한 보고서를 얻는 데 도움이 됩니다. IPython을 사용하는 경우 이러한 모든 기능이 사용자 친화적 방법으로 포함되어 있습니다. 우리는 몇 가지 중요한 것들을 보게 될 것이며, 자세한 내용은 Additional Resouces 섹션의 링크를 확인하십시오. OpenCV로 성능 측정cv2.getTickCount 함수는 이 함수가 호출되는 순간까지 참조 이벤트 (순간 기계가 켜졌을 때처럼) 이후의 클럭 사이클 수를 반환합니다. 따라서 함수를 실행하기 전후에 함수를 호출하면 함수를 실행하는데 사용되는 클럭 사이클 수를 얻게 됩니다. cv2.getTickFrequency 함수는 클럭 사이클의 빈도 또는 초당 클럭 사이클 수를 반환합니다. 따라서 실행 시간을 초 단위로 확인하려면 다음을 수행 할 수 있습니다. 1234e1 = cv2.getTickCount()# your code executione2 = cv2.getTickCount()time = (e2 - e1)/ cv2.getTickFrequency() 우리는 다음 예제를 통해 설명 할 것입니다. 다음 예제는 5부터 49까지의 홀수 크기의 커널을 사용하여 중간 필터링을 적용합니다. (결과가 어떻게 보이는지 걱정하지 마십시오. 이것은 우리의 목표가 아닙니다.) 12345678910111213141516171819import cv2img1 = cv2.imread('model.jpg')e1 = cv2.getTickCount()for i in range(5, 49, 2): img2 = cv2.medianBlur(img1, i)e2 = cv2.getTickCount()t = (e2 - e1) / cv2.getTickFrequency()cv2.imshow('Original', img1)cv2.imshow('Blur', img2)cv2.waitKey(0)cv2.destroyAllWindows()print(t)# 결과: 2.5564403101561437 당신은 time 모듈을 사용할 수도 있습니다. cv2.getTickCount 대신 time.time() 함수를 사용하십시오. 그런 다음 두 시각의 차이를 사용하면 됩니다. OpenCV의 기본 최적화많은 OpenCV 기능은 SSE2, AVX 등을 사용하여 최적화됩니다. 최적화되지 않은 코드도 포함되어 있습니다. 따라서 우리 시스템이 이러한 기능을 지원한다면, 우리는 이를 이용해야합니다 (거의 모든 현대 프로세서가 이를 지원합니다). 컴파일하는 동안 기본적으로 활성화됩니다. 따라서 OpenCV는 최적화 된 코드를 실행하면 활성화되고 그렇지 않으면 최적화되지 않은 코드가 실행됩니다. cv2.useOptimized()를 사용하여 활성화 / 비활성화되어 있는지 확인하고 cv2.setUseOptimized()를 사용하여 활성화 / 비활성화 할 수 있습니다. 간단한 예를 봅시다. 123456789101112131415# check if optimization is enabledIn [5]: cv2.useOptimized()Out[5]: TrueIn [6]: %timeit res = cv2.medianBlur(img,49)10 loops, best of 3: 34.9 ms per loop# Disable itIn [7]: cv2.setUseOptimized(False)In [8]: cv2.useOptimized()Out[8]: FalseIn [9]: %timeit res = cv2.medianBlur(img,49)10 loops, best of 3: 64.1 ms per loop 최적화 된 중앙 필터링은 최적화되지 않은 버전보다 ~2 배 빠릅니다. 소스를 확인하면 중간 필터링이 SIMD에 최적화 된 것을 볼 수 있습니다. 따라서 이것을 사용하여 코드 상단에서 최적화를 활성화 할 수 있습니다 (기본적으로 활성화되어 있음을 기억하십시오). IPython에서 성능 측정때로는 두 가지 유사한 작업의 성능을 비교해야 할 수도 있습니다. IPython은 이것을 수행하는 마법 명령 %timeit 제공합니다. 더 정확한 결과를 얻기 위해 코드를 여러 번 실행합니다. 다시 한번 말하지만, 단일 라인 코드를 측정하는 데 적합합니다. 예를 들어, 다음 중 더 나은 연산이 어떤것인지 알 수 있습니까? x = 5; y = x ** 2 x = 5; y = x * x x = np.uint8([5]); y = x * x 또는 y = np.square(x)? 우리는 IPython 셸에서 %timeit을 사용하여 찾아보겠습니다. 123456789101112131415In [10]: x = 5In [11]: %timeit y=x**210000000 loops, best of 3: 73 ns per loopIn [12]: %timeit y=x*x10000000 loops, best of 3: 58.3 ns per loopIn [15]: z = np.uint8([5])In [17]: %timeit y=z*z1000000 loops, best of 3: 1.25 us per loopIn [19]: %timeit y=np.square(z)1000000 loops, best of 3: 1.16 us per loop x = 5; y = x * x는 가장 빠르며 Numpy에 비해 20 배 정도 빠른 것을 확인할 수 있습니다. 배열 생성도 고려한다면 최대 100 배까지 빨라질 수 있습니다. 멋지지 않습니까? (Numpy devs는이 문제를 해결하기 위해 노력하고 있습니다) 파이썬 스칼라 연산은 Numpy 스칼라 연산보다 빠릅니다. 따라서 하나 또는 두 개의 요소를 포함하는 연산의 경우 Python 스칼라가 Numpy 배열보다 낫습니다. Numpy는 배열의 크기가 조금 더 클 때 이점을 취합니다. 우리는 한 가지 더 많은 예제를 시도 할 것입니다. 이번에는 동일한 이미지에 대해 cv2.countNonZero() 및 np.count_nonzero()의 성능을 비교합니다. 12345In [35]: %timeit z = cv2.countNonZero(img)100000 loops, best of 3: 15.8 us per loopIn [36]: %timeit z = np.count_nonzero(img)1000 loops, best of 3: 370 us per loop OpenCV 기능이 Numpy 기능보다 25배 빠릅니다. 일반적으로 OpenCV 기능은 Numpy 기능보다 빠릅니다. 따라서 동일한 작업을 위해 OpenCV 기능이 선호됩니다. 그러나 예외가 있을 수 있습니다. 특히 Numpy가 사본 대신 보기를 사용할 때 그렇습니다. 더 많은 IPython 마법 명령성능, 프로파일링, 라인 프로파일링, 메모리 측정 등을 측정하는 몇 가지 다른 마법 명령이 있습니다. 그것들 모두 잘 문서화되어 있습니다. 따라서 해당 문서에 대한 링크만 제공됩니다. 관심있는 독자는 링크를 확인하시기 바랍니다. 성능 최적화 기법Python과 Numpy의 최대 성능을 활용하기 위한 몇 가지 기술과 코딩 방법이 있습니다. 관련된 것만이 여기에 표시되며 링크는 중요한 출처에 제공됩니다. 여기서 주목해야 할 점은 먼저 알고리즘을 간단한 방식으로 구현하려고 시도한다는 것입니다. 일단 작동되면 프로파일링하고 병목 현상을 찾아 최적화하십시오. Python에서 가능한 한 루프를 사용하지 마십시오. 특히 이중 / 삼중 루프 등은 본질적으로 느립니다. Numpy와 OpenCV가 벡터 연산에 최적화되어 있기 때문에 알고리즘 / 코드를 가능한 최대로 벡터화하십시오. 캐시 일관성을 이용하십시오. 필요하지 않으면 배열의 복사본을 만들지 마십시오. 대신 보기를 사용해보십시오. 배열 복사는 비용이 많이 드는 작업입니다. 이러한 모든 작업을 수행 한 후에도 코드가 여전히 느리거나 큰 루프를 사용해야하는 경우에는 Cython과 같은 추가 라이브러리를 사용하여 더 빨리 수행 할 수 있습니다. 추가 리소스 파이썬 최적화 기법 Scipy 강의 노트 - 고급 Numpy IPython의 타이밍 및 프로파일링 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_optimization/py_optimization.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials 06] 색상표 트랙바 사용하기","slug":"2018/OpenCV-Python-Tutorials-06-색상표-트랙바-사용하기","date":"2018-01-06T10:12:16.000Z","updated":"2018-01-05T10:12:24.765Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-06-색상표-트랙바-사용하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-06-색상표-트랙바-사용하기/","excerpt":"","text":"[OpenCV-Python Tutorials 06] 색상표 트랙바 사용하기목표 트랙바를 OpenCV 창에 바인딩하는 방법 배우기 cv2.getTrackbarPos(), cv2.createTrackbar() 등의 함수를 배웁니다. 코드 데모여기에서는 지정한 색상을 보여주는 간단한 응용 프로그램을 만듭니다. B, G, R 각 색상을 지정하는 색상과 세 개의 트랙바를 보여주는 창이 있습니다. 트랙바를 슬라이드하고 그에 따라 창 색상이 변경됩니다. 기본적으로 초기 색은 검은색으로 설정됩니다. cv2.getTrackbarPos() 함수의 경우 첫 번째 인수는 트랙바 이름이고, 두 번째 인수는 연결될 창 이름이며 세 번째 인수는 기본값이며 네 번째 매개 변수는 최대값이며 다섯 번째 매개 변수는 실행되는 콜백 함수입니다 트랙볼 값이 매번 변경됩니다. 콜백 함수에는 항상 트랙바 위치인 기본 인수가 있습니다. 우리의 경우 함수는 아무 것도하지 않으므로 간단히 패스합니다. 파라미터 목록 트랙바 이름 연결될 창 이름 기본값 최대값 콜백 함수 트랙바의 또 다른 중요한 응용 프로그램은 단추 또는 스위치로 사용하는 것입니다. OpenCV는 기본적으로 버튼 기능이 없습니다. 따라서 트랙바를 사용하여 이러한 기능을 사용할 수 있습니다. 우리의 응용 프로그램에서는 스위치가 ON 인 경우에만 응용 프로그램이 작동하는 스위치 하나를 만들었습니다. 그렇지 않으면 화면이 항상 검은색입니다. 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npdef nothing(x): pass# Create a black image, a windowimg = np.zeros((300,512,3), np.uint8)cv2.namedWindow('image')# create trackbars for color changecv2.createTrackbar('R','image',0,255,nothing)cv2.createTrackbar('G','image',0,255,nothing)cv2.createTrackbar('B','image',0,255,nothing)# create switch for ON/OFF functionalityswitch = '0 : OFF \\n1 : ON'cv2.createTrackbar(switch, 'image',0,1,nothing)while(1): cv2.imshow('image',img) k = cv2.waitKey(1) &amp; 0xFF if k == 27: break # get current positions of four trackbars r = cv2.getTrackbarPos('R','image') g = cv2.getTrackbarPos('G','image') b = cv2.getTrackbarPos('B','image') s = cv2.getTrackbarPos(switch,'image') if s == 0: img[:] = 0 else: img[:] = [b,g,r]cv2.destroyAllWindows() 애플리케이션의 스크린 샷은 다음과 같습니다. ESC 키를 눌러서 윈도우를 종료합니다. 연습 문제트랙 바를 사용하여 색상 및 브러쉬 반경을 조정할 수있는 페인트 응용 프로그램을 만듭니다. 그리기에 대해서는 마우스 조작에 대한 이전 자습서를 참조하십시오. 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npdef nothing(x): pass# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: # get current positions of four trackbars r = cv2.getTrackbarPos('R', 'image') g = cv2.getTrackbarPos('G', 'image') b = cv2.getTrackbarPos('B', 'image') d = cv2.getTrackbarPos('Distance', 'image') cv2.circle(img, (x, y), d, (b, g, r), -1)# Create a black image, a windowimg = np.zeros((300,512,3), np.uint8)cv2.namedWindow('image')# create trackbars for color changecv2.createTrackbar('R','image',0,255, nothing)cv2.createTrackbar('G','image',0,255, nothing)cv2.createTrackbar('B','image',0,255, nothing)cv2.createTrackbar('Distance','image',0,255, nothing)cv2.setMouseCallback('image', draw_circle)while(1): cv2.imshow('image',img) k = cv2.waitKey(1) &amp; 0xFF if k == 27: breakcv2.destroyAllWindows() 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_trackbar/py_trackbar.html","categories":[],"tags":[]},{"title":"Hello World","slug":"2018/hello-world","date":"2018-01-05T11:16:26.285Z","updated":"2018-01-05T05:26:15.529Z","comments":true,"path":"2018/hello-world/","link":"","permalink":"http://jacegem.github.io/blog/2018/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Github 에 ssh 사용하기","slug":"2016/ssh","date":"2018-01-05T11:16:25.805Z","updated":"2018-01-05T06:31:30.195Z","comments":true,"path":"2016/ssh/","link":"","permalink":"http://jacegem.github.io/blog/2016/ssh/","excerpt":"","text":"ssh-keygen -R github.comssh -v github.com C:\\Users\\[사용자명]\\.ssh 경로에 ssh 파일이 저장됩니다.","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials] 08 이미지의 산술 연산","slug":"2018/OpenCV-Python-Tutorials-08-이미지의-산술-연산","date":"2018-01-05T10:12:55.000Z","updated":"2018-01-05T10:33:53.859Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-08-이미지의-산술-연산/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-08-이미지의-산술-연산/","excerpt":"","text":"[OpenCV-Python Tutorials] 08 이미지의 산술 연산목표 더하기, 빼기, 비트 연산 등과 같은 이미지에 대한 여러 가지 산술 연산에 대해 배웁니다. cv2.add(), cv2.addWeighted() 등의 함수를 배우게 됩니다. 이미지 추가OpenCV 함수 cv2.add() 또는 단순히 numpy 연산인 res = img1 + img2로 두 개의 이미지를 추가 할 수 있습니다. 두 이미지는 모두 같은 깊이와 유형이어야 하며 두 번째 이미지는 스칼라 값일 수 있습니다. OpenCV 추가와 Numpy 추가에는 차이가 있습니다. OpenCV 추가는 포화된 작업이며 Numpy 추가는 모듈러스 연산입니다. 예를 들어, 다음 샘플을 확인하십시오. 12345678&gt;&gt;&gt; x = np.uint8([250])&gt;&gt;&gt; y = np.uint8([10])&gt;&gt;&gt; print cv2.add(x,y) # 250+10 = 260 =&gt; 255[[255]]&gt;&gt;&gt; print x+y # 250+10 = 260 % 256 = 4[4] 두 개의 이미지를 추가하면 더 잘 보입니다. OpenCV 기능이 더 나은 결과를 제공합니다. 항상 OpenCV 기능을 더 잘 사용하십시오. 코드12345678import cv2import numpy as npx = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y)) # 250+10 = 260 =&gt; 255print(x + y) # 250+10 = 260 % 256 = 4 이미지 블렌딩이것은 이미지 추가이지만 이미지에 다른 가중치가 주어지기 때문에 블렌딩이나 투명성을 부여합니다. 이미지는 아래의 방정식에 따라 추가됩니다. $$g(x) = (1-\\alpha)f_0(x) + \\alpha f_1(x)$$ $$\\alpha$$ 값을 0에서 1로 변경하면서 이미지간에 멋진 전환을 수행 할 수 있습니다. 섞기 위해 두 개의 이미지를 사용했습니다. 첫 번째 이미지에는 0.7의 가중치가 부여되고 두 번째 이미지에는 0.3이 주어집니다. cv2.addWeighted()는 이미지에 다음 방정식을 적용합니다. $$dst = \\alpha \\cdot img1 + \\beta \\cdot img2 + \\gamma$$ 여기서 $$\\gamma$$는 0으로 간주됩니다. 12345678910import cv2img1 = cv2.imread('resize_model1.jpg')img2 = cv2.imread('resize_model2.jpg')dst = cv2.addWeighted(img1, 0.7, img2, 0.3, 0)cv2.imshow('dst', dst)cv2.waitKey(0)cv2.destroyAllWindows() 아래의 결과를 확인하십시오: 두 이미지의 사이즈가 동일해야 합니다. 비트 연산여기에는 비트 AND, OR, NOT 및 XOR 연산이 포함됩니다. 그들은 직사각형이 아닌 ROI 등을 정의하고 작업하면서 이미지의 어떤 부분을 추출하는 동안 매우 유용 할 것입니다 (아래 장에서 보게 될 것입니다). 아래에서는 이미지의 특정 영역을 변경하는 방법에 대한 예제를 보도록 하겠습니다. OpenCV 로고를 이미지 위에 올려 놓고 싶습니다. 두 개의 이미지를 추가하면 색이 바뀝니다. 그것을 섞으면 투명한 효과를 얻습니다. 그러나 나는 그것을 불투명하게 하고 싶다. 직사각형 영역이라면 마지막 장에서했던 것처럼 ROI를 사용할 수 있습니다. 그러나 OpenCV 로고는 직사각형이 아닙니다. 그래서 아래와 같이 bitwise 연산으로 할 수 있습니다: 12345678910111213141516171819202122232425262728293031import cv2img1 = cv2.imread('resize_model1.jpg')img2 = cv2.imread('opencv-logo-white.png')# I want to put logo on top-left corner, So I create a ROIrows, cols, channels = img2.shapeprint(rows, cols, channels) # 222 180 3roi = img1[0:rows, 0:cols]# Now create a mask of logo and create its inverse mask alsoimg2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)mask_inv = cv2.bitwise_not(mask)# Now black-out the area of logo in ROIimg1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)# Take only region of logo from logo image.img2_fg = cv2.bitwise_and(img2, img2, mask=mask)# Put logo in ROI and modify the main imagedst = cv2.add(img1_bg, img2_fg)img1[0:rows, 0:cols] = dstcv2.imshow('bg', img1)cv2.imshow('res', img1)cv2.imshow('res', img1)cv2.waitKey(0)cv2.destroyAllWindows() 아래 결과를 보십시오. 왼쪽 이미지는 우리가 만든 마스크를 보여줍니다. 오른쪽 이미지는 최종 결과를 보여줍니다. 이해를 돕기 위해 위의 코드에서 모든 중간 이미지, 특히 img1_bg 및 img2_fg를 표시하십시오. 연습 문제cv2.addWeighted 함수를 사용하여 폴더에 있는 이미지간에 부드러운 전환이 슬라이드 쇼 만들기 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials 07] 이미지에 대한 기본 작업","slug":"2018/OpenCV-Python-Tutorials-07-이미지에-대한-기본-작업","date":"2018-01-05T10:12:36.000Z","updated":"2018-01-05T10:12:40.501Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-07-이미지에-대한-기본-작업/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-07-이미지에-대한-기본-작업/","excerpt":"","text":"[OpenCV-Python Tutorials 07] 이미지에 대한 기본 작업모든 파일은 Github에서 확인 할 수 있습니다. 목표배울 내용: 픽셀 값에 액세스 및 수정 이미지 속성에 액세스 이미지 영역 설정 (ROI: Region of Image) 이미지 분할 및 병합 이 섹션의 거의 모든 작업은 주로 OpenCV보다는 Numpy와 관련이 있습니다. OpenCV로 더 최적화 된 코드를 작성하기 위해서는 Numpy에 대한 좋은 지식이 필요합니다. (예제는 단일 라인 코드이기 때문에 Python 터미널에 표시되는 내용입니다.) 픽셀 값 액세스 및 수정먼저 컬러 이미지를 로드 해 봅시다. 1234&gt;&gt;&gt; import cv2&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; img = cv2.imread('messi5.jpg') 행 및 열 좌표로 픽셀 값에 액세스 할 수 있습니다. BGR 이미지의 경우 Blue, Green, Red 값의 배열을 반환합니다. 회색 음영 이미지의 경우 해당 강도 만 반환됩니다. 12345678&gt;&gt;&gt; px = img[100,100]&gt;&gt;&gt; print px[178 197 205]# accessing only blue pixel&gt;&gt;&gt; blue = img[100,100,0]&gt;&gt;&gt; print blue178 img[100,100,0] 에서 배열 3번째 값이 0이므로 blue 입니다. BGR 이므로 아래와 같습니다. 0: Blue 1: Green R: Red 같은 방법으로 픽셀값을 수정할 수 있습니다. 123&gt;&gt;&gt; img[100,100] = [255,255,255]&gt;&gt;&gt; print img[100,100][255 255 255] 전체 코드는 다음과 같습니다. 1234567891011121314import cv2import numpy as npimage_file = 'ball_image.jpg'img = cv2.imread(image_file)px = img[100, 100]print(px)blue = img[100,100,0]print(blue)img[100,100] = [255,255,255]print(img[100,100]) Numpy는 빠른 배열 계산을 위해 최적화된 라이브러리입니다. 따라서 각 픽셀 값에 액세스하고 수정하는 것은 매우 느릴 것이며 권장하지 않습니다. 위에서 언급 한 방법은 일반적으로 배열 영역을 선택하는 데 사용됩니다. 예를 들어 처음 5 행과 마지막 3 열을 말합니다. 개별 픽셀에 액세스하는 경우 Numpy 배열 메서드인 array.item() 및 array.itemset()을 사용하는 것이 더 좋습니다. 하지만 항상 스칼라를 반환합니다. 따라서 모든 B, G, R 값에 액세스하려면 array.item()을 개별적으로 호출해야합니다. 더 나은 픽셀 액세스 및 편집 방법 : 12345678# accessing RED value&gt;&gt;&gt; img.item(10,10,2)59# modifying RED value&gt;&gt;&gt; img.itemset((10,10,2),100)&gt;&gt;&gt; img.item(10,10,2)100 이미지 속성에 액세스하기이미지 속성에는 행 수, 열 및 채널, 이미지 데이터 유형, 픽셀 수 등이 포함됩니다. 이미지의 모양은 img.shape에 의해 액세스됩니다. 행, 열 및 채널 수의 튜플을 반환합니다 (이미지가 색상인 경우). 12&gt;&gt;&gt; print img.shape(342, 548, 3) 이미지가 회색조인 경우 반환되는 튜플에는 행과 열만 포함됩니다. 따라서 로드 된 이미지가 회색조 또는 컬러 이미지인지 확인하는 좋은 방법입니다. img.size는 총 픽셀 수에 액세스합니다. 12&gt;&gt;&gt; print img.size562248 이미지 데이터 유형은 img.dtype를 통해서 얻을 수 있습니다. 12&gt;&gt;&gt; print img.dtypeuint8 OpenCV-Python 코드에서 많은 수의 오류가 잘못된 데이터 유형으로 인해 발생하기 때문에 img.dtype은 디버깅하는 동안 매우 중요합니다. 터미널이 아닌 소스파일로 작성한 전체 코드는 다음과 같습니다. 123456789import cv2import numpy as npimage_file = 'ball_image.jpg'img = cv2.imread(image_file)print(\"shape:\" + str(img.shape))print(\"size:\" + str(img.size))print(\"dtype:\" + str(img.dtype)) 결과 123shape:(205, 246, 3)size:151290dtype:uint8 이미지 ROI때로는 이미지의 특정 영역을 가지고 작업을 해야 합니다. 이미지에서 눈을 검색하려면 먼저 얼굴을 찾을 때까지 이미지에서 얼굴 검색을 수행 한 다음 얼굴 영역 내에서 눈을 검색하십시오. 이 방법은 정확도와 성능 향상시킵니다 (눈이 항상 얼굴에 있기 때문에 우리는 작은 영역만 검색을 수행하면 됩니다) ROI는 Numpy 색인을 사용하여 다시 얻습니다. 여기서 공을 선택하여 이미지의 다른 영역으로 복사합니다. 12&gt;&gt;&gt; ball = img[280:340, 330:390]&gt;&gt;&gt; img[273:333, 100:160] = ball 전체 코드는 다음과 같습니다. 1234567891011import cv2image_file = 'ball_image.jpg'img = cv2.imread(image_file)ball = img[0:113, 349:459]img[100:213, 449:559] = ballcv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 결과 이미지 채널 분할 및 병합필요한 경우 이미지의 B, G, R 채널을 개별 평면으로 분할 할 수 있습니다. 그런 다음 개별 채널을 다시 병합하여 BGR 이미지를 다시 형성 할 수 있습니다. 이것은 다음과 같이 수행 할 수 있습니다. 12&gt;&gt;&gt; b,g,r = cv2.split(img)&gt;&gt;&gt; img = cv2.merge((b,g,r)) 또는 1&gt;&gt;&gt; b = img[:,:,0] 빨간색 픽셀을 모두 0으로 만들고 싶다면, 이렇게 분할하고 0으로 놓을 필요가 없습니다. 더 빠르다고 말하는 Numpy 색인 생성을 간단하게 사용할 수 있습니다. 1img[:,:,2] = 0 cv2.split()은 값 비싼 연산이므로 (시간의 관점에서) 필요한 경우에만 사용하십시오. Numpy 색인 생성은 훨씬 효율적이기 때문에 가능하면 사용해야 합니다. 이미지에 테두리 만들기 (안쪽 여백 만들기)포토 프레임과 같은 이미지 주위에 테두리를 만들려면 cv2.copyMakeBorder() 함수를 사용할 수 있습니다. 그러나 이 함수는 컨볼루션 연산, 제로 패딩 (zero padding) 등의 애플리케이션이 더 많습니다. 이 함수는 다음과 같은 인수를 취합니다. src - 입력 이미지 위쪽, 아래쪽, 왼쪽, 오른쪽 - 경계의 폭 (해당 방향의 픽셀 수) borderType - 추가되는 경계의 종류를 정의하는 플래그. 다음 유형이 될 수 있습니다. cv2.BORDER_CONSTANT - 일정한 색상의 테두리를 추가합니다. 값은 다음 인수로 제공되어야합니다. cv2.BORDER_REFLECT - 테두리는 다음과 같이 테두리 요소를 반영합니다. fedcba|abcdefgh|hgfedcb cv2.BORDER_REFLECT_101 또는 cv2.BORDER_DEFAULT - 위와 동일하지만 다음과 같이 약간 변경되었습니다. gfedcb|abcdefgh|gfedcba cv2.BORDER_REPLICATE - 마지막 요소는 다음과 같이 전체적으로 복제됩니다. aaaaaa|abcdefgh|hhhhhhh cv2.BORDER_WRAP - 설명 할 수 없습니다. 다음과 같이 보일 것이다 : cdefgh|abcdefgh|abcdefg value - 경계 형이 cv2.BORDER_CONSTANT의 경우는 경계의 색 abcdefgh 는 원본을 의미합니다.fedcba|abcdefgh|hgfedcb 는 세로줄 |을 기준으로 양쪽으로 반영된 상태를 표시합니다. 원본이 abcdefgh 이므로, 왼쪽에 fedcba 의 순서로 반영된 이미지가 나오고 오른쪽에는 hgfedcb 으로 반영된 이미지가 나오는 것을 표시하고 있습니다. 다음은 더 나은 이해를 위해 이러한 모든 경계 유형을 보여주는 샘플 코드입니다. 12345678910111213141516171819202122232425import cv2import numpy as npfrom matplotlib import pyplot as pltBLUE = [255, 0, 0]image_file = 'opencv-logo-white.png'img1 = cv2.imread(image_file)pixel = 100replicate = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_REPLICATE)reflect = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_REFLECT)reflect101 = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_REFLECT_101)wrap = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_WRAP)constant = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_CONSTANT, value=BLUE)plt.subplot(231), plt.imshow(img1, 'gray'), plt.title('ORIGINAL')plt.subplot(232), plt.imshow(replicate, 'gray'), plt.title('REPLICATE')plt.subplot(233), plt.imshow(reflect, 'gray'), plt.title('REFLECT')plt.subplot(234), plt.imshow(reflect101, 'gray'), plt.title('REFLECT_101')plt.subplot(235), plt.imshow(wrap, 'gray'), plt.title('WRAP')plt.subplot(236), plt.imshow(constant, 'gray'), plt.title('CONSTANT')plt.show() 아래 결과를보십시오. (이미지는 matplotlib과 함께 표시되므로 RED 및 BLUE 평면이 상호 교환됩니다.) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html#basic-ops","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials 05] 마우스로 그리기","slug":"2018/OpenCV-Python-Tutorials-05-마우스로-그리기","date":"2018-01-05T10:11:51.000Z","updated":"2018-01-05T10:11:56.365Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-05-마우스로-그리기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-05-마우스로-그리기/","excerpt":"","text":"[OpenCV-Python Tutorials 05] 마우스로 그리기모든 파일은 Github에서 확인 할 수 있습니다. 목표 OpenCV에서 마우스 이벤트 처리 방법 배우기 다음 함수를 배웁니다. cv2.setMouseCallback() 간단한 데모여기서 우리는 두 번 클릭 할 때마다 이미지에 원을 그리는 간단한 애플리케이션을 만듭니다. 먼저 마우스 이벤트가 발생할 때 실행되는 마우스 콜백 함수를 만듭니다. 마우스 이벤트는 왼쪽 버튼 누를 때, 왼쪽 버튼 놓을 때, 왼쪽 버튼 두 번 클릭 등과 같은 마우스 관련 항목 일 수 있습니다. 모든 마우스 이벤트에 대한 좌표 (x, y)를 제공합니다. 이 이벤트와 위치로 우리는 무엇이든 할 수 있습니다. 사용 가능한 이벤트를 모두 나열하려면 Python 터미널에서 다음 코드를 실행하십시오. 123&gt;&gt;&gt; import cv2&gt;&gt;&gt; events = [i for i in dir(cv2) if 'EVENT' in i]&gt;&gt;&gt; print events python3 의 경우에는 print(events) 로 입력합니다. 결과는 아래와 같습니다. 12345&gt;&gt;&gt; import cv2&gt;&gt;&gt; events = [i for i in dir(cv2) if 'EVENT' in i]&gt;&gt;&gt; print(events)['EVENT_FLAG_ALTKEY', 'EVENT_FLAG_CTRLKEY', 'EVENT_FLAG_LBUTTON', 'EVENT_FLAG_MBUTTON', 'EVENT_FLAG_RBUTTON', 'EVENT_FLAG_SHIFTKEY', 'EVENT_LBUTTONDBLCLK', 'EVENT_LBUTTONDOWN', 'EVENT_LBUTTONUP', 'EVENT_MBUTTONDBLCLK', 'EVENT_MBUTTONDOWN', 'EVENT_MBUTTONUP', 'EVENT_MOUSEHWHEEL', 'EVENT_MOUSEMOVE', 'EVENT_MOUSEWHEEL', 'EVENT_RBUTTONDBLCLK', 'EVENT_RBUTTONDOWN', 'EVENT_RBUTTONUP']&gt;&gt;&gt; 마우스 콜백 함수를 생성하는 것은 어디서나 같은 형식을 취합니다. 함수가 하는 것만 다릅니다. 따라서 마우스 콜백 함수는 한 가지 작업을 수행합니다. 두 번 클릭하면 원이 그려집니다. 아래 코드를 참조하십시오. 코드 내용을 보면서 확인할 수 있습니다. 1234567891011121314151617181920import cv2import numpy as np# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: cv2.circle(img, (x, y), 100, (255, 0, 0), -1)# 검은색 바탕을 생성합니다. 마우스 콜백함수를 바인드 합니다.img = np.zeros((512, 512, 3), np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image', draw_circle)while True: cv2.imshow('image', img) if cv2.waitKey(20) &amp; 0xFF == 27: breakcv2.destroyAllWindows() 더블클릭을 하면 원이 그려지는 것을 확인할 수 있습니다. 종료를 하려면 ESC 키를 눌러야 합니다. 고급 데모이제 우리는 훨씬 더 나은 응용 프로그램으로 갑니다. 이 그림에서는 Paint 응용 프로그램에서와 같이 마우스를 끌어서 선택한 사각형에 따라 직사각형 또는 원을 그립니다. 그래서 우리의 마우스 콜백 함수는 두 부분을 가지고 있습니다. 하나는 직사각형을 그리고 다른 하나는 원을 그립니다. 이 특정 예제는 객체 추적, 이미지 분할 등과 같은 일부 대화식 응용 프로그램을 작성하고 이해하는데 실제로 도움이 될 것입니다. 1234567891011121314151617181920212223242526272829import cv2import numpy as npdrawing = False # True 이면 마우스가 눌린 상태입니다.mode = True # True이면 사각형을 그립니다. 'm'을 누르면 곡선으로 변경(토글)됩니다 ix, iy = -1, -1# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): global ix, iy, drawing, mode if event == cv2.EVENT_LBUTTONDOWN: drawing = True ix, iy = x, y elif event == cv2.EVENT_MOUSEMOVE: if drawing == True: if mode == True: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), -1) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1) elif event == cv2.EVENT_LBUTTONUP: drawing = False if mode == True: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), -1) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1) 다음으로이 마우스 콜백 함수를 OpenCV 윈도우에 바인딩해야합니다. 메인 루프에서 사각형과 원 사이를 토글(toggle)하기 위해 키 &#39;m&#39;에 대한 키보드 바인딩을 설정해야 합니다. 12345678910111213img = np.zeros((512,512,3), np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image',draw_circle)while(1): cv2.imshow('image',img) k = cv2.waitKey(1) &amp; 0xFF if k == ord('m'): mode = not mode elif k == 27: breakcv2.destroyAllWindows() 기본은 사각형을 그리게 되고, m키를 누르면 원을 그리게 됩니다. 추가 리소스연습 문제마지막 예제에서는 채워진 직사각형을 그렸습니다. 코드를 수정하여 채워지지 않은 사각형을 그립니다. 1cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), True) 마지막 파라미터 값을 True로 변경하여 채워지지 않은 사각형으로 변경합니다. 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npdrawing = False # True 이면 마우스가 눌린 상태입니다.mode = True # True이면 사각형을 그립니다. 'm'을 누르면 곡선으로 변경(토글)됩니다ix, iy = -1, -1# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): global ix, iy, drawing, mode if event == cv2.EVENT_LBUTTONDOWN: drawing = True ix, iy = x, y elif event == cv2.EVENT_LBUTTONUP: drawing = False if mode == True: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), True) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1)img = np.zeros((512, 512, 3), np.uint8)cv2.namedWindow('image')cv2.setMouseCallback('image', draw_circle)while (1): cv2.imshow('image', img) k = cv2.waitKey(1) &amp; 0xFF if k == ord('m'): mode = not mode elif k == 27: breakcv2.destroyAllWindows() 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_mouse_handling/py_mouse_handling.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials 04] OpenCV의 그리기 함수","slug":"2018/OpenCV-Python-Tutorials-04-OpenCV의-그리기-함수","date":"2018-01-04T10:11:27.000Z","updated":"2018-01-05T10:11:40.270Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-04-OpenCV의-그리기-함수/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-04-OpenCV의-그리기-함수/","excerpt":"","text":"[OpenCV-Python Tutorials 04] OpenCV의 그리기 함수모든 파일은 Github에서 확인 할 수 있습니다. 목표 OpenCV를 사용하여 다양한 기하학적 모양을 그리는 방법을 배웁니다. cv2.line(), cv2.circle(), cv2.rectangle(), cv2.ellipse(), cv2.putText() 등의 함수를 배웁니다. 코드위의 모든 기능에서 다음과 같은 몇 가지 일반적인 인수가 표시됩니다. img : 도형을 그리려는 이미지 color : 도형의 색. BGR의 경우에는 튜플 (예 : (255,0,0), 파란색)으로 전달합니다. 그레이 스케일의 경우 스칼라 값을 전달하십시오. thickness : 선이나 원 등의 두께입니다. 원과 같은 닫힌 그림에 -1이 전달되면 모양이 채워집니다. 기본 두께 = 1 lineType : 8-connected, 앤티 앨리어싱 된 라인 등의 라인 유형. 기본적으로 8-connected 입니다. cv2.LINE_AA는 커브를 위해 멋진 앤티 앨리어싱 된 선을 제공합니다. 8-connected은 가장자리 또는 모서리 중 하나에 닿는 모든 픽셀에 이웃합니다. 선 그리기선을 그리려면 선의 시작과 끝 좌표를 전달해야 합니다. 우리는 검은색 이미지를 만들고 왼쪽 위부터 오른쪽 아래까지 파란 선을 그릴 것입니다. 12345678import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pximg = cv2.line(img,(0,0),(511,511),(255,0,0),5) 선은 그렸지만 보이지 않으므로, 보이는 코드를 추가합니다. 123456789101112import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pximg = cv2.line(img,(0,0),(511,511),(255,0,0),5)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.line(img,(0,0),(511,511),(255,0,0),5) cv2.line() 함수의 파라미터 값은 다음과 같습니다. img: 배경 (0,0): 시작좌표 (511,511): 마지막좌표 (255,0,0): 컬러는 BGR 이므로, 파란색 5: 두께 BGR 은 Blue, Green, Red 를 의미합니다. 직사각형 그리기직사각형을 그리려면 직사각형의 왼쪽 위모서리와 오른쪽 하단 모서리가 필요합니다. 이번에는 이미지의 오른쪽 상단에 녹색 사각형을 그려 보겠습니다. 1234567891011import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)img = cv2.rectangle(img,(384,0),(510,128),(0,255,0),3)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.rectangle(img,(384,0),(510,128),(0,255,0),3) cv2.rectangle 함수의 파라미터 값은 다음과 같습니다. img: 배경 (384,0) : 시작 좌표 (좌측 상단) (510,128): 끝 좌표 (우측 하단) (0,255,0): BGR 이므로 녹색 3 : 두께 원 그리기원을 그리려면 중심 좌표와 반지름이 필요합니다. 위에서 그린 직사각형 안에 원을 그립니다. 1234567891011import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)img = cv2.circle(img,(447,63), 63, (0,0,255), -1)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.circle(img,(447,63), 63, (0,0,255), -1) cv2.circle() 함수의 파라미터는 다음과 같습니다. img: 배경 (447,63): 중심좌표 63: 반지름 (0,0,255): 컬러 BGR 이므로 빨간색 -1 : 두께가 -1 이므로 색상 채우기 타원 그리기타원을 그리려면 몇 가지 인수를 전달해야합니다. 하나의 인수는 중심 위치 (x, y)입니다. 다음 인수는 축 길이 (장축 길이, 보조 축 길이)입니다. angle은 반 시계 방향으로 타원의 회전 각도입니다. startAngle과 endAngle은 장축에서 시계 방향으로 측정 된 타원 호의 시작과 끝을 나타냅니다. 0과 360의 값을 부여하면 타원이됩니다. 자세한 내용은 cv2.ellipse() 문서를 확인하십시오. 아래 예제에서는 이미지의 중앙에 반 타원을 그립니다. 1234567891011import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)img = cv2.ellipse(img,(256,256),(100,50),0,0,180,255,-1)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.ellipse(img,(256,256),(100,50),0,0,180,255,-1) cv2.ellipse() 함수의 파라미터는 다음과 같습니다. img: 배경 (256,256): 중심점 (100,50): 장축길이, 보조축길이 0: 회전 각도 0: 시각 각도 180: 종료 각도 255: 색상, (255,0,0)로 입력해도 동일한 결과를 얻을 수 있습니다. -1: 두께, 채우기 다각형 그리기다각형을 그리려면 먼저 정점 좌표가 필요합니다. 이러한 점을 모양 ROWSx1x2의 배열로 만듭니다. 여기서 ROWS는 정점의 수이고 int32 유형이어야합니다. 여기서 우리는 4 개의 꼭지점이있는 작은 폴리곤을 노란색으로 그립니다. 12345678910111213import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts = pts.reshape((-1,1,2))img = cv2.polylines(img,[pts],True,(0,255,255))cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 123pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts = pts.reshape((-1,1,2))img = cv2.polylines(img,[pts],True,(0,255,255)) cv2.polylines() 함수의 파라미터는 다음과 같습니다. img: 배경 [pts]: 좌표 배열 True: 닫힘 여부 설정 (0,255,255)): 컬러 세 번째 인수가 False인 경우 닫힌 모양이 아닌 모든 점에 합류하는 폴리 라인을 가져옵니다. 여러 줄을 그리려면 cv2.polylines()를 사용할 수 있습니다. 그리기 원하는 모든 선 목록을 만들어 함수에 전달하십시오. 모든 선은 개별적으로 그려집니다. 각 행에 대해 cv2.line()을 호출하는 것보다 더 효율적이고 빠른 방법으로 행 그룹을 그립니다. 이미지에 텍스트 추가하기이미지에 텍스트를 넣으려면 다음을 지정해야합니다. 입력할 텍스트 데이터 놓을 위치의 좌표 (즉, 데이터가 시작되는 왼쪽 하단 모서리). 글꼴 유형 (지원되는 글꼴은 cv2.putText() 문서를 확인하십시오) 글꼴 크기 (글꼴 크기 지정) color, thickness, lineType 등과 같은 일반적인 것들. 더 나은 모양을 위해 lineType = cv2.LINE_AA가 권장됩니다. 우리는 우리의 이미지에 흰색으로 Hello OpenCV!!!를 씁니다. 123456789101112import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)font = cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,'Hello OpenCV!!!',(10,500), font, 2, (255,255,255), 2, cv2.LINE_AA)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 12font = cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,'OpenCV',(10,500), font, 4,(255,255,255),2,cv2.LINE_AA) cv2.putText()함수의 파라미터는 다음과 같습니다. img: 배경 ‘OpenCV’: 문자열 (10,500): 시작위치 font: 폰트 4: 폰트 크기 (255,255,255): 색상 2: 두께 cv2.LINE_AA: 선 유형 LINE_4 = 4LINE_8 = 8LINE_AA = 16 결과이제 우리가 그린 그림의 최종 결과를 볼 시간입니다. 이전 기사에서 공부하면서 이미지를 표시하여 이미지를 봅니다. 12345678910111213141516171819202122import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pximg = cv2.line(img,(0,0),(511,511),(255,0,0),5)img = cv2.rectangle(img,(384,0),(510,128),(0,255,0),3)img = cv2.circle(img,(447,63), 63, (0,0,255), -1)img = cv2.ellipse(img,(256,256),(100,50),0,0,180,(255,0,0),-1)pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts = pts.reshape((-1,1,2))img = cv2.polylines(img,[pts],True,(0,255,255))font = cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,'Hello OpenCV!!!',(10,500), font, 2, (255,255,255), 2, cv2.LINE_AA)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 추가 리소스타원 함수에 사용 된 각도는 원형 각도가 아닙니다. 자세한 내용은이 토론을 방문하십시오. 연습 문제OpenCV에서 사용할 수있는 그리기 기능을 사용하여 OpenCV 로고 만들기 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_drawing_functions/py_drawing_functions.html http://radio.feld.cvut.cz/matlab/toolbox/images/binary6.html http://docs.opencv.org/2.4/modules/core/doc/drawing_functions.html","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials 03] 비디오 시작하기","slug":"2018/OpenCV-Python-Tutorials-03-비디오-시작하기","date":"2018-01-03T10:11:01.000Z","updated":"2018-01-05T10:11:13.751Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-03-비디오-시작하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-03-비디오-시작하기/","excerpt":"","text":"[OpenCV-Python Tutorials 03] 비디오 시작하기모든 파일은 Github에서 확인 할 수 있습니다. 목표 비디오 읽기, 비디오 디스플레이 및 비디오 저장 방법을 배웁니다. 카메라에서 캡처하여 표시하는 방법을 배웁니다. 다음 함수를 배웁니다. cv2.VideoCapture(), cv2.VideoWriter() 카메라에서 비디오 캡처가끔 우리는 카메라로 라이브 스트림을 캡처 해야 합니다. OpenCV는 매우 간단한 인터페이스를 제공합니다. 카메라에서 비디오를 캡처하고 (저는 노트북의 내장 웹캠을 사용하고 있습니다.) 그레이 스케일 비디오로 변환하여 표시하는 간단한 작업부터 시작합니다. 비디오를 캡처하려면 VideoCapture 객체를 만들어야 합니다. 인수는 장치 색인이나 비디오 파일 이름이 될 수 있습니다. 장치 색인은 카메라를 지정하는 번호입니다. 일반적으로 하나의 카메라가 연결됩니다 (필자의 경우). 단순히 0 (또는 -1)을 전달합니다. 1을 전달하여 두 번째 카메라를 선택할 수 있습니다. 그 후에 프레임 단위로 캡처 할 수 있습니다. 그러나 마지막에 release 하는 것을 잊지 마십시오. 1234567891011121314151617181920import numpy as npimport cv2cap = cv2.VideoCapture(0)while(True): # Capture frame-by-frame ret, frame = cap.read() # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow('frame',gray) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break# When everything done, release the capturecap.release()cv2.destroyAllWindows() 내장 웹캠이 없는 경우에는 에러가 발생하므로, 파일에서 비디오 재생하기 내용을 확인하여 저장 파일을 읽도록 변경합니다. cap.read()는 bool (True/False)을 반환합니다. 프레임을 올바르게 읽으면 True입니다. 따라서 이 반환 값을 확인하여 동영상의 끝을 확인할 수 있습니다. 경우에 따라 cap이 캡처를 초기화하지 않았을 수 있습니다. 이 경우이 코드는 오류를 표시합니다. cap.isOpened() 메소드를 통해서 초기화되었는지 여부를 확인할 수 있습니다. True이면 OK입니다. 그렇지 않으면 cap.open()을 사용하여 열 수 있습니다. 또한 cap.get(propId) 메소드를 사용하여 이 비디오의 일부 기능에 액세스 할 수 있습니다. 여기서 propId는 0에서 18사이의 숫자입니다. 각 숫자는 비디오의 속성을 나타내며 (해당 비디오에 적용 가능할 경우) 자세한 내용은 여기서 볼 수 있습니다 : Property Identifier.. 이 값 중 일부는 cap.set(propId, value)을 사용하여 수정할 수 있습니다. Value는 원하는 새 값입니다. 속성 설명 CV_CAP_PROP_POS_MSEC 밀리 세컨드 단위의 비디오 파일의 현재의 위치 또는 비디오 캡춰의 타임 스탬프. CV_CAP_PROP_POS_FRAMES 다음에 디코드 또는 캡춰되는, 프레임의 0베이스의 인덱스 CV_CAP_PROP_POS_AVI_RATIO 비디오 파일의 상대 위치 : 0 - 필름의 시작 부분, 필름의 끝 부분. CV_CAP_PROP_FRAME_WIDTH 비디오 스트림의 프레임의 폭. CV_CAP_PROP_FRAME_HEIGHT 비디오 스트림의 프레임의 높이. CV_CAP_PROP_FPS 프레임 속도. CV_CAP_PROP_FOURCC 코덱의 4-character 코드입니다. CV_CAP_PROP_FRAME_COUNT 비디오 파일의 프레임 수. CV_CAP_PROP_FORMAT retrieve()에 의해 반환 된 Mat 객체의 형식. CV_CAP_PROP_MODE 현재의 캡춰 모드를 나타내는 백엔드 고유의 값. CV_CAP_PROP_BRIGHTNESS 이미지의 밝기입니다 (카메라에만 해당). CV_CAP_PROP_CONTRAST 이미지의 명암 (카메라에만 해당). CV_CAP_PROP_SATURATION 이미지 포화 (카메라 만). CV_CAP_PROP_HUE 이미지의 색조입니다 (카메라에만 해당). CV_CAP_PROP_GAIN 이미지의 게인 (카메라에만 해당). CV_CAP_PROP_EXPOSURE 노출 (카메라에만 해당). CV_CAP_PROP_CONVERT_RGB 이미지를 RGB로 변환할지 어떨지를 나타내는 Boolean 형의 플래그. CV_CAP_PROP_WHITE_BALANCE_U 화이트 밸런스 설정의 U 값 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_WHITE_BALANCE_V 화이트 밸런스 설정의 V 값 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_RECTIFICATION 스테레오 카메라의 정류 플래그 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_ISO_SPEED 카메라의 ISO 속도 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_BUFFERSIZE 내부 버퍼 메모리에 저장된 프레임 수 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) 예를 들어, 프레임 너비와 높이를 cap.get(3)과 cap.get(4)로 확인할 수 있습니다. 기본적으로 640x480을 제공하는 것을 320x240으로 수정하고 싶다면 ret = cap.set(3,320) 와 ret = cap.set(4,240) 만 사용하십시오. 12ret = cap.set(CV_CAP_PROP_FRAME_WIDTH,320)ret = cap.set(CV_CAP_PROP_FRAME_HEIGHT,240) 오류가 발생하면 다른 카메라 응용 프로그램 (예 : Linux의 Cheese)을 사용하여 카메라가 제대로 작동하는지 확인하십시오. 파일에서 비디오 재생하기카메라에서 캡쳐하는 것과 같습니다. 비디오 파일 이름으로 카메라 인덱스를 변경하면 됩니다. 또한 프레임을 표시하는 동안 cv2.waitKey()을 이용하여 적절한 시간을 사용하십시오. 너무 적으면 비디오가 매우 빠르며 너무 높으면 비디오가 느려집니다 (즉, 비디오를 느린 동작으로 표시 할 수 있습니다). 정상적인 경우 25 밀리 초가 정상입니다. 123456789101112131415161718192021import numpy as npimport cv2file = '01_video.mp4'cap = cv2.VideoCapture(file)while(True): # Capture frame-by-frame ret, frame = cap.read() # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow('frame',gray) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break# When everything done, release the capturecap.release()cv2.destroyAllWindows() 동영상을 끝내기 위해서는 q 키를 입력해야 합니다. ffmpeg 또는 gstreamer의 올바른 버전이 설치되어 있는지 확인하십시오. 때로는 ffmpeg / gstreamer가 잘못 설치되어 비디오 캡쳐 작업에 문제가 생깁니다. 비디오 저장하기따라서 우리는 비디오를 캡처하여 프레임 단위로 처리하고 해당 비디오를 저장하려고 합니다. 이미지의 경우 매우 간단합니다. cv2.imwrite()만 사용하면됩니다. 비디오에서는 좀 더 많은 작업이 필요합니다. 이번에는 VideoWriter 객체를 만듭니다. 출력 파일 이름을 지정해야 합니다 (예 : output.avi). 그런 다음 FourCC 코드를 지정해야 합니다 (다음 단락에 세부사항이 설명되어 있습니다). 그런 다음 초당 프레임 수(fps)와 프레임 크기를 전달해야 합니다. 그리고 마지막 하나는 isColor 플래그입니다. True이면 인코더는 컬러 프레임을 요구하고 그렇지 않으면 그레이 스케일 프레임과 함께 작동합니다. FourCC는 비디오 코덱을 지정하는 데 사용되는 4 바이트 코드입니다. 사용 가능한 코드 목록은 fourcc.org에서 찾을 수 있습니다. 플랫폼에 따라 다릅니다. 다음 코덱은 잘 작동합니다. FourCC(Four Character Code)는 말 그대로 “4글자 코드”라는 뜻이며, 4 바이트로 된 문자열은 데이터 형식을 구분하는 고유 글자가 된다. Fedora : DIVX, XVID, MJPG, X264, WMV1, WMV2. (XVID가 더 바람직합니다. MJPG는 고화질 비디오를 만듭니다 .X264는 매우 작은 크기의 비디오를 제공합니다) Windows의 경우 : DIVX (테스트 및 추가 예정) FourCC 코드는 MJPG의 경우 cv2.VideoWriter_fourcc(&#39;M&#39;, &#39;J&#39;, &#39;P&#39;, &#39;G&#39;) 또는 cv2.VideoWriter_fourcc(*&#39;MJPG&#39;)로 전달됩니다. 카메라의 코드 캡처 아래에서 모든 프레임을 수직 방향으로 뒤집어 저장합니다. 123456789101112131415161718192021222324252627import numpy as npimport cv2cap = cv2.VideoCapture(0)# Define the codec and create VideoWriter objectfourcc = cv2.VideoWriter_fourcc(*'XVID')out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480))while(cap.isOpened()): ret, frame = cap.read() if ret==True: frame = cv2.flip(frame,0) # write the flipped frame out.write(frame) cv2.imshow('frame',frame) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break# Release everything if job is finishedcap.release()out.release()cv2.destroyAllWindows() 위아래가 뒤집어진 영상이 저장된 것을 확인할 수 있습니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image https://videos.pexels.com/","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials 02] 이미지 시작하기","slug":"2018/OpenCV-Python-Tutorials-02-이미지-시작하기","date":"2018-01-02T10:10:35.000Z","updated":"2018-01-05T10:10:50.376Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-02-이미지-시작하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-02-이미지-시작하기/","excerpt":"","text":"[OpenCV-Python Tutorials 02] 이미지 시작하기모든 파일은 Github에서 확인 할 수 있습니다. 목표 여기에서 이미지를 읽는 방법, 이미지를 표시하는 방법 및 이미지를 다시 저장하는 방법에 대해 배웁니다. 다음 함수를 배웁니다. cv2.imread(), cv2.imshow(), cv2.imwrite() 선택적으로 Matplotlib을 사용하여 이미지를 표시하는 방법을 배우게됩니다. OpenCV 사용이미지 읽기이미지를 읽으려면 cv2.imread() 함수를 사용하십시오. 이미지는 작업 디렉토리에 있거나 이미지의 전체 경로가 주어져야 합니다. 두 번째 인수는 이미지를 읽어야하는 방법을 지정하는 플래그입니다. cv2.IMREAD_COLOR : 컬러 이미지를 로드합니다. 이미지의 투명성은 무시됩니다. 기본 플래그입니다. cv2.IMREAD_GRAYSCALE : 이미지를 회색조 모드로 로드합니다. cv2.IMREAD_UNCHANGED : 알파 채널을 포함하여 이미지를 로드합니다. 이 세 개의 플래그 대신 정수 1, 0 또는 -1을 각각 전달할 수 있습니다. 아래 코드를 참조하십시오. 123456import numpy as npimport cv2# Load an color image in grayscalefile = '01_model.jpg'img = cv2.imread(file, 0) 이미지 경로가 잘못 되어도 오류는 발생하지 않지만 img(print img)는 아무것도(None) 표시되지 않습니다. 이미지 표시창에 이미지를 표시하려면 cv2.imshow() 함수를 사용하십시오. 창은 이미지 크기에 자동으로 맞춰집니다. 첫 번째 파라미터는 창 이름을 나타내는 문자열입니다. 두 번째 파라미터는 출력할 이미지입니다. 원하는 만큼 창을 만들 수 있지만 창이름은 다르게 해야 합니다. 12345678910import numpy as npimport cv2# Load an color image in grayscalefile = '01_model.jpg'img = cv2.imread(file, 0)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 윈도우의 스크린 샷은 다음과 같습니다. cv2.imread(file, 0) 호출시에 두번째 파라미터로 0을 전달하여 그레이스케일 이미지로 출력됩니다. 12345678910import numpy as npimport cv2# 컬러 이미지를 로드 합니다. file = '01_model.jpg'img = cv2.imread(file, cv2.IMREAD_COLOR)cv2.imshow('image', img)cv2.waitKey(0)cv2.destroyAllWindows() 두번째 파라미터에 cv2.IMREAD_COLOR를 전달하여 컬러 이미지로 출력되도록 변경합니다. cv2.waitKey()는 키보드 바인딩 함수입니다. 인수는 밀리 초 단위의 시간입니다. 이 함수는 키보드 이벤트에 대해 지정된 밀리 초를 기다립니다. 그 시간에 아무 키나 누르면 프로그램이 계속됩니다. 0을 전달하면 키 스트로크가 무기한 대기됩니다. 키 a가 눌려 졌을 때 등과 같은 특정 키 스트로크를 감지하도록 설정할 수도 있습니다. cv2.destroyAllWindows()는 우리가 만든 모든 창을 단순히 파괴합니다. 특정 윈도우를 파기하려면 정확한 윈도우 이름을 인수로 전달하는 cv2.destroyWindow() 함수를 사용하십시오. 이미 창을 만들고 나중에 이미지를 로드 하는 특별한 경우가 있습니다. 이 경우 창 크기를 조정할 수 있는지 여부를 지정할 수 있습니다. 이것은 cv2.namedWindow() 함수로 처리됩니다. 플래그 기본값은 cv2.WINDOW_AUTOSIZE입니다. 그러나 플래그를 cv2.WINDOW_NORMAL로 지정하면 윈도우의 크기를 조정할 수 있습니다. 이미지의 크기가 너무 크고 트랙 바를 윈도우에 추가 할 때 유용합니다. 아래 코드를 참조하십시오. 1234cv2.namedWindow('image', cv2.WINDOW_NORMAL)cv2.imshow('image',img)cv2.waitKey(0)cv2.destroyAllWindows() 이미지 저장이미지를 저장하려면 cv2.imwrite() 함수를 사용하십시오. 첫 번째 인수는 파일 이름이고, 두 번째 인수는 저장할 이미지입니다. 12345678import numpy as npimport cv2# 컬러 이미지를 로드 합니다.file = '01_model.jpg'img = cv2.imread(file, cv2.IMREAD_COLOR)cv2.imwrite('04_image_write_output.png', img) 그러면 작업 디렉토리에 이미지가 PNG 형식으로 저장됩니다. 작업폴더에 파일이 생성되는 것을 확인할 수 있습니다. 소스파일은 모두 Github에서 확인할 수 있습니다. Sum it up아래 프로그램은 그레이 스케일로 이미지를 로드하고, 표시하고, ‘s’를 누르면 이미지를 저장하고 종료합니다. 아니면 ESC 키를 누르면 저장하지 않고 종료합니다. 1234567891011121314import numpy as npimport cv2# Load an color image in grayscalefile = '01_model.jpg'img = cv2.imread(file, 0)cv2.imshow('image', img)k = cv2.waitKey(0)if k == 27: # wait for ESC key to exit cv2.destroyAllWindows()elif k == ord('s'): # wait for 's' key to save and exit cv2.imwrite('05_sum_it_up_output.png', img) cv2.destroyAllWindows() Matplotlib 사용하기Matplotlib은 다양한 플로팅 방법을 제공하는 Python용 플로팅 라이브러리입니다. 당신은 다음 내용에서 Matplotlib에 대해 볼 수 있습니다. 여기서는 Matplotlib을 사용하여 이미지를 표시하는 방법을 배우게 됩니다. Matplotlib을 사용하여 이미지를 확대/축소하고 저장할 수 있습니다. matplotlib는 파이썬에서 자료를 차트(chart)나 플롯(plot)으로 시각화(visulaization)하는 패키지이다. 123456789import numpy as npimport cv2from matplotlib import pyplot as pltfile = '01_model.jpg'img = cv2.imread(file, 0)plt.imshow(img, cmap = 'gray', interpolation = 'bicubic')plt.xticks([]), plt.yticks([]) # to hide tick values on X and Y axisplt.show() 화면의 스크린 샷은 다음과 같습니다. Matplotlib에서는 다양한 플롯팅 옵션을 사용할 수 있습니다. 자세한 내용은 Matplotlib 문서를 참조하십시오. OpenCV로로드 된 컬러 이미지는 BGR 모드입니다. 그러나 Matplotlib은 RGB 모드로 표시됩니다. 따라서 OpenCV로 이미지를 읽으면 컬러 이미지가 Matplotlib에서 올바르게 표시되지 않습니다. 자세한 내용은 연습 문제를 참조하십시오. Additional Resources Matplotlib Plotting Styles and Features 연습 문제OpenCV에서 컬러 이미지를로드하여 Matplotlib에 표시하려고 할 때 약간의 문제가 있습니다. 이 토론을 읽고 이해하십시오. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220499281999&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[],"tags":[]},{"title":"[OpenCV-Python Tutorials 01] OpenCV-Python Tutorials 소개","slug":"2018/OpenCV-Python-Tutorials-01-OpenCV-Python-Tutorials-소개","date":"2018-01-01T10:13:45.000Z","updated":"2018-01-05T10:31:57.954Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-01-OpenCV-Python-Tutorials-소개/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-01-OpenCV-Python-Tutorials-소개/","excerpt":"","text":"[OpenCV-Python Tutorials 01] OpenCV-Python Tutorials 소개모든 파일은 Github에서 확인 할 수 있습니다. OpenCV OpenCV는 1999년 Gary Bradsky에 의해 인텔에서 시작되었으며 첫번째 릴리스는 2000년에 나왔습니다. Vadim Pisarevsky는 Intel의 러시아 소프트웨어 OpenCV 팀을 관리하기 위해 Gary Bradsky에 합류했습니다. 2005년, OpenCV는 2005 DARPA 그랜드 챌린지에서 우승 한 차량인 Stanley에 사용되었습니다. 다르파 그랜드 챌린지(The DARPA Grand Challenge)는 미 국방성 최고위 연구기관인 국방고등기획국(Defense Advanced Research Projects Agency, DARPA, 다르파)이 후원하는 무인 자동차 경주 대회다. 나중에 Gary Bradsky와 Vadim Pisarevsky가 프로젝트를 이끌면서 Willow Garage의 지원하에 적극적으로 발전했습니다. 현재 OpenCV는 컴퓨터 비전 및 기계 학습과 관련된 많은 알고리즘을 지원하며 날마다 확장되고 있습니다. 현재 OpenCV는 C++, Python, Java 등 다양한 프로그래밍 언어를 지원하며 Windows, Linux, OS X, Android, iOS 등 다양한 플랫폼에서 사용할 수 있습니다. 또한 CUDA 및 OpenCL을 기반으로 한 인터페이스도 고속 GPU 작동을 위해 활발히 개발 중입니다. CUDA (“Compute Unified Device Architecture”, 쿠다)는 그래픽 처리 장치(GPU)에서 수행하는 (병렬 처리) 알고리즘을 C 프로그래밍 언어를 비롯한 산업 표준 언어를 사용하여 작성할 수 있도록 하는 GPGPU 기술이다. OpenCV-Python은 OpenCV의 Python API입니다. OpenCV C++ API와 Python 언어의 최상의 특성을 결합합니다. OpenCV-Python Python은 Guido van Rossum에 의해 시작된 범용 프로그래밍 언어입니다. 이 언어는 단순성과 코드 가독성으로 인해 단기간에 큰 인기를 끌게 되었습니다. Python을 사용하면 프로그래머는 가독성을 떨어 뜨리지 않으면서 적은 수의 코드 행으로 자신의 아이디어를 표현할 수 있습니다. C/C++와 같은 다른 언어와 비교할 때 Python은 속도가 느립니다. 그러나 파이썬의 또 다른 중요한 특징은 C/C++로 쉽게 확장 할 수 있다는 것입니다. 이 기능은 C/C++에서 계산 집약적인 코드를 작성하고 파이썬 래퍼를 작성하여 이러한 래퍼를 파이썬 모듈로 사용할 수 있게 도와줍니다. 이것은 두 가지 이점을 제공합니다. 첫번째, 우리의 코드는 원래의 C/C++ 코드만큼 빠르며 (실제 C++ 코드가 백그라운드에서 작동하기 때문에) 두번째, Python으로 코딩하는 것이 매우 쉽습니다. 이것은 OpenCV-Python이 작동하는 방식으로 원래의 C++ 구현을 둘러싼 파이썬 wrapper입니다. 그리고 Numpy의 지원으로 작업이 더 쉬워졌습니다. Numpy는 수치 연산을 위해 최적화된 라이브러리입니다. Numpy는 MATLAB 스타일의 구문을 제공합니다. 모든 OpenCV 배열 구조는 Numpy 배열로 변환됩니다. Numpy에서 할 수 있는 어떤 작업도 OpenCV와 결합하여 당신의 무기고의 무기 개수를 늘릴 수 있습니다. 그 외에도 Numpy를 지원하는 SciPy, Matplotlib과 같은 여러 라이브러리와 함께 사용할 수 있습니다. 따라서 OpenCV-Python은 컴퓨터 비전 문제의 신속한 프로토타이핑을 위한 적절한 도구입니다. 프로토타입은 ‘정보시스템의 미완성 버전 또는 중요한 기능들이 포함되어 있는 시스템의 초기모델’이다. OpenCV-Python TutorialsOpenCV는 OpenCV-Python에서 사용할 수 있는 다양한 기능을 안내하는 새로운 자습서 세트를 소개합니다. 이 가이드는 주로 OpenCV 3.x 버전에 초점을 맞추고 있습니다. (대부분의 자습서는 OpenCV 2.x에서도 작동합니다.) Python과 Numpy에 대한 사전 지식은 안내서에서 다루지 않기 때문에 시작하기 전에 필요합니다. 특히, OpenCV-Python에서 최적화된 코드를 작성하기 위해서 Numpy에 대한 좋은 지식이 필요합니다. 이 자습서는 Alexander Mordvintsev의 지도하에 2013년 Google Summer of Code 프로그램의 일환으로 Abid Rahman K가 시작했습니다. OpenCV Needs You !!!OpenCV는 오픈 소스 이니셔티브이기 때문에 이 라이브러리에 기여할 수 있습니다. 그리고 이 튜토리얼에서도 마찬가지입니다. 오픈 소스 이니셔티브(Open Source Initiative, 줄여서 OSI)는 오픈 소스 소프트웨어 사용을 장려하기 위하여 만들어진 단체이다. 따라서 이 튜토리얼에서 실수를 발견하면 (작은 맞춤법 오류, 코드, 개념의 큰 오류 등 어떤 것이든) 자유롭게 수정하십시오. 오픈 소스 프로젝트에 기여하기 시작하는 사람들에게는 좋은 일이 될 것입니다. OpenCV를 Github에서 fork 하고 필요한 부분을 수정하고 OpenCV에 pull request 를 보내면 됩니다. OpenCV 개발자는 pull request 요청을 확인하고 중요한 피드백을 주며 검토자 승인을 통과하면 OpenCV에 병합됩니다. 그러면 당신은 오픈 소스 기여자가 됩니다. 다른 튜토리얼, 문서 등의 경우에서도 마찬가지 입니다 OpenCV-Python에 새로운 모듈이 추가됨에 따라 이 튜토리얼은 확장되어야 합니다. 그래서 특정 알고리즘을 아는 사람들은 알고리즘의 기본 이론과 알고리즘의 기본 사용법을 보여주는 코드를 포함하는 튜토리얼을 작성하여 OpenCV에 제출할 수 있습니다. 우리는 함께 이 프로젝트를 성공적으로 만들 수 있다는 것을 잊지 마십시오!!! Contributors다음은 OpenCV-Python에 자습서를 제출한 기고자 목록입니다. Alexander Mordvintsev (GSoC-2013 mentor) Abid Rahman K. (GSoC-2013 intern) 설치 Anaconda를 설치합니다.파이썬 라이브러리 모음 사이트에서 opencv를 찾아 설치합니다. 12345&gt; D:\\8.Download&gt;pip install \"opencv_python-3.2.0+contrib-cp36-cp36m-win_amd64.whl\"Processing d:\\8.download\\opencv_python-3.2.0+contrib-cp36-cp36m-win_amd64.whlInstalling collected packages: opencv-pythonSuccessfully installed opencv-python-3.2.0+contrib Additional Resources A Quick guide to Python - A Byte of Python Basic Numpy Tutorials Numpy Examples List OpenCV Documentation OpenCV Forum 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_setup/py_intro/py_intro.html#intro https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220498694383&amp;categoryNo=66&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=6&amp;postListTopCurrentPage=1&amp;from=postList&amp;userTopListOpen=true&amp;userTopListCount=10&amp;userTopListManageOpen=false&amp;userTopListCurrentPage=6 https://ko.wikipedia.org","categories":[],"tags":[]},{"title":"UbuntuOpenStack","slug":"2016/UbuntuOpenStack","date":"2016-12-27T05:33:00.000Z","updated":"2018-01-05T06:21:41.040Z","comments":true,"path":"2016/UbuntuOpenStack/","link":"","permalink":"http://jacegem.github.io/blog/2016/UbuntuOpenStack/","excerpt":"","text":"우분투 홈페이지에서 ISO 파일 다운로드 VirtualBox 로 설치 instal-guide-ubuntu https://www.ubuntu.com/download/cloud#instructions Installation instructions Set up your hardware ———————– Install Ubuntu Server 14.04 LTS on the machine designated to be the MAAS server. You need to setup a private network with all machines plugged in and enough IP addresses available for all physical and virtual machines you plan to run. This network must not have a DHCP server: MAAS will fill in that role. For the simplest topology, connect the second NIC of the dual-nic machines(s) to the same network Add required repositories —————————- 123sudo apt-get install python-software-propertiessudo add-apt-repository ppa:cloud-installer/stablesudo apt-get update","categories":[],"tags":[]},{"title":"[하스스톤] 선술집 - 나를 따르라","slug":"2016/하스스톤-선술집-나를-따르라","date":"2016-02-19T02:10:37.000Z","updated":"2018-01-05T06:31:37.658Z","comments":true,"path":"2016/하스스톤-선술집-나를-따르라/","link":"","permalink":"http://jacegem.github.io/blog/2016/하스스톤-선술집-나를-따르라/","excerpt":"","text":"[하스스톤] 선술집 - 나를 따르라 하수인 뒤에서 숨어있는 자를 어찌 영웅이라 할 수 있겠습니까! 하수인들을 지키세요! 이번 난투에서는 내 영웅예게 도발 능력이 부여됩니다. 게임을 시작하면 영웅에게 방어 10이 추가되고, 도발 능력이 부여됩니다. 마법사 전략단 하나의 카드로 인해 이번 선술집에서 최고의 영웅이 되었습니다. 그래서 마법사 대 마법사의 게임이 자주 발생하게 됩니다. 이번 선술집의 진정한 히어로 입니다. 영웅의 도발 뒤에 숨어서, 영웅의 피해를 1로 고정합니다.살아 움직이는 갑옷을 골랐으면, 나머지는 마법사 카드들을 선택하면 됩니다. 마법을 위주로 사용하기에 필수 카드인 불꽃꼬리 전사를 선택합니다. 마법 법사라면 공격력 높고, 주문을 얻을 수 있기 때문에 이 카드도 유용합니다. 살아 움직이는 갑옷 과 세트로 사용합니다. 상대방이 영웅의 피해가 1로 고정되는 것을 피하기 위해서 살아 움직이는 갑옷을 먼저 처치하려고 할 것입니다. 2의 피해를 줄 수 있기 때문에, 적 하수인을 처치할 때 유용합니다. 비밀을 사용한다면 꼭 넣어줍니다. 얼음 방패와 비전술사는 최고의 콤비 입니다. 주술사 전략 그냥 1마나로 사용하기 좋습니다. 땅굴 트로그와 콤비로 다니는 카드 입니다. 2마나 카드이며 과부하가 있기에 땅굴 트로그에 공격력 +1 을 부여합니다. 이번 선술집에서 주술사의 핵심카드 입니다. 지속적으로 양옆 하수인들에게 공격력 +2 를 부여합니다. 영웅의 도발 능력으로 상대방이 이 카드를 처치하기 쉽지 않습니다. 두 개의 불꽃의 토템을 놓이면 총 공격력 +8의 효과를 얻게 됩니다. 영웅의 도발로 인해 하수인 처리가 어려워지므로, 하수인 수를 늘리기 쉽습니다. 이때 피의 욕망을 부르면 한번에 상대방의 피를 모두 깍을 수 있습니다. 기본공격력에, 불꽃토템 +8, 피의욕망 +12. 게임이 종료되었습니다. 전사 전략 하수인을 모으고, 방어도를 높이면서 게임을 진행할 수 있습니다. 이번 선술집에서 활용도가 큰 카드입니다. 기본으로 주어지는 10 방어도를 그대로 활용할 수 있습니다. 1마나만 사용하여 초반부터 10의 피해가 가능합니다. 이 무기는 공격력보다는 죽음의 메아리를 활용하는 것이 관건입니다. 파괴될 때, 모든 하수인들에게 피해를 주므로 방어구 제작자가 있다면 높은 방어력을 얻을 수 있습니다. 한번에 방어도 8을 얻었습니다. 사냥꾼 전략 야수들에게 돌진을 부여하는 툰드라 코뿔소로 시작합니다. 이때 부터는 모든 야수들은 등장하자마자 공격이 가능해지기 때문에 딜에 좋습니다. 일반 카드상대방의 하수인에 늘어나기 쉬우므로 정신 지배 기술자를 사용하여 상대방의 하수인을 가져옵니다.","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/하스스톤/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/선술집/"}]},{"title":"일러스트레이터 - 단축키","slug":"2016/일러스트레이터-단축키","date":"2016-02-10T12:31:54.000Z","updated":"2018-01-05T06:31:52.067Z","comments":true,"path":"2016/일러스트레이터-단축키/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-단축키/","excerpt":"","text":"단축키 요약Alt 키가 반대의 역할을 한다. Alt 키가 사용중이면 Shift 가 반대의 역할을 한다.숫자키 조합 단축키가 유용하다.이동시에, Shift 를 누르면 더 크게 움직인다. 파일 단축키 설명 Ctrl + N 새 파일 만들기 Ctrl + Shift + N 템플릿 불러오기 Ctrl + O 파일 불러오기 Ctrl + Alt + O 어도비 브릿지로 불러오기 Ctrl + W 파일 닫기 Ctrl + Alt + W 열린 파일 모두 닫기 Ctrl + S 파일 저장하기 Ctrl + Shift + S 다른 이름으로 저장하기 Ctrl + Alt + S 복사본 저장하기 Ctrl + Shift + Alt + S 웹용 파일로 저장하기 Ctrl + Alt + P 도큐먼트 셋업하기 Ctrl + P 프린트하기 Ctrl + Q 일러스트러에터 종료하기 오브젝트 단축키 설명 Ctrl + D 변형 작업 반복하기 Ctrl + G 선택한 오브젝트를 그룹으로 묶기 Ctrl + Shift + G 묶인 그룹 풀어주기 Ctrl + ], Ctrl + [ 선택한 오브젝트의 배열을 위·아래로 Ctrl + Shift + ], Ctrl + Shift + [ 선택한 오브젝트의 배열을 최상위·최하위로 Ctrl + 2 선택한 오브젝트 잠그기 Ctrl + Alt + 2 잠긴 오브젝트 풀어주기 Ctrl + 3 선택한 오브젝트 보이지 않게 숨기기 Ctrl + Alt + 3 감춘 오브젝트 보이게 하기 Ctrl + Shift + Alt + 3 선택한 오브젝트만 남기고 모두 숨기기 Ctrl + J 떨어져 있는 패스 기준점 이어주기 Ctrl + Alt + X 라이브 페인트 환경 만들기 Ctrl + 7 클리핑 마스크 만들기 Ctrl + Alt + 7 클리핑 마스크 해제하기 Ctrl + 8 컴파운드 패스 만들기 Ctrl + Alt + B 블렌드 만들기 Ctrl + Shift + Alt + B 블렌드 없애기 Ctrl + Shift + Alt + W 와프로 둘러싸서 왜곡하기 Ctrl + Alt + W 메시로 둘러싸서 왜곡하기 Ctrl + Alt + C 상위 오브젝트로 둘러싸서 왜곡하기 Ctrl + Alt + X 라이브 페인트 환경 만들기 편집 단축키 설명 Ctrl + Z 실행 취소 (작업 순서를 전단계로 되돌리기) Ctrl + Shift + Z 다시 실행 (최근 작업 순서로 돌아오기) Ctrl + X 잘라내기 Ctrl + C 복사하기 Ctrl + V 붙여 넣기 Ctrl + F 제자리 위에 붙여 넣기 Ctrl + B 제자리 뒤에 붙여 넣기 Ctrl + Shift + V 현재 아트보드에 붙여 넣기 Ctrl + Shift + Alt + V 모든 아트보드에 붙여 넣기 Ctrl + I 맞춤법 검사하기 보기 단축키 설명 Ctrl + +, Ctrl + Space + 드래그(or 클릭) 도큐먼트 확대 Ctrl + -, Ctrl + Space + Alt + 클릭 도큐먼트 축소 Ctrl + 0 도큐먼트를 화면에 딱 맞게 보기 Ctrl + 1 실 사이즈(100%)로 보기 Space + 드래그 화면 옮기기 Ctrl + Y 아웃라인 보기/숨기기 Ctrl + H 패스 보기/숨기기 Ctrl + R 눈금자 보기/숨기기 Ctrl + Shift + B 바운딩 박스 보기/숨기기 Ctrl + Shift + D 도큐먼트를 투명으로 보기/흰색으로 보기 Ctrl + ; 안내선 보기/숨기기 Ctrl + Alt + ; 안내선 잠그기/풀기 Ctrl + 5 선택한 패스를 안내선으로 만들기 Ctrl + ‘ 격자 보기/숨기기 Ctrl + Shift + I 원근감 격자 보기/숨기기 글자 단축키 설명 Ctrl + Shift + O 글자 속성을 버리고 아웃라인 만들기 Ctrl + → 단어 끝 부분으로 커서 옮기기 Ctrl + ← 단어 첫 부분으로 커서 옮기기 Ctrl + Shift + ↑, ↓ 행 단위로 블록 선택 Ctrl + Shift + →, ← 단어 단위로 블록 선택 Ctrl + Shift + R 오른쪽 정렬 Ctrl + Shift + L 왼쪽 정렬 Ctrl + Shift + C 가운데 정렬 Ctrl + Shift + &gt;, &lt; 글자 크기 키우기, 줄이기 Alt + ↑, ↓ 행간 넓히기, 좁히기 Alt + →, ← 자간 넓히기, 좁히기 Shift + Alt + ↑, ↓ 기준선 올리기, 내리기 툴 단축키 툴 단축키 설명 선택 툴 V 오브젝트 선택 직접 선택 툴 A 오브젝트 기준점이나 패스를 선택 마술봉 툴 Y 비슷한 속성 오브젝트를 모두 선택 올가미 툴 Q 드래그 영역 오브젝트 선택 펜 툴 P 직선, 곡선, 도형 같은 오브젝트를 그리는 툴 글자 툴 T 글자 입력이나 수정 선 툴 \\ 직선, 곡선, 나선, 격자, 원형 격자를 그리는 툴 도형 툴 M 사각형, 원형, 다각형, 별, 광선을 그리는 툴 브러시 툴 B 일반적 패스에 다양한 선 모양이나 붓 터치 느낌을 더하는 툴 연필 툴 N 자유롭게 드래그하여 선을 그리는 툴 블럽 브러시 툴 SHIFT+B 면으로 그림을 그리는 툴 지우개 툴 SHIFT+E 벡터 오브젝트를 지우는 툴 가위 툴 C 패스를 자르는 툴 → 열린 패스가 됨 칼 툴 → 닫힌 패스가 됨 회전 툴 R 오브젝트를 회전하거나 반전 스케일 툴 S 오브젝트 크기를 조절하거나 기울임 폭 툴 SHIFT+W 선 폭을 조절하여 구불구불한 형태로 만듦 자유 변형 툴 E 바운딩 박스의 기준점을 조절하여 크기, 기울기, 회전 정도를 조절 도형 구성 툴 SHIFT+M 선택한 여러 오브젝트를 드래그로 연결해서 한 덩어리로 만듦 라이브 페인트 버킷 툴 K 일반 오브젝트 또는 라이브 트레이스를 이용해 만든 오브젝트에 지정한 색이나 속성을 클릭 한 번으로 적용. 속성이 적용될 때에는 식별하기 쉽도록 붉고 굵은 색이 나타남 라이브 페인트 선택 툴 SHIFT+L 라이브 페인트 버킷 툴로 색을 채운 오브젝트만 선택 원근감 격자 툴 SHIFT+P 원근감 있는 일러스트를 그릴 수 있도록 원근감 격자를 만듦 원근감 선택 툴 SHIFT+V 오브젝트, 텍스트, 심벌을 원근감 격자로 드래그해서 입체적으로 적용함 메시 툴 U 오브젝트 내면에 그물망 모양의 기준점을 추가하여 자연스러운 그레이디언트 효과를 만듦. 사진처럼 정교한 일러스트를 그릴 때 사용함 그레이디언트 툴 G 오브젝트에 그레이디언트 효과를 적용 스포이트 툴 I 오브젝트 속성 복제 블렌드 툴 W 서로 다른 속성을 가진 오브젝트를 자연스럽게 연결하고, 변화 단계를 자동으로 만듦 심벌 툴 SHIFT+S 심벌을 만들고 수정할 수 있음. 심벌 뿌리기 툴로 심벌 오브젝트를 만든 뒤 다른 심벌 툴을 이용해서 밀도, 색상, 위치, 크기, 회전, 투명도, 스타일을 바꿀 수 있음 그래프 툴 J 수치만 입력해서 다양한 그래프를 만듦 아트보드 툴 SHIFT+O 아트보드를 추가, 이동, 복사하고 크기를 조절 슬라이스 툴 SHIFT+K 작업 영역을 웹 이미지별로 나누거나 선택 손 툴 H 작업 화면을 드래그해서 원하는 곳으로 옮김 spacebar를 누르면 손 툴 상태가 됨 돋보기 툴 Z 클릭하거나 드래그해서 화면을 확대. Alt와 함께 사용하면 축소. 더불륵릭하면 작업 화면 크기가 100%로 맞춰짐 초기화 버튼 D 선택한 오브젝트 또는 툴 패널의 컬러 속성을 초기화. 면은 흰색, 선 굵기는 1px, 선 색은 검은색. 스타일이나 브러시가 적용되어 있는 오브젝트는 해당 속성이 사라짐 바꾸기 버튼 SHIFT+X 선택한 오브젝트 또는 툴 패널의 선 색과 면 색을 서로 맞바꿉니다. 면(Fill)과 선(Stroke) X 선택한 오브젝트의 면 색과 선 색을 표시함. 투명은 붉은색 사선으로 나타냄 그리기 모드 SHIFT+D Draw Normal, Draw Behind, Draw Inside 화면 모드 F Normal Screen Mode, Full Screen Mode with Menu Bar, Full Screen Mode 단축키를 다른 정렬로 모음숫자키 조합 단축키 설명 Ctrl + 2 선택한 오브젝트 잠그기 Ctrl + Alt + 2 잠긴 오브젝트 풀어주기 Ctrl + 3 선택한 오브젝트 보이지 않게 숨기기 Ctrl + Alt + 3 감춘 오브젝트 보이게 하기 Ctrl + Shift + Alt + 3 선택한 오브젝트만 남기고 모두 숨기기 Ctrl + 7 클리핑 마스크 만들기 Ctrl + Alt + 7 클리핑 마스크 해제하기 Ctrl + 8 컴파운드 패스 만들기 Ctrl + 0 도큐먼트를 화면에 딱 맞게 보기 Ctrl + 1 실 사이즈(100%)로 보기 Ctrl + 5 선택한 패스를 안내선으로 만들기 토글 단축키 단축키 설명 Ctrl + Y 아웃라인 보기/숨기기 Ctrl + H 패스 보기/숨기기 Ctrl + R 눈금자 보기/숨기기 Ctrl + Shift + B 바운딩 박스 보기/숨기기 Ctrl + Shift + D 도큐먼트를 투명으로 보기/흰색으로 보기 Ctrl + ; 안내선 보기/숨기기 Ctrl + Alt + ; 안내선 잠그기/풀기 Ctrl + ‘ 격자 보기/숨기기 Ctrl + Shift + I 원근감 격자 보기/숨기기 마우스 조합 단축키 설명 Ctrl + 휠 도큐먼트 좌우 이동 Alt + 휠 도큐먼트 확대 축소 Space + 드래그 화면 옮기기 명칭패스 명칭 기준점(Anchor Point) : 패스를 고정하는 기준이 되는 점 세그먼트(Segment) : 기준점 사이의 선 방향점(Direction Point) : 방향선을 움직여 곡선 형태를 조정 방향선(Direction Line) : 세그먼트의 기울기와 굴곡을 조정 패스(Path) : 이어져 있는 기준점과 세그먼트 전체","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"단축키","slug":"단축키","permalink":"http://jacegem.github.io/blog/tags/단축키/"},{"name":"파일","slug":"파일","permalink":"http://jacegem.github.io/blog/tags/파일/"},{"name":"오브젝트","slug":"오브젝트","permalink":"http://jacegem.github.io/blog/tags/오브젝트/"},{"name":"편집","slug":"편집","permalink":"http://jacegem.github.io/blog/tags/편집/"},{"name":"보기","slug":"보기","permalink":"http://jacegem.github.io/blog/tags/보기/"},{"name":"글자","slug":"글자","permalink":"http://jacegem.github.io/blog/tags/글자/"},{"name":"숫자키","slug":"숫자키","permalink":"http://jacegem.github.io/blog/tags/숫자키/"}]},{"title":"일러스트레이터 - Select","slug":"2016/일러스트레이터-Select","date":"2016-02-10T11:11:07.000Z","updated":"2018-01-05T06:31:45.642Z","comments":true,"path":"2016/일러스트레이터-Select/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-Select/","excerpt":"","text":"Select Same [Select]-[Same] 메뉴를 이용하면 선택한 오브젝트와 속성이 같은 오브젝트를 한 번에 선택할 수 있다. Appearance : 모양이 같은 오브젝트를 모두 선택한다. Appearance Attribute : 모양 속성이 같은 오브젝트를 모두 선택한다. Blending Mode : 블렌딩 모드가 같은 오브젝트를 모두 선택한다. Fill &amp; Stroke : 면과 선 속성이 같은 오브젝트를 모두 선택한다. Fill Color : 면 색이 같은 오브젝트를 모두 선택한다. Opacity : 불투명도가 같은 오브젝트를 모두 선택한다. Stroke Color : 선 색이 같은 오브젝트를 모두 선택한다. Graphic Style : 그래픽 스타일이 같은 오브젝트를 모두 선택한다. Symbol Instance : 심벌 속성이 같은 오브젝트를 모두 선택한다. Link Block Series : 같은 블록으로 연결된 텍스트 박스를 선택한다. Select Object [Select]-[Object] 메뉴를 이용하면 원하는 오브젝트를 한 번에 선택할 수 있다. All on Same Layers : 같은 레이어에 있는 오브젝트를 모두 선택한다. Direction Handles : 선택한 오브젝트의 방향선을 모두 본다. Not Aligned to Pixel Grid : 픽셀 그리드에 정렬되지 않은 오브젝트를 모두 선택한다. Bristle Brush Strokes : 강모 브러시가 적용된 오브젝트를 모두 선택한다 Brush Strokes : 브러시가 적용된 오브젝트를 모두 선택한다. Clipping Masks : 클리핑 마스크를 모두 선택한다. (오브젝트는 제외하고 마스크 영역만 선택) Stray Points : 패스가 작성되지 않은 기준점(클릭만 한 상태)을 모두 선택한다. Text Objects : 텍스트 오브젝트(글자 툴로 쓰인 것)를 선택한다. Flash Dynamic Text : 플래시 다이내믹 텍스트를 선택한다. Flash Input Text : 플래시 인풋 텍스트를 선택한다.","categories":[],"tags":[]},{"title":"일러스트레이터 - Extrude&Bevel","slug":"2016/일러스트레이터-Extrude-Bevel","date":"2016-02-10T04:11:50.000Z","updated":"2018-01-05T06:31:48.882Z","comments":true,"path":"2016/일러스트레이터-Extrude-Bevel/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-Extrude-Bevel/","excerpt":"","text":"Extrude &amp; Bevel [Effect]-[3D]-[Extrude&amp;Bevel] Position : 3D 오브젝트의 방향을 선택한다 Perspective : 원근법을 적용한다. Extrude Depth : 입체 기둥의 두께를 정한다. Cap : 오브젝트 면을 표시하거나 없앤다. Bevel : Bevel 모양을 선택한다. Height : Bevel 두께를 정한다 Bevel 을 오브젝트 바깥쪽 또는 안쪽으로 표현한다. Revolve [Effect]-[3D]-[Revolve] Position : 3D 오브젝트의 방향을 선택한다. 드래그해서 위치를 정한다. 수치를 입력해서 위치를 정한다. Perspective : 원근법을 적용한다 Angle : 회전각을 정한다 Cap : 오브젝트 면을 표시하거나 없앤다. Offset : 회전축에 공간을 준다. From : 회전축 위치를 설정한다. Surface : 표면 광택을 외곽선, 단색, 무광, 유광으로 표현한다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"Extrude","slug":"Extrude","permalink":"http://jacegem.github.io/blog/tags/Extrude/"},{"name":"Bevel","slug":"Bevel","permalink":"http://jacegem.github.io/blog/tags/Bevel/"},{"name":"3D","slug":"3D","permalink":"http://jacegem.github.io/blog/tags/3D/"}]},{"title":"일러스트레이터 - Scribble","slug":"2016/일러스트레이터-Scribble","date":"2016-02-10T02:57:26.000Z","updated":"2018-01-05T06:31:34.113Z","comments":true,"path":"2016/일러스트레이터-Scribble/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-Scribble/","excerpt":"","text":"일러스트레이터 - Scribble [Effect]-[Stylize]-[Scribble] Settings : 미리 설정된 낙서 스타일을 선택할 수 있다. Angle : 선 각도를 설정한다. Path Overlap : 선이 오브젝트를 벗어나는 정도를 설정한다. Variation 값으로 뒤틀린 선들의 길이 차이를 설정한다. Stroke Width : 선 두께를 설정한다. Curviness : 선이 구부러지는 정도를 설정한다. Variation 값으로 뒤틀린 선들의 곡선 차이를 설정한다. Spacing : 선이 접힌 간격을 설정한다. Variation 값으로 뒤틀린 선의 간격 차이를 설정한다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"scribble","slug":"scribble","permalink":"http://jacegem.github.io/blog/tags/scribble/"},{"name":"effect","slug":"effect","permalink":"http://jacegem.github.io/blog/tags/effect/"},{"name":"stylize","slug":"stylize","permalink":"http://jacegem.github.io/blog/tags/stylize/"}]},{"title":"일러스트레이터 - 투명도 병합 옵션","slug":"2016/일러스트레이터-투명도-병합-옵션","date":"2016-02-09T10:42:41.000Z","updated":"2018-01-05T06:31:58.838Z","comments":true,"path":"2016/일러스트레이터-투명도-병합-옵션/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-투명도-병합-옵션/","excerpt":"","text":"투명도 병합 옵션 Raster/Vector Balance : 벡터와 비트맵 비율을 정합니다. 수치가 높을 수록 벡터 상태를 많이 유지 하고, 낮을수록 래스터(비트맵)화 된다. 50%로 설정하면 간단한 영역은 벡터로 유지되고 복잡한 영역은 래스터화된다. Line Art and Text Resolution : 오브젝트를 지정한 해상도로 래스터화한다. 작은 글자나 얇은 선은 600~1200 으로 지정한다. Gradient and Mesh Resolution : 그레이디언트된 오브젝트 해상도를 설정한다. 그레이디언트, 메시, 그림자 등은 수치가 높아도 결과가 차이가 없으므로 150~300으로 지정한다. Convert All Text to Outlines : 모든 문자 오브젝트를 아웃라인 처리한다. Convert All Strokes to Outlines : 모든 선을 아웃라인 처리해서 면으로 만든다. 가는 선은 약간 두껍게 나타날 수 있다. 벡터로 처리할 때 패스가 늘어나기 때문에 속도가 느려질 수 있다. Clip Complex Regions : 벡터와 비트맵의 경계를 자연스럽게 표시하는 옵션이다. 경우에 따라 복잡한 패스가 만들어져 속도가 느려질 수 있다. Preserve Alpha Transparency : 알파 투명도를 지원하는 형식으로 저장할 때 체크한다. Preserve Overprints and Spot Colors : 오버프린트와 별색을 보존하는 옵션이다. 문서에 별색과 오버프린트가 설정되어 있으면 분판으로 인쇄할 때 선택한다 (편집 프로그램만 쓸 때는 체킄하지 않는다)","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"투명도","slug":"투명도","permalink":"http://jacegem.github.io/blog/tags/투명도/"},{"name":"옵션","slug":"옵션","permalink":"http://jacegem.github.io/blog/tags/옵션/"}]},{"title":"일러스트레이터 - 타이포그래픽","slug":"2016/일러스트레이터-타이포그래픽","date":"2016-02-09T05:25:40.000Z","updated":"2018-01-05T06:31:41.079Z","comments":true,"path":"2016/일러스트레이터-타이포그래픽/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-타이포그래픽/","excerpt":"","text":"추천 무료 폰트 사이트 폰트클럽 : http://www.fontclub.co.kr 윤디자인연구소 : http://yoonfont.co.kr 폰트릭스 : http://www.fontrix.co.kr 좋은글자 : http://www.goodfont.kr 아시아 폰트 : http://www.asiafont.com 헤움 : http://www.heumm.com 폰트나비 : http://www.fontnavi.com 직지소프트 : http://www.smfont.com 무료 영문 폰트 사이트 : http://www.dafont.com 네이버 나눔 폰트 : http://www.hangeul.naver.com 다음 서체 : http://info.daum.net/Daum/info/introduceOfCl.do 서울 서체 : http://design.seoul.go.kr KT&amp;G 상상체 : http://www.kfng.com/kr/company/sangsang.jsp 글자 툴과 글자 패널 Type Tool : 기본 글자 툴. 다른 툴이 선택되어 있어도 써 둔 글자를 더블클릭하면 글자를 다시 입력하거사 수정할 수 있다. 패스 위에서는 패스 글자 툴, 닫힌 패스 위에서는 패스 영역 속에 글자를 입력할 수 있도록 바뀐다. Area Type Tool : 닫힌 패스 속에 글자를 쓴다. Type on a Path Tool : 패스를 따라 글자를 쓴다. Vertical Type Tool : 세로쓰기를 한다. Vertical Area Type Tool : 닫힌 패스 속에서 세로쓰기를 한다. Vertical Type on a Path Tool : 패스를 따라 세로쓰기를 한다. Type on a Path Rainbow : 글자가 기준선 직각 방향으로 나열된다. Skew : 글자가 기준선 모양대로 비스듬해진다. 3D Ribbon : 글자가 기준선을 따라 입체적인 모양으로 변형된다. Stair Step : 글자 방향은 그대로 유지한 채 위치만 기준선을 따른다. Gravity : 글자가 무게 중심점 방향으로 왜곡된다. Erase로 지우고 나서 Gradient 이미지를 불러와서 image tracepathfinder 에서 minus font 처리gradient 텍스트를 선택하고 Ctrl+8 로 외각선만 남김배경화 함께 선택 후 Ctrl+7 왜곡 툴로 변형 후 Gradient [Windows]-[Graphic Style Libraries] 적용 [Object]-[Envelope Distort]-[Make with Top Object]","categories":[],"tags":[{"name":"illustratro","slug":"illustratro","permalink":"http://jacegem.github.io/blog/tags/illustratro/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"}]},{"title":"일러스트레이터 - 원근감 격자","slug":"2016/일러스트레이터-원근감-격자","date":"2016-02-09T03:18:08.000Z","updated":"2018-01-05T06:31:55.597Z","comments":true,"path":"2016/일러스트레이터-원근감-격자/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-원근감-격자/","excerpt":"","text":"원근감 격자Perspective Grid Hide Grid : 원근감 격자를 보이지 않게 한다 Show Rulers : 실측 줄자를 표시한다 Snap to Grid : 오브젝트를 그리거나 옮길 때 격자에 스냅이 건다 Lock Grid : 원근감 격자가 움직이지 않게 고정한다. Lock Station Point : 소실점 하나를 옮기면 다른 소실점이 영향을 받아 함께 움직인다. Defind Grid : 원근감 격자를 설정한다. One, Two, Three Point Perspective : 1,2,3점 투시 격자를 만든다. Save Grid as Preset : 설정한 격자를 저장한다. Define Perspective Grid Perspective Grid SettingsPerspective Grid Settings : 격자 모양을 1점, 2점, 3점 투시 중 선택할 수 있다. 격자 단위(Units), 실측 비율(Scale), 격자 간격(Gridline every)을 설정한다. 시선의 좌우 각도(Viewing Angle)와 관찰자와의 거리(Viewing Distance)와 눈높이(Horizon Height), 3점 투시가 선택된 경우 세번째 소실점의 좌표 값(Third Vanishing Point)을 설정한다. Grid Color &amp; OpacityGrid Color &amp; Opacity : 격자 색과 전체적인 투명도를 설정한다. 격자 색은 평면 전환 위젯의 면 색을 나타낸다. 따라 그리기","categories":[],"tags":[{"name":"illustrator","slug":"illustrator","permalink":"http://jacegem.github.io/blog/tags/illustrator/"},{"name":"perspective","slug":"perspective","permalink":"http://jacegem.github.io/blog/tags/perspective/"},{"name":"grid","slug":"grid","permalink":"http://jacegem.github.io/blog/tags/grid/"},{"name":"preset","slug":"preset","permalink":"http://jacegem.github.io/blog/tags/preset/"}]},{"title":"[안드로이드] 원더택티스","slug":"2016/안드로이드-원더택티스","date":"2016-02-08T11:38:00.000Z","updated":"2018-01-05T06:32:16.124Z","comments":true,"path":"2016/안드로이드-원더택티스/","link":"","permalink":"http://jacegem.github.io/blog/2016/안드로이드-원더택티스/","excerpt":"","text":"[안드로이드] 원더택티스 시작하면 파일을 다운로드 합니다. TIPS 영웅 강화 : 영웅 강화 성공 시 기본 능력치가 상승해요! 영웅진화 : 영웅 진화는 랜덤/고정 진화 중 선택할 수 있어요! 영웅초월 : 초월은 5회까지 가능하고, 영웅의 최대 레벨이 상승해요. 영웅 마스터 : 영웅 30레벨을 달성할 때마다 마스터 보상을 준답니다. 특성 활성화 : 조건에 맞는 장비와 보석 장착 시 특성이 활성화돼요. 보석 강화 : 보석 강화를 하면 옵션의 수치가 올라가요. 강화 보너스 : 장비 강화 2단계마다 보너스가 있어요! 장비 강화 : 장비 강화 성공 시 주 옵션의 수치가 올라가요. 비밀 던전 속성 : 비밀 던전의 속성은 매일 변경됩니다. 보물의 탑 보상 : 보물의 탑 층마다 다양한 보상을 얻을 수 있어요. 다승 보상 : 대전 상대를 7번, 10번 이기면 추가 보상이 있답니다. 고대의 성채 보상 : 고대의 성채 지하에서 높은 등급의 장비를 얻을 수 있어요. 오래된 폐광 보상 : 오래된 폐광 지하에서 높은 레벨의 보석을 얻을 수 있어요. 시련의 둥지 보상 : 보스 최종 레벨에 따라 보상 상자의 종류가 달라져요. 전설 보석 : 6레벨 강화 시 일정 확률로 전설 보석이 되며, 특별한 옵션이 붙습니다. 나무, 불, 물, 빛, 어둠 SKILL AUTO는 스킬을 선택해야 시작된다. 스테이지를 클리어한 이후에는 FULL AUTO 사용이 가능하다. 6성 영웅 스킬 플레이 화면 하단에 스킬이 표시된다. 9개의 칸에 칠한 색으로 스킬의 범위와 효과를 표시한다. 빨간색은 공격 스킬, 녹색은 아군용 스킬이다. 연속된 줄로 표시된 것은, 행 또는 열에 효과가 적용되는 스킬이다. 하나의 점은 하나의 대상에 적용되는 스킬이다. 두개 이상의 점이 서로 떨어져 있다면 행, 열과 상관없이 그 수만큼 효과가 적용되는 스킬이다. 9개의 칸에 모두 색이 칠해져 있다면 전역 스킬이다. 캐릭터당 스킬을 2개씩 표현하다보니, 5 캐릭터가 화면을 모두 차지한다. 이것때문에 파티에 참가할 수 있는 최대 영웅수가 5개로 제한된것인가… 스킬을 시전하면 다음 시전까지 기다려야 하는 턴 수가 우측 하단에 표시된다.","categories":[],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://jacegem.github.io/blog/tags/안드로이드/"},{"name":"게임","slug":"게임","permalink":"http://jacegem.github.io/blog/tags/게임/"}]},{"title":"일러스트레이터 - 따라하기 사진, 배경","slug":"2016/일러스트레이터-따라하기-사진","date":"2016-02-08T07:40:21.000Z","updated":"2018-01-05T06:32:05.857Z","comments":true,"path":"2016/일러스트레이터-따라하기-사진/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-따라하기-사진/","excerpt":"","text":"[Effect] - [Distort &amp; Transform] - [Zig Zag] 로 배경 생성. Rotate 로 복제 후 색 변경. 3 Color 로 만들고, 마술봉으로 색 변환처리 Mesh 를 사용하여 변형 왜곡 사각형 생성Mesh 툴로 5군데 분할 후 색 지정가운데 흰색 선 여러개 생성[Effect]-[Stylize]-[Outer Glow] 지정Transparency - Overlay Create Gradient Mesh 브러쉬 사용하기","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"사진","slug":"사진","permalink":"http://jacegem.github.io/blog/tags/사진/"},{"name":"배경","slug":"배경","permalink":"http://jacegem.github.io/blog/tags/배경/"}]},{"title":"따라그리기 - 캐릭터","slug":"2016/따라그리기-캐릭터","date":"2016-02-08T03:15:24.000Z","updated":"2018-01-05T06:32:19.228Z","comments":true,"path":"2016/따라그리기-캐릭터/","link":"","permalink":"http://jacegem.github.io/blog/2016/따라그리기-캐릭터/","excerpt":"","text":"따라그리기 - 캐릭터","categories":[],"tags":[{"name":"캐릭터","slug":"캐릭터","permalink":"http://jacegem.github.io/blog/tags/캐릭터/"}]},{"title":"일러스트레이터 - 라이브 트레이싱","slug":"2016/일러스트레이터-라이브-트레이싱","date":"2016-02-08T03:10:57.000Z","updated":"2018-01-05T06:32:12.396Z","comments":true,"path":"2016/일러스트레이터-라이브-트레이싱/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-라이브-트레이싱/","excerpt":"","text":"일러스트레이터 - 라이브 트레이싱 Preset : 원하는 라이브 트레이스 스타일을 선택 Simple Trace : Default 와 같은 스타일로 어두운 명암 부분이 검은색 패스로 추출 Color 6과 Color 16 : 색을 6단계와 16단계로 나누어 표현. 스케치보다 명암 단계가 뚜렷하게 구분되는 사진 이미지에 적용 Photo Low와 High Fidelity : 저품질과 고품질 사진 이미지로 표현. High Fidelity로 바꾸면 사진 이미지와 흡사한 디테일 일러스트를 만들 수 있음 Grayscale : 이미지를 흑백 명암으로 구분해서 표현 Hand Drawn Sketch : 펜으로 그린 이미지를 선으로 추출 Detailed Illustration : 명함을 원본과 가장 흡사하게 표현하는 스타일. 어두운 명암 부분이 검은색 패스로 추출 Comic Art : 만화처럼 필압이 느껴지도록 표현. 굵기가 일정한 펜으로 그린 스케치 이미지라고 해도 Comic Art 스타일로 바꾸면 선에 강약이 표현되어 역동적인 느낌을 낼 수 있음. 검은색과 흰색 패스로 추출 Technical Drawing : 명암의 경계선을 둘러싼 형태로 선을 표현. Black and White Logo : 검은색과 흰색 로고 스타일로 표현 One Color Logo : 한 가지 색 로고를 표현하는 것으로 어두운 명암 부분이 검은색 패스로 추출 Inked Drawing : 잉크로 그린 효과 Lattering : 레터링 펜으로 그린 효과 Expand : 트레이싱 이미지를 벡터로 전환합니다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"라이브","slug":"라이브","permalink":"http://jacegem.github.io/blog/tags/라이브/"},{"name":"트레이싱","slug":"트레이싱","permalink":"http://jacegem.github.io/blog/tags/트레이싱/"}]},{"title":"일러스트레이터 - 패스파인더 패널","slug":"2016/일러스트레이터-패스파인터-패널","date":"2016-02-08T03:09:32.000Z","updated":"2018-01-05T06:32:02.693Z","comments":true,"path":"2016/일러스트레이터-패스파인터-패널/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-패스파인터-패널/","excerpt":"","text":"일러스트레이터 - 패스파인더 패널 Shape Modes : 여러 오브젝트를 하나로 합칩니다. 합친 오브젝트는 맨 위에 있는 오브젝트 속성을 따릅니다. Expand : Alt 를 누른 채로 Shape Mode 버튼을 클릭하면 Expand 버튼을 누르기 전까지는 직접 선택 툴을 이용해서 수정할 수 있습니다. Pathfinders : 선택한 오브젝트에서 겹쳐지는 패스를 이용하여 오브젝트를 나눕니다. 나눈 다음 그룹을 풀면 오브젝트별로 나눠집니다. Shape Modes 버튼 합치기 : 선택한 오브젝트를 하나로 합칩니다. 위쪽 지우기 : 위쪽 오브젝트 영역을 지웁니다. 겹친 부분 남기기 : 선택한 오브젝트가 모두 겹쳐지는 부분만 남기고, 나머지 영역은 지웁니다. 겹친 부분 지우기 : 겹친 부분만 지웁니다. Pathfinders 버튼 면 나누기 : 오브젝트를 겹쳐진 패스 모양대로 나눕니다. 분리하기 : 오브젝트를 눈에 보이는 모양대로 나눕니다. 병합하기 : 오브젝트 색이 모두 따르면 분리하기와 같지만, 색이 같은 오브젝트는 같은 색끼리 묶어서 나눕니다. 윗면으로 자르기 : 맨 위에 있는 오브젝트와 겹치는 아래 부분만 남깁니다. 윤곽선 나누기 : 패스가 교차되는 곳을 모두 잘라 선으로만 표현합니다. 면 색이 선 색으로 바뀝니다. 뒷면 지우기 : 맨 윗면만 남기고 겹치거나 뒤에 위치한 오브젝트는 모두 지웁니다. 쉐이프 빌더 툴쉐이프 빌더 툴을 사용하면 오브젝트를 합치거나, 필요 없는 부분을 클릭으로 없앨 수 있다. 면과 선 속성을 가진 오브젝트 두 개가 겹쳐 있을 때 쉐이프 빌더 툴로 오브젝트를 드래그 하면 해당 영역이 한 덩어리로 합쳐진다. Alt를 누르면 마우스 포인터가 바뀌고 클릭하거나 드래그 한 곳은 지워진다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"패스파인더","slug":"패스파인더","permalink":"http://jacegem.github.io/blog/tags/패스파인더/"},{"name":"pathfinder","slug":"pathfinder","permalink":"http://jacegem.github.io/blog/tags/pathfinder/"}]},{"title":"일러스트레이터 - 툴 단축키","slug":"2016/일러스트레이터-툴-단축키","date":"2016-02-08T02:57:54.000Z","updated":"2018-01-05T06:32:09.050Z","comments":true,"path":"2016/일러스트레이터-툴-단축키/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-툴-단축키/","excerpt":"","text":"일러스트레이터 - 툴 단축키 툴 단축키 툴 단축키 설명 선택 툴 V 오브젝트 선택 직접 선택 툴 A 오브젝트 기준점이나 패스를 선택 마술봉 툴 Y 비슷한 속성 오브젝트를 모두 선택 올가미 툴 Q 드래그 영역 오브젝트 선택 펜 툴 P 직선, 곡선, 도형 같은 오브젝트를 그리는 툴 글자 툴 T 글자 입력이나 수정 선 툴 \\ 직선, 곡선, 나선, 격자, 원형 격자를 그리는 툴 도형 툴 M 사각형, 원형, 다각형, 별, 광선을 그리는 툴 브러시 툴 B 일반적 패스에 다양한 선 모양이나 붓 터치 느낌을 더하는 툴 연필 툴 N 자유롭게 드래그하여 선을 그리는 툴 블럽 브러시 툴 SHIFT+B 면으로 그림을 그리는 툴 지우개 툴 SHIFT+E 벡터 오브젝트를 지우는 툴 가위 툴 C 패스를 자르는 툴 → 열린 패스가 됨 칼 툴 → 닫힌 패스가 됨 회전 툴 R 오브젝트를 회전하거나 반전 스케일 툴 S 오브젝트 크기를 조절하거나 기울임 폭 툴 SHIFT+W 선 폭을 조절하여 구불구불한 형태로 만듦 자유 변형 툴 E 바운딩 박스의 기준점을 조절하여 크기, 기울기, 회전 정도를 조절 도형 구성 툴 SHIFT+M 선택한 여러 오브젝트를 드래그로 연결해서 한 덩어리로 만듦 라이브 페인트 버킷 툴 K 일반 오브젝트 또는 라이브 트레이스를 이용해 만든 오브젝트에 지정한 색이나 속성을 클릭 한 번으로 적용. 속성이 적용될 때에는 식별하기 쉽도록 붉고 굵은 색이 나타남 라이브 페인트 선택 툴 SHIFT+L 라이브 페인트 버킷 툴로 색을 채운 오브젝트만 선택 원근감 격자 툴 SHIFT+P 원근감 있는 일러스트를 그릴 수 있도록 원근감 격자를 만듦 원근감 선택 툴 SHIFT+V 오브젝트, 텍스트, 심벌을 원근감 격자로 드래그해서 입체적으로 적용함 메시 툴 U 오브젝트 내면에 그물망 모양의 기준점을 추가하여 자연스러운 그레이디언트 효과를 만듦. 사진처럼 정교한 일러스트를 그릴 때 사용함 그레이디언트 툴 G 오브젝트에 그레이디언트 효과를 적용 스포이트 툴 I 오브젝트 속성 복제 블렌드 툴 W 서로 다른 속성을 가진 오브젝트를 자연스럽게 연결하고, 변화 단계를 자동으로 만듦 심벌 툴 SHIFT+S 심벌을 만들고 수정할 수 있음. 심벌 뿌리기 툴로 심벌 오브젝트를 만든 뒤 다른 심벌 툴을 이용해서 밀도, 색상, 위치, 크기, 회전, 투명도, 스타일을 바꿀 수 있음 그래프 툴 J 수치만 입력해서 다양한 그래프를 만듦 아트보드 툴 SHIFT+O 아트보드를 추가, 이동, 복사하고 크기를 조절 슬라이스 툴 SHIFT+K 작업 영역을 웹 이미지별로 나누거나 선택 손 툴 H 작업 화면을 드래그해서 원하는 곳으로 옮김 spacebar를 누르면 손 툴 상태가 됨 돋보기 툴 Z 클릭하거나 드래그해서 화면을 확대. Alt와 함께 사용하면 축소. 더불륵릭하면 작업 화면 크기가 100%로 맞춰짐 초기화 버튼 D 선택한 오브젝트 또는 툴 패널의 컬러 속성을 초기화. 면은 흰색, 선 굵기는 1px, 선 색은 검은색. 스타일이나 브러시가 적용되어 있는 오브젝트는 해당 속성이 사라짐 바꾸기 버튼 SHIFT+X 선택한 오브젝트 또는 툴 패널의 선 색과 면 색을 서로 맞바꿉니다. 면(Fill)과 선(Stroke) X 선택한 오브젝트의 면 색과 선 색을 표시함. 투명은 붉은색 사선으로 나타냄 그리기 모드 SHIFT+D Draw Normal, Draw Behind, Draw Inside 화면 모드 F Normal Screen Mode, Full Screen Mode with Menu Bar, Full Screen Mode","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"단축키","slug":"단축키","permalink":"http://jacegem.github.io/blog/tags/단축키/"},{"name":"툴","slug":"툴","permalink":"http://jacegem.github.io/blog/tags/툴/"}]},{"title":"일러스트레이터 - 참고 사이트","slug":"2016/일러스트레이터-참고-사이트","date":"2016-02-07T13:18:55.000Z","updated":"2018-01-05T06:32:42.076Z","comments":true,"path":"2016/일러스트레이터-참고-사이트/","link":"","permalink":"http://jacegem.github.io/blog/2016/일러스트레이터-참고-사이트/","excerpt":"","text":"일러스트레이터 - 참고 사이트 일러스트 실무 아카데미 일러스트 연구원 (http://illustin.com) 입필 미래그림연구소 (http://www.ippil.com) 일러스트 아카데미 (http://www.illustacademy.com) 디자인 실무 아카데미 아카데미 정글 (http://www.ejungle.co.kr) 디자인 나스 (http://www.designnas.com) SBS 컴퓨터아트학원 (http://www.sbsart.com) 캘리그래피 전문가 과정 필묵 아카데미 (http://www.philmuk.co.kr) 강병인 캘리그래피 연구소 (http://www.sooltong.co.kr) 캘리디자인 (http://www.callidesign.co.kr) 추천 사이트 디자인넷 (http://www.designnet.co.kr) 디자인 (http://mdesign.design.co.kr) 디자인정글 (http://jungle.co.kr) 디자인플럭스 (www.designflux.co.kr) 컴퓨터아트 (http://www.computerarts.co.uk) 굿디자인 (http://www.goodesign.or.kr) 디자인 클러스터 (http://www.dcluster.seoul.kr) 디자인DB (http://www.designdb.com) 한국디자인진흥원 (http://www.kidp.or.kr) 전시회 서울디자인페스티벌 (http://www.designfestival.co.kr) 서울리빙디자인페어 (http://www.livingdesignfair.co.kr) 서울캐릭터라이선싱페어 (http://characterfair.kr) 디자인 &amp; 아트 페어 (http://www.designartfair.com) TOKYO DESIGNERS WEEK (http://www.tdwa.com) 동경디자인페스타 (http://www.designfesta.com) 런던 100% 디자인 박람회 (http://www.100percentdesign.co.uk) 촬영하고 스크랩하고 기록하기 카메라로 자료가 될만한 것은 모두 찍기 휴대폰이나 수첩에 아이디어 스케치 하기 스크랩북을 만들거나 블로그에 정리하기 추천 이미지 라이브러리 무료 사이트 Stock_XCHNG (http://www.sxc.hu) 모그파일 (http://www.morguefile.com) 쉐어이미지 (http://www.shareimage.com) 추천 이미지 라이브러리 유료 사이트 아사달 정액숍 (http://www.period.assadal.com) 오픈애즈 (http://www.openas.com) 클립아트 코리아 (http://www.clipartkorea.co.kr) 출처 회사에서 바로 통하는 일러스트레이터 CS5 - 박혜진 지음 (한빛미디어)","categories":[],"tags":[{"name":"참고","slug":"참고","permalink":"http://jacegem.github.io/blog/tags/참고/"},{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/일러스트레이터/"},{"name":"사이트","slug":"사이트","permalink":"http://jacegem.github.io/blog/tags/사이트/"}]},{"title":"철수랑 영희랑 고양이랑","slug":"2016/철수랑-영희랑-고양이랑","date":"2016-02-07T06:40:17.000Z","updated":"2018-01-05T06:32:26.576Z","comments":true,"path":"2016/철수랑-영희랑-고양이랑/","link":"","permalink":"http://jacegem.github.io/blog/2016/철수랑-영희랑-고양이랑/","excerpt":"","text":"철수랑 영희랑 고양이랑 배경과 패턴은 나중에 추가하는 걸로 한다.각 오브젝트의 경계선이 따로 있어서, 하나를 움직이면 뒷배경이 흰색으로 남는다. 오브젝트들이 연속적으로 이어지게 하려면 어떻게 해야 할까.","categories":[],"tags":[]},{"title":"커피베이에서","slug":"2016/커피베이에서","date":"2016-02-07T02:17:33.000Z","updated":"2018-01-05T06:32:22.345Z","comments":true,"path":"2016/커피베이에서/","link":"","permalink":"http://jacegem.github.io/blog/2016/커피베이에서/","excerpt":"","text":"2013.09 커피베이에서","categories":[],"tags":[{"name":"커피","slug":"커피","permalink":"http://jacegem.github.io/blog/tags/커피/"},{"name":"커피베이","slug":"커피베이","permalink":"http://jacegem.github.io/blog/tags/커피베이/"}]},{"title":"임실치즈테마파크 언덕에서","slug":"2016/임실치즈테마파크-언덕에서","date":"2016-02-07T02:10:44.000Z","updated":"2018-01-05T06:32:35.073Z","comments":true,"path":"2016/임실치즈테마파크-언덕에서/","link":"","permalink":"http://jacegem.github.io/blog/2016/임실치즈테마파크-언덕에서/","excerpt":"","text":"2013.11 임실치즈테마파크 언덕에서","categories":[],"tags":[{"name":"임실","slug":"임실","permalink":"http://jacegem.github.io/blog/tags/임실/"},{"name":"치즈","slug":"치즈","permalink":"http://jacegem.github.io/blog/tags/치즈/"},{"name":"테마파크","slug":"테마파크","permalink":"http://jacegem.github.io/blog/tags/테마파크/"},{"name":"언덕","slug":"언덕","permalink":"http://jacegem.github.io/blog/tags/언덕/"}]},{"title":"15분 의지","slug":"2016/15분-의지","date":"2016-02-06T13:53:30.000Z","updated":"2018-01-05T06:33:04.341Z","comments":true,"path":"2016/15분-의지/","link":"","permalink":"http://jacegem.github.io/blog/2016/15분-의지/","excerpt":"","text":"노트를 정리하며, 내용을 옮긴다. 아무리 바빠도, 15분 정도의 시간은 만들려고 한다면 충분히 만들 수 있다. 중요한 것은 15분이라는 시간을 만들 의지가 자신에게 있는가 없는가이다. 당신은 진심으로 어떤 일을 하고 싶은가? 재미있는 일? 오늘 하는 일의 대가는 2년 후에 받을 수 있으리라 생각해야 한다.무엇인가를 성취하고 싶다면 시간을 들여 스스로 알아나가고 이해해라. 진심으로 열정을 느끼는 일을 찾아라. 잘 들었지? 네가 무슨 일을 하드, 사람들은 항상 트집을 잡고 험담을 할 게다. 그러니 사람들 말에 귀를 기울여서는 안 된단다.– 나스레딘의 아들, 지하드 다르비슈 다들 아는 진리를 깨달았어요. 세상에 쉬운 일은 하나도 없다는 걸. 오히려 쉽다고 생각해서 더 고생한 것 같아요. 그래서 그 다음부터는 그런 기대일랑은 깨끗하게 접었습니다. 편해 보이는 길과 힘들어 보이는 길이 있으면 무조건 힘들어 보이는 길을 택했습니다. 뭐, 고민할 게 없어서 좋더군요.– 우리가 보낸 순간 : 소설 삶은 언제나 나에게 질문을 한다. 쉬운거 할래, 어려운거 할래.그 질문에 대해서 인간은 언제나 익숙한 것을 선택한다. 상황에 맞는 가면. 그 가면들을 몇 개쯤은 누구나 가지고 살아가지요. 내가 아는 사실을 자연스럽고 자세하게 풀어서 설명하면 좋은 글이 된다. 평범한 진리를 세부적으로 꼼꼼히 묘사하면 문학이 된다. 넓은 줄만 알았던 골목길이 좁아 보이기 시작하면서 우리는 어른이 된다. 어른에게만 시간이 빠르게 느껴지는 이유는 어린아이처럼 많이 걷고 달리지 않기 때문이다. 어떤 문제를 낳게 한 것과 동일한 사고방식으로는 그 문제를 해결할 수 없다.– 알버트 아인슈타인 자신을 통제하는 것보다 더 작은 통제도, 더 큰 통제도 없다. 그것이 가장 작은 통제인 것은 자기 자신조차 통제하지 못하면서 자기 이외의 다른 것을 통제할 수는 없기 때문이며, 그것이 가장 위대한 통제인 것은 자신을 완전히 통제하는 것은 정말 어려운 일이기에 그걸 해내는 것이야말로 다른 어떤 일보다 큰일이기 때문이다.– 레오나르도 다빈치 어떤 외부적인 요인 때문에 괴로워하고 있다면 고통은 그 자체 때문이 아니라 그것에 대한 우리의 생각 때문이다. 그리고 우리는 어느 때든 그 생각을 철회할 힘을 갖고 있다.– 마르쿠스 아우렐리우스","categories":[],"tags":[{"name":"15분","slug":"15분","permalink":"http://jacegem.github.io/blog/tags/15분/"},{"name":"의지","slug":"의지","permalink":"http://jacegem.github.io/blog/tags/의지/"}]},{"title":"밑그림 드로잉 노하우","slug":"2016/밑그림-드로잉-노하우","date":"2016-02-06T13:37:55.000Z","updated":"2018-01-05T06:32:30.452Z","comments":true,"path":"2016/밑그림-드로잉-노하우/","link":"","permalink":"http://jacegem.github.io/blog/2016/밑그림-드로잉-노하우/","excerpt":"","text":"노트를 정리하며, 메모한 내용을 옮깁니다. 밑그림 드로잉의 네 가지 노하우 앞에 있는 대상을 먼저 그립니다. 직선은 최대한 반듯하게 한 번에 긋습니다. 마무리에 가까울 수록 연필의 심을 뽀죡하게 깎습니다. 스케치북의 가장 자리는 여백으로 남겨 둡니다.","categories":[],"tags":[{"name":"드로잉","slug":"드로잉","permalink":"http://jacegem.github.io/blog/tags/드로잉/"},{"name":"노하우","slug":"노하우","permalink":"http://jacegem.github.io/blog/tags/노하우/"}]},{"title":"[words] Muscle Organization in Individuals with and without Pair and Joint Dysfunction","slug":"2016/words-Muscle-Organization-in-Individuals-with-and-without-Pair-and-Joint-Dysfunction","date":"2016-02-06T12:56:15.000Z","updated":"2018-01-05T06:32:46.675Z","comments":true,"path":"2016/words-Muscle-Organization-in-Individuals-with-and-without-Pair-and-Joint-Dysfunction/","link":"","permalink":"http://jacegem.github.io/blog/2016/words-Muscle-Organization-in-Individuals-with-and-without-Pair-and-Joint-Dysfunction/","excerpt":"","text":"단어 dysfunction : [의학] 기능 장애, 고장 masticatory : 저작의, 저작에 쓰는 bilateral : 쌍방의, 좌우 대칭의 electromyography : (의학) 근전도 검사 [기록] (법) incisor : [치과] 앞니 molar : 어금니, 구치 neuromuscular : [생리·생물] 신경과 근육의[에 관한], 신경근의 regression : 후퇴, 쇠퇴, 퇴화 약어 TMD : temporomandibular disorders TMJ : temporomandibular Joint DD : disc displacement MJL : minimization of Joint loads MME : minimization of muscle effort ANOVA : analysis of variance 단어 synovial : [생리] 활액의(을 분비하는) craniormadibular : 두개하악 apparatus : [생리] 기관 indeterminate : 확실하지 않은, 정역학 이론으로는 완전히 분석[결정] 할 수 없는 mastication : 씹음, 저작 apportionment : 분배, 할당 biomechanics : 생체[생물] 역학; 생물의 역학적 연구 effectively : 효과적으로, 유효하게 invasive : [의학] (치료가) 몸에 칼을 대는때 외과적인 electromyographic (EMG) : (의학) 근전도 검사[기록] (법) 의 constrain : 강요하다, 제약을 가하다. numerical : 수의[에 관한]; 수를 나타내는 consistent : 일치하는, 일관된 mandibular : (아래) 턱의, (아랫) 부리의 musculature : 근육 조직 eminence : [해부] (특히 뼈의 표면의) 융기, 돌출 to date : 최신 primarily : 본질적으로, 처음에는 objective : 목적, 객관적인 [의학]&lt;증상이&gt; 타각성의 masseter : [의학] 교근, 저작근 temporalis : 측두근","categories":[],"tags":[{"name":"words","slug":"words","permalink":"http://jacegem.github.io/blog/tags/words/"},{"name":"muscle","slug":"muscle","permalink":"http://jacegem.github.io/blog/tags/muscle/"},{"name":"dysfunction","slug":"dysfunction","permalink":"http://jacegem.github.io/blog/tags/dysfunction/"}]},{"title":"[메모] 노트 사용법","slug":"2016/메모-노트-사용법","date":"2016-02-06T12:04:43.000Z","updated":"2018-01-05T06:33:00.412Z","comments":true,"path":"2016/메모-노트-사용법/","link":"","permalink":"http://jacegem.github.io/blog/2016/메모-노트-사용법/","excerpt":"","text":"노트를 이렇게 사용하면 괜찮을 듯싶어서 적는 내용이다. 책에 나온 내용을 정리한다. 하나의 내용은 한 페이지를 모두 사용한다.페이지가 비었다고 해서 다른 내용을 적지 않는다. 온전히 한 페이지 안에서는 같은 주제를 가지고 있어야 한다. 페이지에 다른 내용을 적는 이유는 단 하나, 남는 여백이 아깝다는 이유일 것이다. 한 페이지 안에 여러 주제가 섞이게 되면 주제가 혼탁해지고, 추가로 적고 싶은 내용이 생겨도 여백이 없어서 적지 못 하는 사태가 발생한다. 뒤에서 시작해도 된다.앞에서부터 시작해도 되고, 뒤에서부터 시작해도 된다. 계속해서 이어지는 연속성만 있으면 된다. 뒤에서 시작해도 되는 것은 또 다른 주제에 대해서 모으는 길을 만드는 것이다. 앞에서부터는 생각을 모으고, 뒤에서부터는 할 일을 모을 수도 있다. 몇 페이지를 건너뛰고 중간부터 시작하면 나중에 다른 페이지가 채워졌을 때 흐름이 깨질 수 있으므로, 앞·뒤 두 군데에서만 시작해 보자. 예약하자.만약 여러 페이지를 사용할 예정이라면, 그냥 붕~ 띄우지 말고, 예약 이라는 표시를 남기자. 다른 주제를 메모할 때에는 예약 표시가 없는 부분부터 시작한다. 표시함으로써 기억에 남게 되고, 그 주제에 대해 생각하게 된다. (빈 페이지를 채워야 하는 압박감도 생긴다) 마크다운을 사용하자.노트에 펜으로 적을 때도 마크다운을 사용한다. 컴퓨터로 내용을 옮길 때에 편하고, 작성할 경우에도 이것이 제목인지, 강조 내용인지 표시할 수 있으므로 더욱 형식화된 문서를 작성할 수 있다. 책에서 옮긴 내용메모를 재활용하라 예전의 메모를 다시 읽어보는 습관부터 기른다. 메모한 것들을 날짜별 혹은 주제별로 정리한다. 정리된 메모를 문서보관 상자에 보관한다. 다시 읽을 때는 느낀 점이나 아이디어를 다른 색 펜으로 적어둔다. 메모한 것을 다시 읽기 위해서는 메모를 한 곳에 하는 습관이 필요하다. 매번 새로운 곳에 메모하면 이전의 것은 찾기 힘들어진다. 한 곳에 메모하고, 메모가 끝나면 앞 장을 들춰보는 습관을 가진다. 메모한 것을 다시 읽을 때 새로운 생각이나 느낌이 들었다면 그곳에 다시 메모한다. 생각에 생각을 더하는 방식으로 진행한다. 느낀 점을 적기 위해서는 메모한 곳에 충분한 여백이 있어야 한다. 나중에 추가 메모를 위해서 여백을 고려하여 메모한다. 왼쪽에 줄이 그어져 있는 노트를 활용해도 되고, 글을 쓸 때 좌우 여백을 충분히 남기면서 글을 쓰는 습관을 지녀도 괜찮다. 주머니에 휴대할 수 있을 정도의 수첩을 준비한다. 즉시 꺼낼 수 있는 필기도구를 준비한다. (바깥 주머니 등에서 즉시 꺼낼 수 있도록) 상황별 메모 도구 집에서 쉴 때 : A4 용지 크기의 복사용지를 적당히 잘라 상자에 넣은 후 집안 여기저기에 놓고, 그 위에 펜을 올려놓는다. 잘 때 : 머리맡에 노트를 준비해둔다. 잘라 놓은 종이를 활용하려면, 그 종이를 모을 곳이 필요하다. 메일에서 사용하는 보관함 같은 것이 필요하다. 메모를 하고 모으는 상자에 담는다. 따라서 잘라놓은 종이를 사용하기보다는 적당한 크기의 노트를 놓고, 그 위에 펜을 올려놓는 것이 메모를 모으는데 더 편리하다. 잘 때는 빛이 없어서 메모하기에 불편하다. 메모 하기 위해 불을 켜는 것은 수면을 방해하기 때문에 좋지 않다. 빛이 나오는 라이트펜을 사용하는 방법을 고려할 만하다. 수첩 사용 시 주의점 백업작업 : 1년에 한두 번은 메모 내용이나 주소록 등 자료 전체를 복사하여 보관 백업을 할 때는 디지털을 활용하자. 에버노트로 사진을 찍어서 보관하는 방법도 좋다. 무료로 이용해도 한 달에 60MB를 저장할 수 있다. 명함에 주인을 알 수 있도록 메모하라.명함 교환 시 상대방의 특징을 명함에 메모하라. 메모 습관을 만들기 위한 원포인트 레슨 노트는 비싼 거로 고르자 - 몰스킨 예쁘게 쓰기보다 많이 쓰자 - 여러 곳에서 메모할 수 있도록 환경을 만들자 들고 다니기 편한 게 최고다. 편과 종이의 맛을 살리자 - 노트는 몰스킨, 펜은 기호에 따라 좋은 것으로 고르자. 생각을 검열하지 말자 - 그냥 생각나는 데로 적어보자. 몰스킨 Moleskine표지가 단단하다.펼치면 활짝 펼쳐져서 편리하다.크기가 여러 가지이다.그림을 그릴 수 있다. &lt;네버랜드를 찾아서&gt; 영화에서 조니 뎁이 이런 말을 했다고 한다. 위대한 생각을 담으려면 최고급 노트가 필요한 법이지!","categories":[],"tags":[{"name":"메모","slug":"메모","permalink":"http://jacegem.github.io/blog/tags/메모/"},{"name":"노트","slug":"노트","permalink":"http://jacegem.github.io/blog/tags/노트/"},{"name":"사용법","slug":"사용법","permalink":"http://jacegem.github.io/blog/tags/사용법/"},{"name":"마크다운","slug":"마크다운","permalink":"http://jacegem.github.io/blog/tags/마크다운/"},{"name":"예약","slug":"예약","permalink":"http://jacegem.github.io/blog/tags/예약/"},{"name":"주제","slug":"주제","permalink":"http://jacegem.github.io/blog/tags/주제/"}]},{"title":"[autohotkey] PPT 작성을 위한 AutoHotkey 스크립트","slug":"2016/autohotkey-PPT-작성을-위한-AutoHotkey-스크립트","date":"2016-01-24T11:44:02.000Z","updated":"2018-01-05T06:32:38.623Z","comments":true,"path":"2016/autohotkey-PPT-작성을-위한-AutoHotkey-스크립트/","link":"","permalink":"http://jacegem.github.io/blog/2016/autohotkey-PPT-작성을-위한-AutoHotkey-스크립트/","excerpt":"","text":"WASD 키를 방향키로 변경하기스크립트를 실행하면, fnOn의 값은 false이기때문에 정상적으로 키입력이 됩니다. 왼손으로 방향키 입력이 필요한 경우에 Capslock + TAB 키를 눌러서 fnOn의 값을 true변경합니다. 이때부터 WASD는 방향키로 동작하게 됩니다. 전체소스는 아래와 같습니다. 12345678fnOn == false~Capslock &amp; TAB::fnOn:=!fnOn#If fnOn a::Send &#123;Left&#125; s::Send &#123;Down&#125; d::Send &#123;Right&#125; w::Send &#123;Up&#125;#If 다른 키들도 변경하기wasd 가 변경되어서 이미 일반 키보드로써의 기능은 잃어버렸습니다. 다른 키들도 변경되도록 하겠습니다. 동일한 형식으로 작성하여 원하는 키로 변경하면 됩니다. 텐키리스 키보드를 사용중일 때 유용할 수 있도록, 상태변경으로 키패드 입력이 되도록 하겠습니다. 12345678 m::Send 0 j::Send 1 k::Send 2 l::Send 3 u::Send 4 i::Send 5 o::Send 6```language mjkluio 의 키 입력을 각각 0123456으로 변경합니다. 789은 원래의 숫자키를 사용하므로 변경하지 않습니다. PPT 작성중에 복사하기 &amp; 붙여넣기 신공도 많이 사용하게 됩니다. 이것도 추가합니다. 1234c::Send ^cv::Send ^vx::Send ^xz::Send ^z 펑션키도 활용합니다. PPT에서 페이지 단위로 이동할 경우를 고려한 키입력을 추가합니다. 1234F1::Send &#123;Left&#125;F2::Send &#123;WheelUp 2&#125;F3::Send &#123;WheelDown 2&#125;F4::Send &#123;Right&#125; 이렇게 사용하면 장담할수 없지만 작업효율이 0.000001% 정도 올라갈 것으로 예측되옵니다. 전체소스는 아래와 같습니다. 123456789101112131415161718192021222324252627282930313233fnOn == false~Capslock &amp; TAB::fnOn:=!fnOn#If fnOn ;;; function keys F1::Send &#123;Left&#125; F2::Send &#123;WheelUp 2&#125; F3::Send &#123;WheelDown 2&#125; F4::Send &#123;Right&#125; ;;; numbers m::Send 0 j::Send 1 k::Send 2 l::Send 3 u::Send 4 i::Send 5 o::Send 6 ;;; cursor keys a::Send &#123;Left&#125; s::Send &#123;Down&#125; d::Send &#123;Right&#125; w::Send &#123;Up&#125; q::Send &#123;BS&#125; ;e::Send &#123;Delete&#125; e::Send &#123;Enter&#125; r::Send &#123;Enter&#125; c::Send ^c v::Send ^v x::Send ^x z::Send ^z#If 에피소드#If를 몰랐을때에는 if 로 모든것을 비교했었습니다. 1234567$w::if (fnOn = true) &#123; Send &#123;Blind&#125;&#123;up&#125;&#125; else &#123; Send &#123;Blind&#125;w&#125; return 이렇게요. 하나씩 키 입력을 지정 하려 하다 보니, 중복되는 코드가 너무 많아서 관리가 안되었습니다. 예전소스가 해당 파일에 주석으로 남아있어서 올렸습니다. 결론은….. #If를 사용합니다.","categories":[],"tags":[{"name":"ahk","slug":"ahk","permalink":"http://jacegem.github.io/blog/tags/ahk/"},{"name":"autohotkey","slug":"autohotkey","permalink":"http://jacegem.github.io/blog/tags/autohotkey/"},{"name":"ppt","slug":"ppt","permalink":"http://jacegem.github.io/blog/tags/ppt/"},{"name":"script","slug":"script","permalink":"http://jacegem.github.io/blog/tags/script/"}]},{"title":"[jquery] jquery를 사용한 input, select 읽기전용으로 변경","slug":"2016/jquery를-사용한-input-select-읽기전용으로-변경","date":"2016-01-24T11:39:06.000Z","updated":"2018-01-05T06:33:21.377Z","comments":true,"path":"2016/jquery를-사용한-input-select-읽기전용으로-변경/","link":"","permalink":"http://jacegem.github.io/blog/2016/jquery를-사용한-input-select-읽기전용으로-변경/","excerpt":"","text":"jquery를 사용한 input 읽기전용 속성 변경input 태그에 readonly 속성을 추가하여 읽기 전용으로 변경합니다. 123$(function()&#123; $('input').prop('readonly', true); // 모든 input 태그를 readonly로 변경함.&#125;); 페이지 onload 이벤트시에 모든 input태그를 읽기전용으로 변경합니다. jquery를 사용한 option 비활성화select에는 readonly가 없으므로 option에 diabled를 설정해야 합니다. 각 option에 disabled를 설정하여 변경이 안되도록 할 수 있습니다. 123$(function()&#123; $('option').attr('disabled', true); // option 태그를 모두 disabled 로 변경함.&#125;); 페이지 onload 이벤트시에 모든 option태그를 비활성화 시킵니다. 참고 http://stackoverflow.com/questions/4610652/jquery-select-option-disabled-if-selected-in-other-select","categories":[],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://jacegem.github.io/blog/tags/jquery/"},{"name":"input","slug":"input","permalink":"http://jacegem.github.io/blog/tags/input/"},{"name":"select","slug":"select","permalink":"http://jacegem.github.io/blog/tags/select/"},{"name":"selector","slug":"selector","permalink":"http://jacegem.github.io/blog/tags/selector/"}]},{"title":"[toad] Script 정보에서 커멘트 정보 얻는 정규표현식","slug":"2016/toad-Script-정보에서-커멘트-정보-얻는-정규표현식","date":"2016-01-24T11:31:04.000Z","updated":"2018-01-05T06:33:30.511Z","comments":true,"path":"2016/toad-Script-정보에서-커멘트-정보-얻는-정규표현식/","link":"","permalink":"http://jacegem.github.io/blog/2016/toad-Script-정보에서-커멘트-정보-얻는-정규표현식/","excerpt":"","text":"Comment from TOAD script... COMMENT ON TABLE SCHEMA.TABLE IS &apos;테이블명&apos;; COMMENT ON COLUMN SCHEMA.TABLE.COL_YYMM IS &apos;컬럼년월&apos;; COMMENT ON COLUMN SCHEMA.TABLE.COL_NO IS &apos;컬럼번호&apos;; COMMENT ON COLUMN SCHEMA.TABLE.COL_CODE IS &apos;컬럼코드&apos;; ... toad 에서 테이블 script 정보를 확인하면 위와 같은 형식으로 되어 있는 스크립트를 확인할 수 있습니다. ERD 확인이 어려운 경우에 스크립트에 있는 Comment정보로 한글명을 확인합니다. Regular expression엑셀에 넣기 위해 각 항목을 탭으로 구분되도록 변경합니다. 1COMMENT ON (TABLE|COLUMN) \\w+?\\.(\\w+)\\.?(\\w+)? IS &apos;(\\w+)&apos;;\\s* 모두 시작은 COMMENT ON으로 시작하므로 문자열 그대로 사용합니다. COMMENT ON 그 다음 TABLE 또는 COLUMN 문자열이 올수 있으므로 그룹으로 지정합니다. (TABLE|COLUMN) 그 다음 첫번째 점(.) 이전에는 스키마정보가 있습니다만 필요 없으므로 이부분은 그룹핑에서 제외합니다. \\w+?\\. 그 다음 테이블명이 옵니다. 그룹핑을 합니다. 그 뒤에 테이블인 경우에는 아무것도 없지만 컬럼명인 경우에는 점(.)이 따라옵니다. (\\w+)\\.? 그 다음 컬럼명이 옵니다. 그룹핑을 하지만 테이블인 경우에는 해당 내용이 없으므로 ?를 사용합니다. (\\w+)? 그 다음 IS 문자열이 옵니다. 그대로 적습니다. IS 그 다음 한글로 된 커멘트가 옵니다. 커멘트는 작은따옴표로 감싸여 있습니다. &#39;(\\w+)&#39; 그 다음 세미콜론(;)이 오고 줄바꿈기호가 있습니다. ;\\s* 그룹핑한 정보들만으로 치환하여 원하는 값을 추출합니다. 1$1\\t$2\\t$3\\t$4\\n 그룹핑된 정보들을 탭 구분으로 변경합니다. 맨 마지막에는 줄바꿈을 포함합니다. $1에는 TABLE 또는 COLUMN 문자열이 매칭되어 있습니다.$2에는 테이블명이 매칭되어 있습니다.$3에는 컬럼명이 매칭되어 있습니다. 테이블 커멘트에서는 아무것도 매칭되어 있지 않습니다.$4에는 한글설명이 매칭되어 있습니다. Notepad++ 를 이용한 치환 [notepad++]에서 치환한 모습입니다. 12찾을내용: COMMENT ON (TABLE|COLUMN) \\w+?\\.(\\w+)\\.?(\\w+)? IS &apos;(\\w+)&apos;;\\s*바꿀내용: $1\\t$2\\t$3\\t$4\\n","categories":[],"tags":[{"name":"script","slug":"script","permalink":"http://jacegem.github.io/blog/tags/script/"},{"name":"toad","slug":"toad","permalink":"http://jacegem.github.io/blog/tags/toad/"},{"name":"regex","slug":"regex","permalink":"http://jacegem.github.io/blog/tags/regex/"},{"name":"comment","slug":"comment","permalink":"http://jacegem.github.io/blog/tags/comment/"}]},{"title":"[jstl] callback 함수명 전달하기","slug":"2016/jstl-callback-함수명-전달하기","date":"2016-01-24T11:26:07.000Z","updated":"2018-01-05T06:33:27.385Z","comments":true,"path":"2016/jstl-callback-함수명-전달하기/","link":"","permalink":"http://jacegem.github.io/blog/2016/jstl-callback-함수명-전달하기/","excerpt":"","text":"JSTL을 사용하여 child window에서 부모창 함수를 호출합니다. 팝업창 생성시에 부모창의 함수명을 서버로 전달하고, 해당 함수명을 받아서 호출할 수 있도록 합니다. JSTL : JavaServer Pages Standard Tag Library 파라미터로 전달한 함수명을 이용하여 함수를 호출합니다. 1234&lt;%@ page import=\"org.apache.commons.lang3.StringUtils\"%&gt;function callback() &#123; parent.&lt;%=!StringUtils.defaultString(request.getParameter(\"callback\")).equals(\"\") ? request.getParameter(\"callback\") : \"defaultCallback\"%&gt;();&#125; !(not) 을 제거하고 삼항연산자의 순서를 변경합니다. 1parent.&lt;%=StringUtils.defaultString(request.getParameter(\"callback\")).equals(\"\") ? \"defaultCallback\" : request.getParameter(\"callback\") %&gt;(); 다른 방법으로는 서버로 전달하지 않고, 부모창에서 바로 자식창에 호출받을 callback 함수를 지정할 수도 있습니다. 또는 eval() 함수를 이용하여 서버로 전달된 함수명을 통해서 호출할 수도 있습니다.","categories":[],"tags":[{"name":"jstl","slug":"jstl","permalink":"http://jacegem.github.io/blog/tags/jstl/"},{"name":"callback","slug":"callback","permalink":"http://jacegem.github.io/blog/tags/callback/"},{"name":"function","slug":"function","permalink":"http://jacegem.github.io/blog/tags/function/"}]},{"title":"[IFTTT] IF THIS THEN THAT","slug":"2016/android-IF-THIS-THEN-THAT-IFTTT","date":"2016-01-22T12:53:48.000Z","updated":"2018-01-05T06:32:51.275Z","comments":true,"path":"2016/android-IF-THIS-THEN-THAT-IFTTT/","link":"","permalink":"http://jacegem.github.io/blog/2016/android-IF-THIS-THEN-THAT-IFTTT/","excerpt":"","text":"15 Best New Writing Apps You’ve Never Heard of를 통해서 IFTTT를 알게되었습니다. Tasker와 비슷하지만 다양한 서비스와 쉽게 연동할 수 있는 장점이 있습니다. 지정한 이벤트가 발생하면 정해진 동작이 실행되도록 설정할 수 있는 서비스입니다. Recipes다양한 Recipes 조리법들이 제공되고 있습니다.로그인하여 접속하면 3가지의 텝 메뉴를 볼 수 있습니다. Remmemded 탭에서 이용자들이 많이 사용하고 있는 Recipes를 확인할 수 있습니다. 추천 항목은 접속할 때마다 변경됩니다. 천천히 어떤 조리법들이 있는지 확인해 보고 필요한 조리법을 사용하면 됩니다. Recipes는 두가지로 분류됩니다. Do Recipes와 IF Recipes 입니다. DO RecipesDo Recipes는 사용자가 어플에 설치한 버튼을 클릭하면 발생하는 것입니다. 다양한 서비스들이 제공되고 있습니다. Do Camera, Do Note, Do Button 이렇게 3가지로 분류가 있습니다. Do Camera는 카메라로 사진을 촬영했을때에, Do Note 는 새로운 문서(글)을 작성 했을때에, Do Button은 버튼을 터치 했을때에, 실행될 동작을 지정하는 서비스입니다. 각 Do Recipes 에서 사용중인 것을 하나씩만 설명하면 아래와 같습니다. Do Camera 에 Email yourself this photo 를 추가했습니다. 사진을 찍으면 그 사진이 이메일로 전송되도록 해줍니다. 사진 백업용으로 사용할 수 있습니다. DO Note 에 Save notes on the fly 를 추가했습니다. Do Note를 실행하고, 입력하고 싶은 내용을 적은 다음에 하단에 있는 버튼을 클릭하면 바로 에버노트에 새로운 문서로 추가되는 서비스 입니다. Do Button에 Track your journey를 추가했습니다. Do Button을 터치하면 나의 위치정보와 시간정보, 지도이미지가 구글 스프레드시트에 한 줄씩 저장 되는 서비스입니다. IF RecipesIf Recipes는 미리 조건을 설정해 놓고, 해당 조건에 맞으면 실행이 되는 서비스입니다. 사용중인 IF Recipes 입니다. Save new texts you receive in a Google Spreadsheet 새로운 문자가 오면 구글 드라이브의 스프레드 시트에 한줄씩 기록하는 서비스입니다. 휴대전화와 별로도 내 문자를 보관할 수 있도록 도와줍니다. Create - 나만의 조리법 생성 먼저 this 를 설정합니다. 발생 조건을 설정하는 부분입니다. 발생 조건으로 새로운 문자 메시지를 받는 경우로 설정하였습니다. 그리고 해당 조건이 발생하면 실행될 동작을 설정합니다. 새로운 문자 메시지를 받으면 구글 캘린더에 추가하도록 설정한 모습입니다. Twitter, Facebook, instagram 등 설정할 수 있는 다양한 서비스 연동을 제공하고 있으므로, 필요에 따라 알맞은 조리법을 만들면 됩니다. AndroidDO Recipes는 어플이 있어야 사용할 수 있습니다. ITFFF 에서 제공하는 Android 어플은 아래와 같습니다. IF는 IF Recipes를 설정하거나 변경할 수 있는 어플입니다. Do Button,Do Note,Do Camera는 각각 Do Recipes를 실행할 수 있는 어플입니다.","categories":[],"tags":[{"name":"do","slug":"do","permalink":"http://jacegem.github.io/blog/tags/do/"},{"name":"ifttt","slug":"ifttt","permalink":"http://jacegem.github.io/blog/tags/ifttt/"},{"name":"sms","slug":"sms","permalink":"http://jacegem.github.io/blog/tags/sms/"},{"name":"google","slug":"google","permalink":"http://jacegem.github.io/blog/tags/google/"},{"name":"drive","slug":"drive","permalink":"http://jacegem.github.io/blog/tags/drive/"},{"name":"spreadsheet","slug":"spreadsheet","permalink":"http://jacegem.github.io/blog/tags/spreadsheet/"}]},{"title":"[하스스톤] 선술집 - 블랙하트 선장의 보물 상자","slug":"2016/하스스톤-선술집-블랙하트-선장의-보물-상자","date":"2016-01-21T12:34:55.000Z","updated":"2018-01-05T06:31:25.702Z","comments":true,"path":"2016/하스스톤-선술집-블랙하트-선장의-보물-상자/","link":"","permalink":"http://jacegem.github.io/blog/2016/하스스톤-선술집-블랙하트-선장의-보물-상자/","excerpt":"","text":"이번 선술집은 블랙하트 선장의 보물 상자입니다. 선장의 보물 상자는 누구에게나 열려 있습니다. 결국엔 당신이 갖겠지만요! 내 턴마다 보물 상자 안에 들어있는 무작위로 선택된 3장의 카드 중 하나를 골래 내 손으로 가져올 수 있습니다! 매 턴마다 3개의 카드가 주어지고 이 중에 하나를 선택하면 내 손 패에 추가됩니다. 게임을 시작하면 30장의 카드는 모두 해적으로 구성되어 있습니다. 혹시나 다른 카드가 있을까 하는 생각에 모두 바꾸어 보았지만, 반전은 없었습니다. 이번 선술집 전략높은 등급의 카드를 선택합니다.카드의 등급은, 전설 등급, 영웅 등급, 희귀 등급, 일반 등급으로 나누어 집니다. 생매장은 일반카드, 시린빛 점쟁이는 희귀카드, 고위 성전사는 영웅카드이므로, 이번 선택에서는 고위 성전사를 고릅니다. 자주(?) 전설카드가 등장합니다. 이때는 전설 카드를 선택하는 것이 일반적으로는 유리합니다. 사용할 수 있는 마나수정이 3개였지만, 전설카드를 선택하였습니다. 이번에도 선택이 너무 쉬웠습니다. 바로 리로이 젠킨스를 선택하고 진행하였습니다. 마나수정의 수를 고려하여 이번턴에 사용할 수 있는 카드를 고릅니다.마나 수정이 2개인 턴일 경우에는 2마나 카드를 선택하는 것입니다. 이런 경우에 2마나 카드를 선택합니다. 3장의 카드가 모두 저코스트 라서 고민할 것이 별로 없었지만, 이 경우에는 기계 카드가 나올 확률이 적기 때문에 광기의 연금술사를 선택합니다. 마나가 많은 경우에는 높은 코스트를 가지고 있는 카드를 선택합니다. 이럴 때에는 7코스트 카드를 선택하는 것이 유리합니다. 선택한 영웅과 호흡이 잘 맞는 카드를 선택합니다.이번 게임에서는 사제를 영웅으로 선택하여 진행하였습니다. 호흡이 잘 맞는 카드는 직업카드 입니다. 해당 영웅만이 사용할 수 있는 카드를 의미합니다. 세 카드가 모두 희귀 등급카드 였지만, 고민할 필요도 없이 바로 아키나이 영혼사제를 선택하면 됩니다. 사제와 호흡이 가장 잘 맞는 카드입니다. 빛샘까지 들어왔습니다. 체력걱정은 잠시 잊어도 될 것 같습니다. 후기드디어 9마나가 되었고, 페일트리스를 사용하였습니다. 격려를 통해 전설을 소환합니다. 브란 브론즈비어드가 있을때에, 리로이 젠킨스를 던졌습니다. 전설의 역효과 입니다. 연금술사로 공격력과 생명력을 바꾸었지만, 이 역시 브란 브론즈비어가 있어서, 2번 발동되어, 원래의 상태가 되었습니다. 이렇게 필드를 잡아가고 있었는데, 일렉스트라자가 등장합니다. 그렇게 바로 15피가 되어버렸습니다. ㅠㅠ 혼란으로 어찌어찌 괴물녀석을 때려잡고 살아가지만, 반피가 된 채로 근근히 살아가던중에 구세주를 만납니다. 흐흐흐, 끝이다! 참고 https://namu.wiki/w/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4%3A%20%EC%9B%8C%ED%81%AC%EB%9E%98%ED%94%84%ED%8A%B8%EC%9D%98%20%EC%98%81%EC%9B%85%EB%93%A4/%EC%B9%B4%EB%93%9C%EC%9D%BC%EB%9E%8C/%EC%A0%84%EC%84%A4%20%EB%93%B1%EA%B8%89","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/하스스톤/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/선술집/"}]},{"title":"[영상] 영상을 제작할 때의 참고 사항","slug":"2016/영상-영상을-제작할-때의-참고-사항","date":"2016-01-14T11:31:55.000Z","updated":"2018-01-05T06:31:14.490Z","comments":true,"path":"2016/영상-영상을-제작할-때의-참고-사항/","link":"","permalink":"http://jacegem.github.io/blog/2016/영상-영상을-제작할-때의-참고-사항/","excerpt":"","text":"영상을 제작할 때의 참고 사항 사진의 기본 원칙인 수평선과 수직선을 맞추고 여백을 잘 정리해야 한다. 흔들림이 없는 안정된 영상을 제작한다. 시청자들이 편안하게 볼 수 있는 높이에서 촬영한다. - eye level, High Angle, Low Angle 동일한 크기의 Shot, 동일한 움직임(pan-pan, zoom-in, zoom-out)을 피한다. - Panning의 방향은 왼쪽에서 오른쪽으로 Long Shot은 길게, Close-up은 짧게 촬영해 시청자들이 인지할 시간적 여유를 준다. 방향성과 화면 연결을 고려한다. 장면을 분할해서 촬영한다. 스플릿 편집을 고려한다. 시간을 조절할 영상을 촬영한다. 상징적 표현 기법을 활용한다. - 다양한 각도의 앵글, 클로즈업 프레임 인-아웃, 분리 컷인 리액션 컷, 인서트 컷 창조성이 원칙보다 우선이다. - 원칙을 파기하라. 마음과 몸을 편하게 가진다. 취재하는 내용을 미리 파악하기 위해 평소에 많이 준비한다. - 노오오오력 피사계 심도를 잘 이용한다. - ND Filter, Shutter Speed 자연스러운 화면을 만드려면 마이크를 감춘다. - 모르게 하라. 하던 일을 하면서 대화하면 자연스러운 인터뷰를 할 수 있다. - 배려 카메라 위치를 인터뷰할 사람과 멀리한다. - 숨겨라 인터뷰 할 때 배경을 단순화한다. - 강조 자연광을 살리고 가급적 조명을 사용하지 않으면서 그곳의 조명을 이용한다. - 간접 조명 동적인 대상을 Close-up으로 촬영하려면 피사체에서 멀리 떨어져서 촬영한다. - 동적인 영상을 크게 찍고 싶을수록 뒤에서 걸어오는 사람을 촬영할 때는 오는 사람의 오른쪽에서 촬영한다. 역광과 심도를 잘 조절한다. 수직선이 많은 곳에서는 Low Angle을 사용한다. - Low Angle 그림이 되지 않는 아이템일수록 잘 생각하면서 촬영한다. 평소에 볼 수 있는 시각 앵글에서 뉴스를 촬영한다. 카메라 Gain을 올리면 화면이 거칠어 사용할 수 없다는 생각에서 탈피해야 한다. 장비 작동 방법을 연습한다. 장비에 항상 테이프(기록 매체)와 배터리를 넣고 다녀야 한다 - 촬영기자의 경우 사건 사고 대비 항상 가상으로 촬영 콘티를 짜는 연습을 한다. - 습관 참고 책. 베가스 프로 9","categories":[],"tags":[{"name":"영상","slug":"영상","permalink":"http://jacegem.github.io/blog/tags/영상/"},{"name":"촬영","slug":"촬영","permalink":"http://jacegem.github.io/blog/tags/촬영/"},{"name":"참고","slug":"참고","permalink":"http://jacegem.github.io/blog/tags/참고/"},{"name":"베가스","slug":"베가스","permalink":"http://jacegem.github.io/blog/tags/베가스/"},{"name":"vegas","slug":"vegas","permalink":"http://jacegem.github.io/blog/tags/vegas/"}]},{"title":"[excel] 문자열 나누기 - 데이터 타입과 길이 분할","slug":"2016/excel-문자열-나누기-데이터-타입과-길이-분할","date":"2016-01-12T07:13:06.000Z","updated":"2018-01-05T06:31:21.466Z","comments":true,"path":"2016/excel-문자열-나누기-데이터-타입과-길이-분할/","link":"","permalink":"http://jacegem.github.io/blog/2016/excel-문자열-나누기-데이터-타입과-길이-분할/","excerpt":"","text":"[excel] 문자열 나누기 - 데이터 타입과 길이 분할 VARCHAR2(80)과 같은 데이터 값을 분할하여 VARCHAR2, 80으로 만들기 위한 함수를 생성합니다. 처음 조건으로 ‘(‘ 를 포함하고 있는가를 확인합니다. FIND 함수를 사용합니다. NUMBER와 같이 길이 정보가 없는 경우가 있기에 이를 구별할 필요가 있습니다. =FIND(&quot;(&quot;,E2) 해당 문자를 포함하고 있으면 인덱스를 반환하지만 없으면 #VALUE! 에러를 반환하게 됩니다. 에러를 처리하기 위해 ISNUMBER 함수를 사용하여 감싸줍니다. =ISNUMBER(FIND(&quot;(&quot;,E2)) ‘(‘ 를 포함하고 있는 문자열인 경우에는 true, 아니면 false 를 반환합니다. 이 함수를 IF 함수로 감싸서, ‘(‘ 문자를 포함하고 있는 경우와 아닌 경우를 나눠서 처리합니다. =IF(ISNUMBER(FIND(&quot;(&quot;,E2)), &quot;포함하는 경우&quot;, &quot;없는 경우&quot;) 각각 “포함하는 경우”, “없는 경우”를 구분하여 함수를 생성합니다.포함하는 경우에는 ‘(‘ 문자 이전까지의 문자를 반환하도록 합니다. VARCHAR2(80) 의 경우 VARCHAR2 가 반환되도록 하는 것이 목적입니다. =LEFT(E2, FIND(&quot;(&quot;,E2) -1) 포함하지 않는 경우에는 그 자체로 반환하면 됩니다. =E2 두 가지 경우에 대한 내용을 모두 IF 함수 안에 포함합니다. =IF(ISNUMBER(FIND(&quot;(&quot;,E2)), LEFT(E2, FIND(&quot;(&quot;,E2) -1), E2 ) 이 함수를 사용하여 타입 정보를 추출합니다. 뒤에 있는 길이 정보도 동일한 방식으로 추출합니다. 길이 정보는 뒤에 있는 ‘)’ 문자 이전까지의 정보를 추출하기 때문에 MID 함수를 사용하여 추출합니다. 길이 정보가 없는 경우에는 빈문자열을 반환하도록 처리합니다. =IF(ISNUMBER(FIND(&quot;(&quot;,E2)), MID(E2, FIND(&quot;(&quot;,E2)+1, LEN(E2)-FIND(&quot;(&quot;,E2)-1 ), &quot;&quot; ) 참고 http://www.tuning-java.com/267 http://seongsland.tistory.com/136 http://mainia.tistory.com/498","categories":[],"tags":[{"name":"excel","slug":"excel","permalink":"http://jacegem.github.io/blog/tags/excel/"},{"name":"substring","slug":"substring","permalink":"http://jacegem.github.io/blog/tags/substring/"},{"name":"type","slug":"type","permalink":"http://jacegem.github.io/blog/tags/type/"},{"name":"length","slug":"length","permalink":"http://jacegem.github.io/blog/tags/length/"},{"name":"엑셀","slug":"엑셀","permalink":"http://jacegem.github.io/blog/tags/엑셀/"},{"name":"문자열","slug":"문자열","permalink":"http://jacegem.github.io/blog/tags/문자열/"},{"name":"분할","slug":"분할","permalink":"http://jacegem.github.io/blog/tags/분할/"}]},{"title":"[c#] 대용량 숫자 값들 중에서 중복 확인","slug":"2016/c-대용량-숫자-값들-중에서-중복-확인","date":"2016-01-12T06:56:06.000Z","updated":"2018-01-05T06:31:17.673Z","comments":true,"path":"2016/c-대용량-숫자-값들-중에서-중복-확인/","link":"","permalink":"http://jacegem.github.io/blog/2016/c-대용량-숫자-값들-중에서-중복-확인/","excerpt":"","text":"[c#] 대용량 숫자 값들 중에서 중복 확인 총 숫자 카운트 확인 배열 생성 배열에 할당 Array.Sort 이전값과 비교 위와 같은 순서로 진행합니다. 총 숫자 카운트를 확인합니다. 파일에 저장된 데이터를 읽습니다. 한줄에 하나씩의 데이터를 읽어오기 때문에, 줄 수를 카운트 합니다. 12345678string path = @\"c:\\test\\code\\\"; string[] filePaths = Directory.GetFiles(path);int lineCnt = 0;foreach (string file in filePaths)&#123; string[] lines = System.IO.File.ReadAllLines(file); lineCnt += lines.Length;&#125; 카운트 크기의 배열을 생성합니다. 1long[] codes = new long[lineCnt]; 다시 파일을 읽으면서 원하는 정보를 추출하여 할당합니다.1234567891011int rowIdx = 0;long val = 0;long[] codes = new long[lineCnt];foreach (string file in filePaths) &#123; string[] lines = System.IO.File.ReadAllLines(file); foreach (string line in lines) &#123; string[] infos = line.Split('\\t'); string firstVal = infos[0]; codes[rowIdx++] = long.Parse(code); &#125;&#125; 값을 할당한 배열을 정렬합니다. 1Array.Sort(codes); 정렬된 배열에서 중복값을 확인합니다. 이전값과 같은지 비교합니다. 1234567891011long last = -1;for (int i = 0; i &lt; rowIdx; i++) &#123; cd = codes[i]; if (last == cd) &#123; Console.WriteLine(\"중복:\"+cd); Console.ReadLine(); &#125; else &#123; last = cd; &#125;&#125; 참고 Sorting Arrays [C#] c# Stopwatch 사용 ( 시간체크, 동작시간 )","categories":[],"tags":[{"name":"c#","slug":"c","permalink":"http://jacegem.github.io/blog/tags/c/"},{"name":"array","slug":"array","permalink":"http://jacegem.github.io/blog/tags/array/"},{"name":"duplcate","slug":"duplcate","permalink":"http://jacegem.github.io/blog/tags/duplcate/"},{"name":"중복","slug":"중복","permalink":"http://jacegem.github.io/blog/tags/중복/"}]},{"title":"블루투스 이어폰 알아보기","slug":"2016/블루투스 이어폰","date":"2016-01-10T11:31:55.000Z","updated":"2018-01-05T10:25:53.266Z","comments":true,"path":"2016/블루투스 이어폰/","link":"","permalink":"http://jacegem.github.io/blog/2016/블루투스 이어폰/","excerpt":"","text":"HBS-810과 비교하여 HBS-900, HB-850은 무게가 더 무거우며 HBS-810보다 이전 출시 모델이므로 비교에서 제외하였습니다. HBS의 경우 LG 제품이고 마지막에 있는 SBH모델을 SONY 제품입니다. 제품 HBS-500 HBS-760 HBS-810 SBH80 무게(g) 29 34.2 41 15.8 불루투스버전(ver) 4.1 4.1 4.1 3.0 줄감기 no no yes no 연속통화시간(h) 9 16 17 9 연속음악재생(h) 7.5 10.5 13 6 대기시간(h) 500 540 550 430 무게만 생각한다면 SBH80이 유리하다. 배터리 시간까지 생각한다면 결과는 달라진다.HBS-810과 같이 줄감기 기능이 있으면, 선이 얇아지고, 뺏을때에 꼬임현상이 발생한다고 한다. HBS-760을 가격을 확인하다 보면 놀라운 점을 발견할 수 있다.색상 마다 가격이 다르다. 샤오미캠의 경우에 녹색이 비싸다는 것은 경험했지만, HBS-760처럼 색상마다 가격이 다르다는 것에 놀라움을 다시 경험했다. 한 오픈마켓의 가격을 보면 아래와 같다. 보라색이 가장 싸다. 검은색이 가장 비싸다. 색상 선호도를 의미하는 듯 하다. 잘 팔린다고 비싸게 파는 것일까?? 혹시 염료의 원가 차이가 있는것인가?? 기승전흑 보라 &lt; 파랑 = 빨강 &lt; 하양 &lt; 검정 가격검정색을 기준으로 찾아보자. 배송비를 포함한 가격으로 알아본다. 제품 가격 HBS-760 5.7(기본) + 0.4(추가) + 0.25(배송) = 6.35 HBS-810 8.7(기본) + 1.0(추가) + 0.25(배송) = 9.95 2016.02.14 기준 다나와를 경우한 가격입니다. HBS-760 vs HBS-810HBS-760 과 HBS-810. 두 가지 모델의 차이점은 줄감기 기능과 가격이다. 참고 LG TONE+ HBS-810 블루투스 구입 후 사용기 LG 블루투스 이어폰 HBS-810 사용 후기및 비교 LG TONE 시리즈 LG 블루투스이어폰, LG 톤플러스 전체 라인업 살펴보기 블루투스 이어폰 LG HBS 760 vs 810","categories":[{"name":"Shopping","slug":"Shopping","permalink":"http://jacegem.github.io/blog/categories/Shopping/"}],"tags":[{"name":"bluetooth","slug":"bluetooth","permalink":"http://jacegem.github.io/blog/tags/bluetooth/"},{"name":"earset","slug":"earset","permalink":"http://jacegem.github.io/blog/tags/earset/"},{"name":"headset","slug":"headset","permalink":"http://jacegem.github.io/blog/tags/headset/"},{"name":"earphone","slug":"earphone","permalink":"http://jacegem.github.io/blog/tags/earphone/"},{"name":"hbs-810","slug":"hbs-810","permalink":"http://jacegem.github.io/blog/tags/hbs-810/"},{"name":"hbs-760","slug":"hbs-760","permalink":"http://jacegem.github.io/blog/tags/hbs-760/"}]},{"title":"[algospot] MERCY","slug":"2016/Algospot-MERCY","date":"2016-01-10T04:48:56.000Z","updated":"2018-01-05T06:31:10.064Z","comments":true,"path":"2016/Algospot-MERCY/","link":"","permalink":"http://jacegem.github.io/blog/2016/Algospot-MERCY/","excerpt":"","text":"[algospot] 알고스팟 - MERCY scala로 작성해보려 합니다. 먼저 튜토리얼을 확인해 봅니다. 스칼라의 경우에도, main() 함수가 있는 오브젝트의 이름은 항상 Main 이어야 한다. 123456789object Main &#123; def main(args: Array[String]): Unit = &#123; var cases = Integer.parseInt(readLine()) while (cases &gt; 0) &#123; println(\"Hello, \" + readLine() + \"!\") cases -= 1 &#125; &#125;&#125; 위의 예시코드를 확인할 수 있습니다. Scala의 새 버전(2.11.1)에서는 scala.readLine()함수 대신 scala.io.StdIn.readLine()을 사용해야 한다고 합니다. 정수를 입력 받을 때는 scala.io.StdIn.readInt(). 코드를 살피던 중 위와 같은 댓글을 확인할 수 있었습니다. 버전차이로 인한 문제가 발생할 수 있을지도 모른다는 생각이었지만, 일단은 예시코드를 변형하여 답안을 제출하겠습니다. 123456789object Main &#123; def main(args: Array[String]): Unit = &#123; var cases = Integer.parseInt(readLine()) while (cases &gt; 0) &#123; println(\"Hello Algospot!\") cases -= 1 &#125; &#125;&#125; MERCY 문제의 경우 Hello Algospot!를 출력하면 되기 때문에, 예시코드에서 출력부분만 바꾸어서 제출하였습니다. 버전 차이로 인한 오답이 될 줄 알았지만, 무사히 정답으로 처리되었습니다.","categories":[],"tags":[{"name":"algospot","slug":"algospot","permalink":"http://jacegem.github.io/blog/tags/algospot/"},{"name":"mercy","slug":"mercy","permalink":"http://jacegem.github.io/blog/tags/mercy/"},{"name":"algorithm","slug":"algorithm","permalink":"http://jacegem.github.io/blog/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://jacegem.github.io/blog/tags/알고리즘/"},{"name":"알고스팟","slug":"알고스팟","permalink":"http://jacegem.github.io/blog/tags/알고스팟/"}]},{"title":"티스토리 #1 스킨 수정하기","slug":"2016/티스토리-1-스킨-수정하기","date":"2016-01-09T00:37:27.000Z","updated":"2018-01-05T06:31:06.691Z","comments":true,"path":"2016/티스토리-1-스킨-수정하기/","link":"","permalink":"http://jacegem.github.io/blog/2016/티스토리-1-스킨-수정하기/","excerpt":"","text":"티스토리 #1 스킨 수정하기폰트 변경CSS 편집화면으로 이동합니다. 관리 &gt; 꾸미기 &gt; HTML/CSS 편집 &gt; CSS font-family 값을 &#39;나눔고딕&#39;,NanumGothic,&#39;돋움&#39;,Dotum,helvetica,sans-serif,tahoma; 로 수정합니다. 또는 원하는 폰트로 변경하시면 됩니다. font-family:&apos;나눔고딕&apos;,NanumGothic,&apos;돋움&apos;,Dotum,helvetica,sans-serif,tahoma; 상단 프로파일 수정HTML 편집화면으로 이동합니다. 관리 &gt; 꾸미기 &gt; HTML/CSS 편집 &gt; HTML 필명과 타이틀이 표시되는 부분을 수정합니다. 필명 위치에 타이틀이 표시되도록 하기 위하여 코드를 수정합니다. 1&lt;button type=\"button\" class=\"btn_name txt_condition\"&gt;[##_title_##] [##_blogger_##] 대신에 타이틀 표출을 위해 [##_title_##]로 변경합니다. 표출되는 색을 타이틀과 동일하도록 변경하기 위해 class에 txt_condition를 추가합니다. 1&lt;!-- &lt;p class=\"txt_condition\"&gt;[##_title_##]&lt;/p&gt; --&gt; 타이틀이 출력되는 위치 입니다. 보이고 싶지 않은 경우에는 해당 태그를 주석처리 합니다. 카테고리에 리스트 스크롤 추가 .area_menu .list_cat 클래스에 속성 두가지를 추가합니다. ovevflow:auto; height:80vh;","categories":[],"tags":[{"name":"티스토리","slug":"티스토리","permalink":"http://jacegem.github.io/blog/tags/티스토리/"},{"name":"스킨","slug":"스킨","permalink":"http://jacegem.github.io/blog/tags/스킨/"},{"name":"tistory","slug":"tistory","permalink":"http://jacegem.github.io/blog/tags/tistory/"},{"name":"skin","slug":"skin","permalink":"http://jacegem.github.io/blog/tags/skin/"}]},{"title":"하스스톤 선술집 - 외길인생","slug":"2016/하스스톤-선술집-외길인생","date":"2016-01-07T15:02:43.000Z","updated":"2018-01-05T06:31:03.569Z","comments":true,"path":"2016/하스스톤-선술집-외길인생/","link":"","permalink":"http://jacegem.github.io/blog/2016/하스스톤-선술집-외길인생/","excerpt":"","text":"외길인생4가지 중에서 한 가지를 선택합니다. 선택한 한 가지를 따라가는 외길인생입니다. 해당 능력은 게임을 진행하는 동안 계속해서 적용되므로 알맞은 것은 선택해야 합니다. 능력에 맞는 덱 구성이 되어 있어야 합니다. 원하는 게 무엇입니까? 전투의 함성, 죽음의 메아리, 주문, 멀록, 무엇이든 골라보세요! 덱을 만들고, 편을 고르고, 게임을 시작합니다! 죽음의 메아리 보너스 : 죽음의 메아리 능력을 가진 내 하수인들이 +1/+1을 얻습니다. 주문 보너스 : 내가 주문을 시전할 때마다 방어도를 +3 얻습니다. 멀록 보너스 : 내 턴이 끝날 때마다 1/1 멀록을 1마리 소환합니다. 전투의 함성 보너스 : 전투의 함성 능력을 가진 내 하수인들이 +1/+1을 얻습니다. 죽음의 메아리 카드와 전투의 함성 카드는 일반 카드에 많이 있으니, 어떤 영웅으로 선택하여도 구성할 수 있습니다. 주문 보너스는 방어도를 얻기 때문에 전사로 덱을 구성하는 편이 유리합니다. 멀록 보너스는 성기사 또는 주술사로 덱을 구성하는 편이 유리합니다. 스마트폰으로 하스스톤을 즐기는 경우에는 턴 종료를 누른다고 별생각 없이 터치하다가 잘 못 선택하는 경우가 생기니 조심해야 합니다. 이번 선술집 보상 카드입니다. 꽝! 로또나 하러 가자.","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/하스스톤/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/선술집/"},{"name":"hearthstone","slug":"hearthstone","permalink":"http://jacegem.github.io/blog/tags/hearthstone/"},{"name":"drinking","slug":"drinking","permalink":"http://jacegem.github.io/blog/tags/drinking/"},{"name":"game","slug":"game","permalink":"http://jacegem.github.io/blog/tags/game/"}]},{"title":"Unix/Linux Command df & du","slug":"2016/Unix-Linux-Command-df-du","date":"2016-01-07T11:33:54.000Z","updated":"2018-01-05T06:30:57.360Z","comments":true,"path":"2016/Unix-Linux-Command-df-du/","link":"","permalink":"http://jacegem.github.io/blog/2016/Unix-Linux-Command-df-du/","excerpt":"","text":"디스크용량을 확인하기 위해 df, du 명령어를 사용합니다. df Reports information about space on file systems. 파일 시스템 용량에 관한 정보를 제공합니다. 파일시스템, 블록, 사용가능, %사용, Iused, %Iused, 마운트 위치 정보를 제공합니다. 파일 시스템 GB 블록 사용가능 %사용 Iused %Iused 마운트 위치 /dev/hd4 330.00 0.00 100% 184939 93% / /dev/hd2 20.00 17.53 13% 46301 2% /usr /dev/hd9var 5.00 4.90 2% 4581 1% /var 옵션df -m : 메가바이트 단위로 정보를 확인합니다. df -g : 기가바이트 단위로 정보를 확인합니다. du Summarizes disk usage. 디스크 사용량을 요약해서 보여줍니다. 사용량 파일 368 ./log/log.log.2015-02-01.log 296 ./log/log.log.2015-02-02.log 8 ./log/log.log.2015-02-03.log ... 10608 . 옵션du -a : 파일단위로 디스크 사용량을 보여줍니다. du -s : 현재 디렉토리의 총 디스크 사용량을 보여줍니다.","categories":[],"tags":[{"name":"unix","slug":"unix","permalink":"http://jacegem.github.io/blog/tags/unix/"},{"name":"linux","slug":"linux","permalink":"http://jacegem.github.io/blog/tags/linux/"},{"name":"command","slug":"command","permalink":"http://jacegem.github.io/blog/tags/command/"},{"name":"df","slug":"df","permalink":"http://jacegem.github.io/blog/tags/df/"},{"name":"du","slug":"du","permalink":"http://jacegem.github.io/blog/tags/du/"}]},{"title":"Writing Post with Hexo","slug":"2016/Writing-Post-with-Hexo","date":"2016-01-07T05:10:24.000Z","updated":"2018-01-05T06:31:00.474Z","comments":true,"path":"2016/Writing-Post-with-Hexo/","link":"","permalink":"http://jacegem.github.io/blog/2016/Writing-Post-with-Hexo/","excerpt":"","text":"[hexo] Writing Post with Hexo HEXO로 포스팅하기 메모하기ResophNotes를 사용해서 초안을 작성합니다. markdown 문법을 지원하기 때문에 어느 정도는 확인을 할 수 있습니다.(hexo 마크다운 문법과 정확히 일치하지는 않습니다.) 또는 메모장과 같은 다른 텍스트 편집기를 이용해서 작성하면 됩니다. 초안 생성hexo 에서 초안 문서를 생성합니다. hexo new draft “title” 해당 문서 draft.md 에서 지정해 놓은 형식으로 _draft 폴더에 생성됩니다. 새로 생성되는 파일의 레이아웃에 대한 정의는 scaffold폴더에 있습니다. scaffold/draft.mdsource/_draft/title.md 새로 생성된 문서로 텍스트 편집기에서 작성한 내용을 복사합니다. 로컬에서 확인파일을 생성하고 로컬 서버를 실행하여 초안 문서를 확인합니다 hexo generatehexo serve –draft 옵션인 --draft를 꼭 붙여서 실행해야 draft 문서도 확인할 수 있습니다. 브라우저를 통하여 localhost:4000으로 접속합니다. 화면을 살펴보면서 내용을 수정합니다. localhost:4000 root 경로를 /blog로 설정한 경우에는 localhost:4000으로 접속하면 /blog로 접속됩니다. publish명령어를 통하여 발행합니다. hexo publish “title” 발행을 하면 _draft 폴더에 있는 파일은 post 폴더로 이동됩니다. source/_post/title.md 다시 한번 내용을 수정하면서 문법을 확인합니다. 문법 확인으로 한국어 맞춤법/문법 검사기를 사용합니다. deploy배포할 파일을 생성한 다음 배포명령어를 실행하여 포스팅합니다. hexo generatehexo deploy 배포한 이후, 잠깐 시간이 지난 뒤에 수정된 내용이 적용된 것을 확인할 수 있습니다. clean생성한 배포 파일을 삭제할 경우에는 clean 옵션을 사용합니다. hexo clean 단축 명령어hexo new draft “title” hexo n draft “title” hexo generate hexo g hexo serve –draft hexo s –draft hexo publish “title” hexo p “title” hexo deploy hexo d hexo generatehexo deploy hexo d -g","categories":[],"tags":[{"name":"writing","slug":"writing","permalink":"http://jacegem.github.io/blog/tags/writing/"},{"name":"post","slug":"post","permalink":"http://jacegem.github.io/blog/tags/post/"},{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"resophnotes","slug":"resophnotes","permalink":"http://jacegem.github.io/blog/tags/resophnotes/"},{"name":"draft","slug":"draft","permalink":"http://jacegem.github.io/blog/tags/draft/"},{"name":"publish","slug":"publish","permalink":"http://jacegem.github.io/blog/tags/publish/"},{"name":"deploy","slug":"deploy","permalink":"http://jacegem.github.io/blog/tags/deploy/"},{"name":"blog","slug":"blog","permalink":"http://jacegem.github.io/blog/tags/blog/"}]},{"title":"[sw] PowerCmd - A Better Command Prompt Replacement Tool","slug":"2016/sw-PowerCmd-A-Better-Command-Prompt-Replacement-Tool","date":"2016-01-07T01:49:13.000Z","updated":"2018-01-05T06:30:54.188Z","comments":true,"path":"2016/sw-PowerCmd-A-Better-Command-Prompt-Replacement-Tool/","link":"","permalink":"http://jacegem.github.io/blog/2016/sw-PowerCmd-A-Better-Command-Prompt-Replacement-Tool/","excerpt":"","text":"PowerCmd홈페이지 커맨드 창 사용의 불편한 점 중의 하나는 복사하기 붙여넣기가 지원되지 않는다는 것입니다. 익숙한 ctrl+c, ctrl+v 가 아닌, 다른 방식으로 진행하다 보니 자연스레 작업 효율이 떨어질 수 밖에 없습니다. ^V를 그만 보고 싶습니다. 문제점을 해결하기위한 대안으로 PowerCmd를 사용합니다. 탭 구분으로 여러개의 창을 관리할 수 있습니다. 마지막 사용 지점을 기억합니다. 커맨드창을 시작할 때마다 경로를 이동하는 불편을 없앨수 있습니다. ctrl+c, ctrl+v 로 복사하기, 붙여넣기를 할 수 있습니다. PowerCmd 한글화PowerCmd 다운로드","categories":[],"tags":[{"name":"command","slug":"command","permalink":"http://jacegem.github.io/blog/tags/command/"},{"name":"sw","slug":"sw","permalink":"http://jacegem.github.io/blog/tags/sw/"},{"name":"powercmd","slug":"powercmd","permalink":"http://jacegem.github.io/blog/tags/powercmd/"},{"name":"prompt","slug":"prompt","permalink":"http://jacegem.github.io/blog/tags/prompt/"},{"name":"tool","slug":"tool","permalink":"http://jacegem.github.io/blog/tags/tool/"}]},{"title":"[highlight.js] Syntax Highlight - highlight.js","slug":"2016/highlight-js","date":"2016-01-07T01:32:37.000Z","updated":"2018-01-05T06:30:17.865Z","comments":true,"path":"2016/highlight-js/","link":"","permalink":"http://jacegem.github.io/blog/2016/highlight-js/","excerpt":"","text":"Syntax Highlight - highlight.js마크다운 편집기로 문서를 작성하고 html코드를 복사하여 포스팅 하고 있습니다. 블로그에서 소스코드에 대해 syntax highlight를 적용하기 위해 hightlight.js 를 적용하였습니다. 1234567class Hello&#123; public static void main(String args[]) &#123; System.out.println(\"안녕하세요?\"); &#125;&#125; 위의 자바 소스를 생성하면 아래와 같은 html 코드가 생성됩니다. 12345678&lt;pre&gt;&lt;code class=\"java\"&gt;class Hello &#123; public static void main(String args[]) &#123; System.out.println(&amp;quot;안녕하세요?&amp;quot;); &#125;&#125;&lt;/code&gt;&lt;/pre&gt; 이 코드를 가지고 highlight 할 수 있도록 설정합니다. highlight.jshttps://highlightjs.org/ 에 접속합니다. 해당 사이트에 접속한 후에 Get version 버튼을 클릭합니다. 두개의 CDN 주소를 확인할 수 있습니다. 둘 중 하나만 복사해서 적용합니다. cdnjs12&lt;link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/default.min.css\"&gt;&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js\"&gt;&lt;/script&gt; jsdelivr12&lt;link rel=\"stylesheet\" href=\"//cdn.jsdelivr.net/highlight.js/9.0.0/styles/default.min.css\"&gt;&lt;script src=\"//cdn.jsdelivr.net/highlight.js/9.0.0/highlight.min.js\"&gt;&lt;/script&gt; 티스토리 관리에서, 꾸미기 &gt; HTML/CSS 편집 메뉴를 선택합니다. 위에서 복사한 CDN 주소와 함께 &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 코드를 &lt;body&gt; 태그 윗 부분에 추가합니다. 123&lt;link rel=\"stylesheet\" href=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/monokai-sublime.min.css\"&gt;&lt;script src=\"//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js\"&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 위의 코드를 복사해서 붙여 넣습니다. 해당 소스를 붙여넣은 다음에 화면을 캡쳐하였습니다. 사용할 수 있는 스타일은 이곳에서 확인 가능합니다. 좌측 하단에 보이는 Language, style 을 클릭하면 언어및, 스타일이 변경되면서 모습을 확인할 수 있습니다. 각각 스타일 및 언어에 대해서 어떠한 형태로 나오는지는 메인화면에서 확인할 수 있습니다. 또는 데모사이트에서 확인 가능합니다. 141 languages and 65 styles (live demo) automatic language detection multi-language code highlighting available for node.js works with any markup compatible with any js framework 스타일 목록https://github.com/isagalaev/highlight.js/tree/master/src/styles agate.min.css androidstudio.min.css arta.min.css ascetic.min.css atelier-cave-dark.min.css atelier-cave-light.min.css atelier-dune-dark.min.css atelier-dune-light.min.css atelier-estuary-dark.min.css atelier-estuary-light.min.css atelier-forest-dark.min.css atelier-forest-light.min.css atelier-heath-dark.min.css atelier-heath-light.min.css atelier-lakeside-dark.min.css atelier-lakeside-light.min.css atelier-plateau-dark.min.css atelier-plateau-light.min.css atelier-savanna-dark.min.css atelier-savanna-light.min.css atelier-seaside-dark.min.css atelier-seaside-light.min.css atelier-sulphurpool-dark.min.css atelier-sulphurpool-light.min.css brown-paper.min.css brown-papersq.png codepen-embed.min.css color-brewer.min.css dark.min.css darkula.min.css default.min.css docco.min.css far.min.css foundation.min.css github-gist.min.css github.min.css googlecode.min.css grayscale.min.css hopscotch.min.css hybrid.min.css idea.min.css ir-black.min.css kimbie.dark.min.css kimbie.light.min.css magula.min.css mono-blue.min.css monokai-sublime.min.css monokai.min.css obsidian.min.css paraiso-dark.min.css paraiso-light.min.css pojoaque.min.css pojoaque.jpg railscasts.min.css rainbow.min.css school-book.min.css school-book.png solarized-dark.min.css solarized-light.min.css sunburst.min.css tomorrow-night-blue.min.css tomorrow-night-bright.min.css tomorrow-night-eighties.min.css tomorrow-night.min.css tomorrow.min.css vs.min.css xcode.min.css zenburn.min.css CSS classes reference http://highlightjs.readthedocs.org/en/latest/css-classes-reference.html 참고 http://jsonobject.tistory.com/174 http://gseok.tistory.com/entry/TistoryTip-%ED%8B%B0%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%97%90%EC%84%9C-code-highlighter-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0 http://prismjs.com/","categories":[],"tags":[{"name":"highlight","slug":"highlight","permalink":"http://jacegem.github.io/blog/tags/highlight/"},{"name":"syntax","slug":"syntax","permalink":"http://jacegem.github.io/blog/tags/syntax/"},{"name":"js","slug":"js","permalink":"http://jacegem.github.io/blog/tags/js/"}]},{"title":"[oracle] Undo tablespace","slug":"2016/oracle-Undo-tablespace","date":"2016-01-06T21:13:36.000Z","updated":"2018-01-05T06:30:44.526Z","comments":true,"path":"2016/oracle-Undo-tablespace/","link":"","permalink":"http://jacegem.github.io/blog/2016/oracle-Undo-tablespace/","excerpt":"","text":"[오라클] Undo tablespace Undo tablespace는 사용자가 rollback 을 하는 경우에 사용하기 위한 데이터를 저장하는 곳입니다. Undo 파라미터 확인show parameter undo; 새로운 undo tablespace 생성CREATE UNDO TABLESPACE UNDOTBS2 DATAFILE &apos;/home/oradata/undotbs2.dbf&apos; SIZE 10M AUTOEXTEND ON MAXSIZE 100m; 자동 확장 설정 : AUTOEXTEND확장 단위 설정 : ON NEXT 5M무한 확장 설정 : MAXSIZE UNLIMITED AUTOEXTEND ON NEXT 5M MAXSIZE UNLIMITED 생성한 undo tablespace 확인SELECT tablespace_name, contents, extent_management FROM dba_tablespaces WHERE contents = &apos;UNDO&apos;; undo tablespace에 설정된 rollback segment 확인SELECT segment_name, tablespace_name, status FROM dba_rollback_segs ORDER BY 2; undo tablespace 이름 변경ALTER SYSTEM SET UNDO_TABLESPACE = UNDOTBS2; 기존 undo tablespace 삭제DROP TABLESPACE UNDOTBS1; 참고 http://thankyeon.tistory.com/31 https://community.oracle.com/thread/454837?start=0&amp;tstart=0","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jacegem.github.io/blog/tags/oracle/"},{"name":"undo","slug":"undo","permalink":"http://jacegem.github.io/blog/tags/undo/"},{"name":"tablespace","slug":"tablespace","permalink":"http://jacegem.github.io/blog/tags/tablespace/"}]},{"title":"[scala] 섭씨 화씨 변환기","slug":"2016/scala-섭씨-화씨-변환기","date":"2016-01-06T07:07:17.000Z","updated":"2018-01-05T06:30:13.911Z","comments":true,"path":"2016/scala-섭씨-화씨-변환기/","link":"","permalink":"http://jacegem.github.io/blog/2016/scala-섭씨-화씨-변환기/","excerpt":"","text":"섭씨, 화씨 변환 공식은 아래와 같습니다. 섭씨 = (화씨 - 32) * 5 / 9 화씨 = 섭씨 * 9 / 5 + 32 변환을 해보면 아래와 같습니다. 왼쪽에 값을 입력한 후에 변환 버튼을 클릭하면 변환된 값이 오른쪽에 표시됩니다. 섭씨 → 화씨: 화씨 → 섭씨: function trans(){ var c = $('#c').val(); var f = $('#f').val(); var cf = c * 9 / 5 + 32 ; var fc = (f - 32) * 5 / 9; $('#cf').val(cf); $('#fc').val(fc); } scala object 파일을 생성합니다. import 구문을 추가합니다12import swing._import event._ MainFrame 을 생성합니다. 12345object TempConverter extends SimpleSwingApplication&#123; def top = new MainFrame&#123; ... &#125;&#125; 소스12345678910111213141516171819202122232425262728293031package week1import swing._import event._object TempConverter extends SimpleSwingApplication&#123; def top = new MainFrame&#123; title = \"섭씨 / 화씨 변환기\" object celsius extends TextField &#123; columns = 5&#125; object fahrenheit extends TextField &#123; columns = 5&#125; contents = new FlowPanel &#123; contents += celsius contents += new Label (\" Celsius = \") contents += fahrenheit contents += new Label (\" Fahrenheit\") border = Swing.EmptyBorder(15, 10, 10, 10) &#125; listenTo(celsius, fahrenheit) reactions += &#123; case EditDone(`fahrenheit`) =&gt; val f = fahrenheit.text.toInt val c = (f - 32) * 5 / 9 celsius.text = c.toString case EditDone(`celsius`) =&gt; val c = celsius.text.toInt val f = c * 9 / 5 + 32 fahrenheit.text = f.toString &#125; &#125;&#125; gist 실행화면","categories":[],"tags":[{"name":"scala","slug":"scala","permalink":"http://jacegem.github.io/blog/tags/scala/"},{"name":"섭씨","slug":"섭씨","permalink":"http://jacegem.github.io/blog/tags/섭씨/"},{"name":"화씨","slug":"화씨","permalink":"http://jacegem.github.io/blog/tags/화씨/"},{"name":"변환기","slug":"변환기","permalink":"http://jacegem.github.io/blog/tags/변환기/"},{"name":"공식","slug":"공식","permalink":"http://jacegem.github.io/blog/tags/공식/"},{"name":"온도","slug":"온도","permalink":"http://jacegem.github.io/blog/tags/온도/"}]},{"title":"[하스스톤] 선술집 - 이제 누가 우두머리지","slug":"2016/하스스톤-선술집-이제-누가-우두머리지","date":"2016-01-05T12:20:16.000Z","updated":"2018-01-05T06:29:40.717Z","comments":true,"path":"2016/하스스톤-선술집-이제-누가-우두머리지/","link":"","permalink":"http://jacegem.github.io/blog/2016/하스스톤-선술집-이제-누가-우두머리지/","excerpt":"","text":"[하스스톤] 선술집 - 이제 누가 우두머리지? [toc] 영웅의 능력을 사용하면 새로운 능력으로 변경됩니다. 마나만 있다면 계속해서 영웅 능력을 사용할 수 있습니다. 변경되는 영웅능력은 랜덤 이므로 운에 맡겨야 합니다. 이제 누가 우두머리지? 던전의 우두머리들이 당신을 돕겠다는군요! 덱을 만들어 게임을 시작하면 무작위 우두머리의 영웅 능력을 쓸 수 있습니다. 영웅 능력은 사용할 때마다 새로운 영웅 능력으로 바뀝니다. 영웅 능력들척살 적 하수인의 생명력을 1로 바꿉니다. 가장 가끔 나오는 영웅 능력입니다. 독구름과 콤보로 사용할 때 최고의 효율을 얻을 수 있습니다. 문을 열어라 1/1 새끼용 3마리를 소환합니다. 하수인 소환과 관련된 카드를 같이 사용할때에 유용합니다. 단검 곡예사 와 콤비로 사용합니다. 가동 무작위 골렘 하나를 가동시킵니다. 영웅 능력도 랜덤인데, 여기서 한번 더 랜덤의 운에 기대야 합니다. 너 박살낸다! 무작위 하수인 하나를 처치합니다. 상대편 하수인이 없으면 이 능력은 발동될 수 없습니다. 다들 모여!! 각 플레이어의 덱에서 하수인을 한씩 뽑아 전장에 놓습니다. 이 능력이 무조건 내 쪽에 유리하지만은 않습니다. 따라서 상황에 맞게 사용해야 합니다. 덱을 구성할 때에도, 코스트가 높은 하수인을 사용하는 것이 이 영웅 능력의 효과를 극대화 할 수 있는 방법입니다. 덱에 하수인 카드가 없다면, 이 능력을 발동되지 않습니다. 주문카드 보단 하수인 카드 위주의 덱 구성을 추천합니다. 착취 카드를 1장 뽑고, 마나 수정을 1개 획득합니다. 마나수정이 홀수인 경우에 해당 영웅 능력이 나오면 좋습니다. 코스트 낭비를 없애줍니다. 마나 수정을 1개 획득한다고 너무 깊게 생각한 나머지, 주문이나 하수인을 쓰면서 먼저 코스트를 0으로 만드는일은 없어야 합니다. 마나 수정이 모두 사라지면 영웅 능력을 사용할 수 없게 됩니다. 거미줄 감싸기 무작위 적 하수인 하나를 상대편의 손으로 돌려보냅니다. 적편에 높은 코스트 하수인 딱 버티고 있을 때 한줄기 단비같은 영웅능력입니다. 해골 하수인 2/1 해골 피조물을 둘 소환합니다. 문을 열어라와 비슷합니다만, 해골 하수인은 공력력이 2이고, 2개를 소환합니다. 마법 폭주 상대편 직업의 주문 카드 1장을 무작위로 내 손에 가져옵니다. 상대편의 영웅 캐릭터의 주문카드를 가져옵니다. 상대방의 영웅 능력과는 상관이 없습니다. 독구름 모든 적 하수인에게 피해를 1 줍니다. 하나라도 죽으면, 독액괴물을 소환합니다. 척살과 딱 콤비 입니다. 척살로 모든 하수인의 체력을 1 로 만들어 버린 다음에, 적 하수인의 수만큼 독액괴물을 소환할 수 있습니다. 2/2 하수인이라 쓸만합니다. 청지기의 권능 3/3 불꽃꼬리 수행사제를 하나 소환합니다. 3/3 하수인이므로, 덱에 포함되어 있는 2 마나 하수인보다 성능이 좋습니다. 야유하는 군중 도발 능력을 가진 1/1 구경꾼을 1명 소환합니다. 쓸만한 카드들호수의 여인 내 영웅 능력의 비용이 (1)이 됩니다. 이번 선술집에서 필히 들고 가야할 하수인 입니다. 이 하수인이 한턴이라도 살아 남는다면, 전세는 역전하기 힘들어 집니다. 무클라의 용사 격려: 내 다른 하수인들에게 +1/+1 을 부여합니다. 호수의 여인과 최고의 조합입니다. 10마나 턴이라면, 10번의 영웅능력을 사용하고, 모든 하수인에 대해서, 영웅 능력을 사용할 때마다 +1/+1 의 효과를 얻을 수 있습니다. @하스스톤 선술집 - 이제 누가 우두머리지 서리 거인 이번 게임에서 내가 영웅 능력을 사용할 때마다 비용이 (1)씩 감소합니다. 한 턴에도 마나만 충분하다면 여러번의 영웅 능력을 사용할 수 있기 때문에, 서리 거인의 코스트를 빠르게 낮출 수 있습니다. 단검 곡예사 내 하수인이 소한된 후에, 무작위 저거 하나에게 피해를 1 줍니다. 영웅능력 해골 하수인 과 문을 열어라 영웅 능력과 조합으로 사용할 수 있습니다.","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/하스스톤/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/선술집/"},{"name":"우두머리","slug":"우두머리","permalink":"http://jacegem.github.io/blog/tags/우두머리/"},{"name":"영웅","slug":"영웅","permalink":"http://jacegem.github.io/blog/tags/영웅/"},{"name":"능력","slug":"능력","permalink":"http://jacegem.github.io/blog/tags/능력/"}]},{"title":"[scala] Hello World","slug":"2016/scala-hello-world","date":"2016-01-05T12:16:00.000Z","updated":"2018-01-05T06:30:10.410Z","comments":true,"path":"2016/scala-hello-world/","link":"","permalink":"http://jacegem.github.io/blog/2016/scala-hello-world/","excerpt":"","text":"[scala] Hello World IDEhttp://scala-ide.org/ 에서 Scala IDE를 다운로드 하여 실행합니다. HelloWorld12345object HelloWorld &#123; def main(args: Array[String]) &#123; println(\"Hello, world!\") &#125;&#125; 코드를 작성하고 실행합니다. IDE에서 HelloWorld 프로젝트를 생성하고, HelloWorld Object 를 생성합니다. 코드를 작성하고 Scala Application으로 실행하면 결과를 확인할 수 있습니다. Hello, world! HelloWorld 오브젝트를 실행하면, 안에 있는 main 함수가 호출되고, 그 안에서 println문이 실행됩니다. Timer1234567891011object Timer &#123; def oncePerSecond(cb: () =&gt; Unit) &#123; while (true) &#123; cb(); Thread sleep 1000 &#125; &#125; def timeFlies() &#123; println(\"time flies like an arrow...\") &#125; def main(args: Array[String]) &#123; oncePerSecond(timeFlies) &#125;&#125; 코드를 작성하고 실행합니다. 기존 프로젝트에, Timer Object 만 추가하고 작성해도 됩니다. time flies like an arrow... time flies like an arrow... time flies like an arrow... 1초 마다 해당 문구열이 출력되는 것을 확인할 수 있습니다. main 함수에서, timeFiles 함수를 파라미터로 oncePerSecond를 호출합니다. oncePerSecond 함수에서는 파라미터로 전달받은 timeFiles함수를 cb 객체에 담습니다.while문 진입이후에는 cb 함수를 호출하고, 1초간 슬립을 하는 무한 루프를 돌게 됩니다. cb 함수 호출시에, println(&quot;time flies like an arrow...&quot;) 해당 문이 동작하게 되어, 같은 물자열이 계속 출력되게 됩니다. 참고 스칼라 학교 Effective Scala 자바 프로그래머를 위한 스칼라 튜토리얼","categories":[],"tags":[{"name":"hello","slug":"hello","permalink":"http://jacegem.github.io/blog/tags/hello/"},{"name":"scala","slug":"scala","permalink":"http://jacegem.github.io/blog/tags/scala/"},{"name":"world","slug":"world","permalink":"http://jacegem.github.io/blog/tags/world/"}]},{"title":"[hexo] add tags and categories","slug":"2016/hexo-add-tags-and-categories","date":"2016-01-05T11:48:27.000Z","updated":"2018-01-05T06:30:06.933Z","comments":true,"path":"2016/hexo-add-tags-and-categories/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-add-tags-and-categories/","excerpt":"","text":"태그, 카테고리 추가하기 tag 추가hexo new &quot;title&quot; 로 문서를 생성하면 기본 틀이 생성됩니다. tag 입력은 한줄로 입력할 때에는 tags: [tag1, tag2] 이와 같이 입력하며 여러 줄로 입력할 때에는 아래와 같습니다.123tags: - tag1 - tag2 category 추가category는 순서가 중요합니다.123categories: - ca1 - ca2 위와 같이 작성하면 카테고리를 지정한 순서대로 하위 카테고리로 설정이 되기 때문에 아래와 같은 구조로 생성 됩니다. ca1 ca2 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"tag","slug":"tag","permalink":"http://jacegem.github.io/blog/tags/tag/"},{"name":"category","slug":"category","permalink":"http://jacegem.github.io/blog/tags/category/"}]},{"title":"[hexo] add adsense to hexo","slug":"2016/hexo-add-adsense-to-hexo","date":"2016-01-05T04:12:26.000Z","updated":"2018-01-05T06:30:03.312Z","comments":true,"path":"2016/hexo-add-adsense-to-hexo/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-add-adsense-to-hexo/","excerpt":"","text":"[hexo] 애드센스 추가하기 adsense 추가bootstrap 테마를 기준으로 adsense를 추가해보도록 하겠습니다. 상단에 추가하는 방법블로그 레이아웃의 전체적인 구조는 layout.ejs 파일을 통해서 확인할 수 있습니다. layout.ejs파일을 수정하여 상에 애드센스를 추가합니다. theme &gt; bootstrap &gt; layout &gt; layout.ejs 1234567891011&lt;div class=\"row\"&gt; &lt;div class=\"col-sm-8 blog-main\"&gt; &lt;!-- ad start --&gt; &lt;%- partial('_custom_ad/google-adsense') %&gt; &lt;!-- ad end --&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;div class=\"col-sm-3 col-sm-offset-1 blog-sidebar\"&gt; &lt;%- partial('_partial/sidebar', null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;/div&gt;&lt;/div&gt; 중간에 있는 &lt;%- body %&gt; 이 부분이 본문이 표출되는 레이아웃 입니다. 따라서, &lt;%- body %&gt; 윗 부분에 애드센스를 추가합니다. 123&lt;!-- ad start --&gt;&lt;%- partial('_custom_ad/google-adsense') %&gt;&lt;!-- ad end --&gt; 위의 코드를 추가하였습니다. 실질적 동작을 위한 코드가 들어있는 파일을 추가합니다. theme &gt; bootstrap &gt; layout &gt; _custom_ad &gt; google-adsense.ejs 해당 파일에 애드센스에서 제공하는 코드를 입력합니다. 각 계정 및 광고 크기마다 다른 코드가 생성됩니다. 123456789101112&lt;div&gt;&lt;script async src=\"//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"&gt;&lt;/script&gt;&lt;!-- 반응형 --&gt;&lt;ins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"ca-pub-[yours]\" data-ad-slot=\"[yours]\" data-ad-format=\"auto\"&gt;&lt;/ins&gt;&lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push(&#123;&#125;);&lt;/script&gt;&lt;/div&gt; 위의 코드는 반응형으로 생성하였기 때문에, 다른 위치에서도 이 파일을 사용하여 애드센스를 추가합니다. 하단에 추가하는 방법하단도 상단과 마찬가지로 &lt;%- body %&gt; 부분 밑에 코드를 추가함으로써 삽입이 가능합니다. 이 경우에는 댓글 부분 밑에 추가되기 때문에, 이를 변경하기 위해서 삽입 코드의 위치를 변경합니다. 태그 밑 부분에 출력하기 위해서 tag.ejs 파일을 수정합니다. themes &gt; bootstrap &gt; layout &gt; _partial &gt; post &gt; tag.ejs tag.ejs 파일의 맨 밑에 삽입 코드를 추가합니다. 123&lt;!-- ad start --&gt;&lt;%- partial('_custom_ad/google-adsense') %&gt;&lt;!-- ad end --&gt; 사이드에 추가하는 방법사이드에 추가하기 위해서 sidebar.ejs 파일을 수정합니다.sidebar.ejs 파일 맨 맽에 코드를 추가합니다. themes &gt; bootstrap &gt; layout &gt; _partial &gt; sidebar.ejs 123&lt;!-- ad start --&gt;&lt;%- partial('_custom_ad/google-adsense') %&gt;&lt;!-- ad end --&gt; 반응형 광고 크기를 사용하였기 때문에, 하나의 코드로 여러군데에서 사용하였습니다. 각각 다른 광고 크기를 사용해야 한다면 추가되는 파일을 따로 생성해서 추가하도록 코드를 변경해야 합니다. 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"adsense","slug":"adsense","permalink":"http://jacegem.github.io/blog/tags/adsense/"},{"name":"layout","slug":"layout","permalink":"http://jacegem.github.io/blog/tags/layout/"},{"name":"ejs","slug":"ejs","permalink":"http://jacegem.github.io/blog/tags/ejs/"}]},{"title":"[ahk] Generate haroopad Shortcuts by AHK","slug":"2016/ahk-Generate-haroopad-Shortcuts-by-ahk","date":"2016-01-05T01:11:31.000Z","updated":"2018-01-05T06:29:44.044Z","comments":true,"path":"2016/ahk-Generate-haroopad-Shortcuts-by-ahk/","link":"","permalink":"http://jacegem.github.io/blog/2016/ahk-Generate-haroopad-Shortcuts-by-ahk/","excerpt":"","text":"오토핫키로 하루패드 단축키 생성하기 뷰 단축키 설명 AHK 변경키 코드 SHIFT-CTRL-1 (에디터:뷰어)모드 F1 F1::Send +^1 SHIFT-CTRL-2 (뷰어:에디터)모드 F2 F2::Send +^2 SHIFT-CTRL-3 에디터 모드 F3 F3::Send +^3 SHIFT-CTRL-4 뷰어 모드 F4 F4::Send +^4 CTRL-F11 전체화면 모드 토글 F11 F11::Send ^{F11} CTRL-ALT-P 프리젠테이션 모드 F12 F12::Send ^!p 사용할 코드는 아래와 같습니다. 123456F1::Send +^1F2::Send +^2F3::Send +^3F4::Send +^4F11::Send ^&#123;F11&#125;F12::Send ^!p AHK를 실행하고, 트레이 아이콘에서, Window Spy를 실행합니다. Active Window Info 정보를 확인합니다. ahk_exe haroopad.exe 를 확용하여 해당 윈도우를 확인합니다.haroopad.ahk 파일명으로 파일을 생성합니다. 전체 코드12345678910#ifWinActive ahk_exe haroopad.exeF1::Send +^1F2::Send +^2F3::Send +^3F4::Send +^4F11::Send ^&#123;F11&#125;F12::Send ^!p#ifWinActive 하루패드에서만 단축키를 적용하기 위해서, #ifWindActive를 사용하였습니다. 유의 사항대문자 P와 소문자 p는 다르므로, 정확히 작성해야 합니다.","categories":[],"tags":[{"name":"ahk","slug":"ahk","permalink":"http://jacegem.github.io/blog/tags/ahk/"},{"name":"autohotkey","slug":"autohotkey","permalink":"http://jacegem.github.io/blog/tags/autohotkey/"},{"name":"haroopad","slug":"haroopad","permalink":"http://jacegem.github.io/blog/tags/haroopad/"},{"name":"shortcut","slug":"shortcut","permalink":"http://jacegem.github.io/blog/tags/shortcut/"}]},{"title":"[hexo] install powerful blog framework hexo","slug":"2016/hexo-install-powerful-blog-framework-hexo","date":"2016-01-04T17:10:45.000Z","updated":"2018-01-05T06:29:37.750Z","comments":true,"path":"2016/hexo-install-powerful-blog-framework-hexo/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-install-powerful-blog-framework-hexo/","excerpt":"","text":"파워풀 블로그 프레임워크 HEXO 설치하기 node.js 설치Git Bash를 설치합니다.node js를 설치합니다. 윈도우 방화벽 설정을 허용합니다. 버전을 확인합니다.12node -vnpm -v hexo 프레임워크를 설치합니다.123npm install hexo-cli -gnpm install hexo-deployer-git --savehexo -v 실행 결과123456789101112131415161718192021222324252627282930313233C:\\Temp&gt;npm install hexo-cli -gnpm WARN optional dep failed, continuing fsevents@1.0.6C:\\Users\\[USER]\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\[USER]\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\bin\\hexohexo-cli@0.2.0 C:\\Users\\[USER]\\AppData\\Roaming\\npm\\node_modules\\hexo-cli├── abbrev@1.0.7├── minimist@1.2.0├── bluebird@3.1.1├── tildify@1.1.2 (os-homedir@1.0.1)├── chalk@1.1.1 (supports-color@2.0.0, ansi-styles@2.1.0, escape-string-regexp@1.0.4, strip-ansi@3.0.0, has-ansi@2.0.0)├── hexo-util@0.5.1 (html-entities@1.2.0, highlight.js@9.0.0, camel-case@1.2.2)└── hexo-fs@0.1.5 (escape-string-regexp@1.0.4, graceful-fs@4.1.2, chokidar@1.4.2)C:\\Temp&gt;npm install hexo-deployer-git --savenpm WARN optional dep failed, continuing fsevents@1.0.6hexo-deployer-git@0.0.4 node_modules\\hexo-deployer-git├── chalk@0.5.1 (ansi-styles@1.1.0, escape-string-regexp@1.0.4, supports-color@0.2.0, strip-ansi@0.3.0, has-ansi@0.1.0)├── moment@2.11.0├── swig@1.4.2 (optimist@0.6.1, uglify-js@2.4.24)├── hexo-fs@0.1.5 (escape-string-regexp@1.0.4, graceful-fs@4.1.2, bluebird@3.1.1, chokidar@1.4.2)└── hexo-util@0.1.7 (ent@2.2.0, bluebird@2.10.2, highlight.js@8.9.1)C:\\Temp&gt;hexo -vhexo-cli: 0.2.0os: Windows_NT 6.1.7601 win32 x64http_parser: 2.5.0node: 4.1.0v8: 4.5.103.33uv: 1.7.4zlib: 1.2.8ares: 1.10.1-DEVmodules: 46openssl: 1.0.2d hexo 설치블로그로 사용할 디렉토리를 생성합니다. 12mkdir blogcd blog 블로그를 초기화 합니다.123hexo initnpm installhexo serve http://localhost:4000/ 로 접속하면 블로그 화면을 볼 수 있습니다. 참고 Setting up Hexo on Windows Github Pages와 Hexo github 생성저장소를 생성합니다. 저장소 이름을 설정합니다. 해당 저장소에서 Settings &gt; GitHub Pages &gt; Automatic page generator &gt; Launch automatic page generator 를 클릭하여 적당한 템플릿을 선택하여 생성합니다. ssh-keygen을 실행하여 ssh 키를 생성합니다. 해당 실행파일은 C:\\Program Files\\Git\\usr\\bin 에 있습니다. 12345678C:\\Program Files\\Git\\usr\\bin&gt;ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/[USER]/.ssh/id_rsa):Created directory '/c/Users/[USER]/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/[USER]/.ssh/id_rsa.Your public key has been saved in /c/Users/[USER]/.ssh/id_rsa.pub. .ssh/id_rsa 키를 저장하고 싶은 디렉토리를 입력합니다.이어서 암호를 두 번 입력합니다. 이때 암호를 비워두면 키를 사용할 때 암호를 묻지 않습니다. id_rsa.pub 파일의 내용을 복사해서, github에 등록합니다. 저장소에서 Settings &gt; Deploy keys &gt; Deploy keys &gt; Add deploy key 를 클릭합니다. 복사한 내용을 등록하고 Allow write access를 선택한 다음 Add key를 눌러서 키를 등록합니다. 참고 https://help.github.com/articles/generating-ssh-keys/ https://git-scm.com/book/ko/v2/Git-%EC%84%9C%EB%B2%84-SSH-%EA%B3%B5%EA%B0%9C%ED%82%A4-%EB%A7%8C%EB%93%A4%EA%B8%B0 configuration블로그를 위해 생성한 디렉토리의 _config.yml 파일을 수정합니다. URL을 변경합니다.12url: https:/[YOUR_ID].github.iom/blogroot: /blog/ 뒤에 blog가 붙은 이유는, 해당 저장소의 이름을 blog로 지정하였기 때문입니다. Deployment 를 수정합니다.1234deploy: type: git repository: git@github.com:[YOUR_ID]/blog.git branch: gh-pages 포스팅ssh 에이전트를 실행합니다.12ssh-agent -sclip &lt; id_rsa.pub 블로그를 위한 정적 파일을 생성하고 배포합니다. 123hexo cleanhexo generatehexo deploy 12FATAL Error: Host key verification failed.fatal: Could not read from remote repository. 위와 같은 에러가 발생하면 ssh -T git@github.com 을 실행하여 확인합니다. 123456C:\\Program Files\\Git\\usr\\bin&gt;ssh -T git@github.comThe authenticity of host &apos;github.com ([IP])&apos; can&apos;t be established.RSA key fingerprint is SHA256:[fingerprint].Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;github.com,[IP]&apos; (RSA) to the list of known hosts.Hi [YOUR_ID]/blog! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 참고 https://help.github.com/articles/generating-ssh-keys/ http://blog.star-flare.com/2014/11/23/hexo-setting-google-adsense/ https://github.com/hexojs/hexo/issues/1495 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://jacegem.github.io/blog/tags/blog/"},{"name":"framework","slug":"framework","permalink":"http://jacegem.github.io/blog/tags/framework/"},{"name":"install","slug":"install","permalink":"http://jacegem.github.io/blog/tags/install/"},{"name":"nodejs","slug":"nodejs","permalink":"http://jacegem.github.io/blog/tags/nodejs/"}]},{"title":"[hexo] change theme","slug":"2016/hexo-change-theme","date":"2016-01-04T13:37:58.000Z","updated":"2018-01-05T06:29:34.642Z","comments":true,"path":"2016/hexo-change-theme/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-change-theme/","excerpt":"","text":"Hexo 테마 변경 theme 변경여기에서 테마를 선택한 다음에 다운로드 받습니다. hexo blog 설치 경로 밑에 themes 폴더가 있고, 그 밑에 해당 파일을 복사합니다. (압축 파일이면 풀어 놓습니다.) 해당 폴더에는 기본 테마인 landscape가 있습니다. 복사해 넣은 테마로 적용하기 위해서 _config.yml를 수정합니다. 12#theme: landscapetheme: bootstrap 기존의 landscape 는 주석처리 하고, bootstrap을 추가합니다. 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"http://jacegem.github.io/blog/tags/theme/"}]},{"title":"책.C++ Network Programming Vol.1","slug":"2016/책. C++ Network Programming Vol.1","date":"2015-02-05T01:11:31.000Z","updated":"2018-01-05T06:29:27.360Z","comments":true,"path":"2016/책. C++ Network Programming Vol.1/","link":"","permalink":"http://jacegem.github.io/blog/2016/책. C++ Network Programming Vol.1/","excerpt":"","text":"[TOC] 책. C++ Network Programming Vol.1 운영체제 API 를 직접적으로 사용하여 프로그래밍 하는 것은 다음과 같은 문제점을 야기할 수 있습니다. 오류를 만들기 쉽습니다. 부적절한 디자인 기술 적용을 유발할 수 있습니다. 예제로 보는 Socket API의 문제점 ##ACE 소켓 Wrapper Facade 클래스 ACE Socket Wrapper Facades 구조ACE Socket wrapper facade class는 다음과 같은 기능들을 제공한다. ACE_SOCK_ : 인터넷 영역 소켓 API함수들을 캡슐화 시킨 클래스ACE_L_SOCK_ : Unix 영역(Local) 소켓 API함수들을 캡슐화 시킨 클래스 ACE Socket Wrapper Facades의 규칙Socket API에서 능동적으로 연결하기 위한 connect()함수와 능동적으로 연결하기 위해서 accept()함수를, 마지막으로 통신을 위해서 read(), write()함수를 사용하는 것과 마찬가지로, active connection role 과 passive connection role, communication role을 가지고 있다. 능동적 접속 규칙active connection role(ACE_SOCK_Connector)은 원격지로 연결을 초기화하는 규칙을 가진다. 수동적 접속 규칙passive connection role(ACE_SOCK_Acceptor)은 원격지의 연결을 받아들이는 규칙을 가진다. 통신 규칙communication role(ACE_SOCK_Stream)은 연결이 된후 어플리케이션관 데이터를 교환하기 위한 규칙을 가진다. ACE 프로그래밍 가이드라인에 대한 문서는 $ACE_ROOT/docs/ACE-guidelines.html 을 참조. 특성값(Trait)은 템플릿 클래스의 행동을 설정하기 위하여 한 무리의 특징들을 정의하고 결합하기 위해 사용될 수 있는 C++ 일반적(generic) 프로그래밍 용어입니다. +-----------------+ +----------------+ | ACE_SOCK_Stream | | ACE_INET_Addr | +-----------------+ +----------------+ ^ ^ | | +-----------------\\ +----------------\\ | PEER_STREAM | | PEER_ADDR | +-----------------+ +----------------+ | | +---------------------------------------------------------------------+ | ACE_SOCK_Connector | +---------------------------------------------------------------------+ +---------------------------------------------------------------------+ | + connect (stream : ACE_SOCK_Stream&amp;, remote_addr : ACE_Addr &amp;, | | timeout : ACE_Time_Value *= 0) : int | | + complete (stream : ACE_SOCK_Stream&amp;, remote_addr : ACE_Addr *=0, | | timeout : ACE_Time_Value *= 0) : int | +---------------------------------------------------------------------+ PEER_ADDR : 이 특성값은 ACE 소켓 wrapper facade 클래스와 관련된 ACE_INET_Addr 주소 지정 클래스를 정의 PEER_STREAM : ACE_SOCK_Acceptor 와 ACE_SOCK_Connector 팩토리 클래스와 관련된 ACE_SOCK_Stream 데이터 전송 클래스를 정의 선형화(Linearization) : 배열, 연결 리스트, 그래프와 같은 고급 타입의 데이터와 raw 상태의 메모리 버퍼간의 변환을 다룹니다. 마샬링/역마샬링(Marshaling/demarshaling) : 상이한 컴파일러간 정렬 규칙 및 다른 바이트 순서 규칙을 가진 하드웨어 명령들의 환경 안에서 정확하게 동작하도록 합니다. 용어 ==용어== ==뜻== Accidental Complexity 우발적 복합성 inherent complexity 고유한 복잡성 ACE ADAPTIVE Communication Environment SAP service access point TLI Transport Layer Interface 참고http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/C++/ACE/Documents/tutorialv1","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://jacegem.github.io/blog/tags/cpp/"},{"name":"c++","slug":"c","permalink":"http://jacegem.github.io/blog/tags/c/"},{"name":"network","slug":"network","permalink":"http://jacegem.github.io/blog/tags/network/"},{"name":"programming","slug":"programming","permalink":"http://jacegem.github.io/blog/tags/programming/"}]},{"title":"[md] markdown haroopad","slug":"2016/markdown-haroopad","date":"2014-06-08T01:11:31.000Z","updated":"2018-01-05T06:22:47.076Z","comments":true,"path":"2016/markdown-haroopad/","link":"","permalink":"http://jacegem.github.io/blog/2016/markdown-haroopad/","excerpt":"","text":"마크다운은 하루패드로 정착할 것 같습니다. 몇 가지 마크다운 프로그램들을 테스트 해보면서 안되는 구문들이 많았습니다. 취소선, 밑줄, 표 이 세가지가 기본적으로 잘 안되는 것들이었습니다. 하루패드에서는 모두 지원하면서 취소선, 밑줄, 표, 그리고 목차, 수식, 코드 까지 지원하더군요 목차[TOC] 수식$$J\\alpha(x) = \\sum\\limits{m=0}^\\infty \\frac{(-1)^m}{m! \\, \\Gamma(m + \\alpha + 1)}{\\left({\\frac{x}{2}}\\right)}^{2 m + \\alpha}$$ 표 name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $$$x^2$$$ 코드1234#include &lt;iostream&gt;int main(char *argv[]) &#123; return -2e3 + 12l; 아주 만족하면서, 사용법을 익히는 중입니다.기회가 된다면 소스로 보고싶은 프로그램입니다. 123int main()&#123;&#125; $$J\\alpha(x) = \\sum\\limits{m=0}^\\infty \\frac{(-1)^m}{m! \\, \\Gamma(m + \\alpha + 1)}{\\left({\\frac{x}{2}}\\right)}^{2 m + \\alpha}$$= = =a b c 자동완성 해제asdf 1234#include &lt;iostream&gt;int main(char *argv[]) &#123; return -2e3 + 12l; @caption [TOC] 목차두번째 목차#haroo pad 취소선 $$\\frac{x^2}{\\sqrt(2^2)}$$ i18next Copyright (c) 2011 Jan Mühlemann (MIT) 123function syntax(a, b) &#123; return a + b;&#125; name age gender money rhio 384 robot $3,000 haroo .3 bird $430 jedi ? undefined $$$x^2$$$ $$$x^2$$$$$x^2$$@Alt Text underline ul","categories":[],"tags":[{"name":"haroopad","slug":"haroopad","permalink":"http://jacegem.github.io/blog/tags/haroopad/"},{"name":"md","slug":"md","permalink":"http://jacegem.github.io/blog/tags/md/"},{"name":"markdown","slug":"markdown","permalink":"http://jacegem.github.io/blog/tags/markdown/"}]},{"title":"하루패드 사용팁","slug":"2016/하루패드 사용팁","date":"2014-06-05T01:11:31.000Z","updated":"2018-01-05T06:29:31.085Z","comments":true,"path":"2016/하루패드 사용팁/","link":"","permalink":"http://jacegem.github.io/blog/2016/하루패드 사용팁/","excerpt":"","text":"[toc] 하루패드 도움말 패널 보기화면 좌측 하단의 버튼을 누르면 도움말이 왼쪽에 펼쳐집니다. 또는 우측 하단 버튼에서, 도움말을 선택해서 볼 수도 있습니다. 수학 표현식 사용하기 파일 &gt; 환경설정 수학표현식을 체크합니다. 수학표현식은 TeX 문법을 참고하면됩니다. $$\\begin{aligned}\\dot{x} = \\sigma(y-x) \\\\dot{y} = \\rho x - y - xz \\\\dot{z} = -\\beta z + xy\\end{aligned}$$ $$\\sin x + \\ln y +\\operatorname{sgn} z \\\\frac{2}{4} or {2 \\over 4}$$ $$ 와 $$ 사이에 수학표현식을 적으면 되는데, 여러개의 수학표현식을 쓰면 옆으로 붙어서 나오게 됩니다. 여러개의 수학표현식을 한번에 적을 때에는 하나의 수학표현식이 끝난 후에 \\\\ 를 붙여서 구분 표시를 해주어야 합니다. \\$$\\sin x + \\ln y +\\operatorname{sgn} z \\\\\\frac{2}{4} or {2 \\over 4}\\$$ 잘못적은 정보가 있다면 알려주시기 바랍니다.~","categories":[],"tags":[{"name":"haroopad","slug":"haroopad","permalink":"http://jacegem.github.io/blog/tags/haroopad/"},{"name":"md","slug":"md","permalink":"http://jacegem.github.io/blog/tags/md/"},{"name":"markdown","slug":"markdown","permalink":"http://jacegem.github.io/blog/tags/markdown/"}]},{"title":"[wiki] 도쿠 위치 설치하기","slug":"2016/도쿠 위치 설치하기 2","date":"2014-03-05T01:11:31.000Z","updated":"2018-01-05T06:23:02.801Z","comments":true,"path":"2016/도쿠 위치 설치하기 2/","link":"","permalink":"http://jacegem.github.io/blog/2016/도쿠 위치 설치하기 2/","excerpt":"","text":"[TOC] 도쿠 위치 설치하기필요한 파일 dokuwiki 홈페이지에서 파일을 다운로드한다.(다운로드 페이지)용량은 2.8M정도 입니다. XAMPP XAMPP 를 다운로드 합니다. XAMPP 를 설치합니다. xampp-win32-1.8.3-2-VC11-installer.exe 실행 dokuwiki 파일을 압축을 푼 다음에 설치한 XAMPP/htdocs 경로에 복사합니다. E:\\xampp\\htdocs\\wiki 웹 브라우저에서 localhost/wiki/install.php 로 접속 복사한 경로에 맞게 수정해서 설치 페이지로 접속합니다. 플러그인 설치 사용자 신규가입을 위해서 swiftmail 플러그인을 설치합니다.https://www.dokuwiki.org/plugin:swiftmail 에 접속해서 다운로드 합니다. 다운로드한 파일을 압축을 풀어서 플러그인 폴더에 복사합니다. E:\\xampp\\htdocs\\wiki\\lib\\plugins\\swiftmail 도쿠위키 관리 페이지에서, SMTP 메일 설정을 하면됩니다. 관리 &gt; 환경설정 &gt; 플러그인설정 &gt; Swiftmail 에서 설정을 합니다. Gmail 을 사용하였습니다.SMTP: smtp.gmail.comPORT: 465암호화: TLSUSER: 사용하는 이메일PASS: 이메일 암호 ##오류들 Windows XP 에서 XAMPP 을 설치할 때에 에러 발생 XP에 설치할 경우에는 php 5.4 이하 버전으로 설치해야만 한다. ##참고http://z3moon.com/wiki/%EC%84%A4%EC%B9%98https://www.oss.kr/41671http://blog.naver.com/PostView.nhn?blogId=gdlab&amp;logNo=150003033037","categories":[],"tags":[{"name":"wiki","slug":"wiki","permalink":"http://jacegem.github.io/blog/tags/wiki/"},{"name":"dokuwiki","slug":"dokuwiki","permalink":"http://jacegem.github.io/blog/tags/dokuwiki/"}]},{"title":"[wiki] 도쿠 위치 설치하기","slug":"2016/도쿠 위치 설치하기","date":"2014-02-05T01:11:31.000Z","updated":"2018-01-05T06:22:53.863Z","comments":true,"path":"2016/도쿠 위치 설치하기/","link":"","permalink":"http://jacegem.github.io/blog/2016/도쿠 위치 설치하기/","excerpt":"","text":"[TOC] 도쿠 위치 설치하기필요한 파일 dokuwiki 홈페이지에서 파일을 다운로드한다.다운로드 페이지용량은 2.8M정도 입니다. XAMPP XAMPP 를 다운로드 합니다. ##참고http://z3moon.com/wiki/%EC%84%A4%EC%B9%98https://www.oss.kr/41671http://blog.naver.com/PostView.nhn?blogId=gdlab&amp;logNo=150003033037","categories":[],"tags":[{"name":"wiki","slug":"wiki","permalink":"http://jacegem.github.io/blog/tags/wiki/"},{"name":"dokuwiki","slug":"dokuwiki","permalink":"http://jacegem.github.io/blog/tags/dokuwiki/"}]}]}