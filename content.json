{"meta":{"title":"Momentous for the future","subtitle":"Momentous for the future","description":"Momentous for the future","author":"Jace","url":"http://jacegem.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"Flutter 이미지 보여주기","slug":"2023/flutter-network-image","date":"2023-10-23T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2023/flutter-network-image/","link":"","permalink":"http://jacegem.github.io/blog/2023/flutter-network-image/","excerpt":"","text":"네트워크 이미지 보여주기 1Image.network(&#x27;https://picsum.photos/250?image=9&#x27;) 모서리 둥글게 만들기 12345678ClipRRect( borderRadius: BorderRadius.circular(8.0), child: Image.network( &#x27;https://picsum.photos/250?image=9&#x27;, height: 150.0, width: 100.0, ),) 원형 이미지 만들기 1234CircleAvatar( radius: 48, // Image radius backgroundImage: NetworkImage(&#x27;imageUrl&#x27;),) 123456ClipOval( child: SizedBox.fromSize( size: Size.fromRadius(48), // Image radius child: Image.network(&#x27;imageUrl&#x27;, fit: BoxFit.cover), ),) cached_network_image 사용하기 https://pub.dev/packages/cached_network_image dependecies 추가 pubspec.yaml 파일에 아래 내용을 추가한다. 12dependencies: cached_network_image: ^3.3.0 CachedNetworkImage 를 사용하여 이미지를 표출한다. 12345CachedNetworkImage( imageUrl: &quot;http://via.placeholder.com/350x150&quot;, placeholder: (context, url) =&gt; CircularProgressIndicator(), errorWidget: (context, url, error) =&gt; Icon(Icons.error), ), 출처 https://pub.dev/packages/cached_network_image https://stackoverflow.com/questions/51513429/how-to-do-rounded-corners-image-in-flutter","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://jacegem.github.io/blog/categories/Flutter/"},{"name":"Image","slug":"Flutter/Image","permalink":"http://jacegem.github.io/blog/categories/Flutter/Image/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://jacegem.github.io/blog/tags/flutter/"},{"name":"image","slug":"image","permalink":"http://jacegem.github.io/blog/tags/image/"}]},{"title":"성공하는 사람들의 자기 시간 연구 2","slug":"2019/성공하는-사람들의-자기-시간-연구","date":"2019-02-25T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2019/성공하는-사람들의-자기-시간-연구/","link":"","permalink":"http://jacegem.github.io/blog/2019/%EC%84%B1%EA%B3%B5%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C%EB%93%A4%EC%9D%98-%EC%9E%90%EA%B8%B0-%EC%8B%9C%EA%B0%84-%EC%97%B0%EA%B5%AC/","excerpt":"","text":"성공하는 사람들의 자기 시간 연구 우에노 미쓰오 저/이보윤 역 자기 시간이야말로 성공을 만든다. 성공 비결은 시간을 보내는 법에 있다. 금전적으로도 정신적으로도 만족하는 사람은 분명 존재한다. 수입의 복선화 성공은 '자기 시간’에 의해 만들어진다 성공한 사람이 가장 중요하게 여기는 ‘자기 시간’ '타인의 시간’이 아니라 '자기 시간’을 살아가자고 결심하자! '자기 시간’이란 다른 사람에게 좌우되지 않고 자기 의지로 자유롭게 사용하는 시간을 뜻합니다. '자기 시간’에 해야 하는 5가지 정보 수집 및 공부 업무처리 능력 향상 신체 단련 인간력·정신력 향상 수입 인생의 마지막을 앞뒀을 때 당신을 지탱하는 것 '버킷리스트’에서 그리는 '자기 시간’의 중요성 하루 6시간의 '자기 시간’을 되찾다 바빠도 시간을 확보할 수 있는 3가지 방법 일의 목표를 생각한다 업무 시간표를 작성한다 시간의 밀도에 차이를 둔다 생산성을 높이고 정시 퇴근을 위한 마인드 개혁 일주일은 4일이라 의식하고 일적 월반을 실현한다 업무의 의의와 목표를 강하게 인식한다 '야근하지 않는 사람’이라는 브랜딩을 하라 테크니컬 스킬을 향상시키면 이렇게까지 야근을 줄일 수 있다 아웃라인을 정하고 난 다음 시작하라 템플릿을 준비하라 확인 업무의 효율화 정보수집과 사전준비를 충실히 하라 수첩이나 노트를 활용해 창의적인 발상을 하라 성공의 기초인 '지성’과 '교양’을 독학으로 갈고닦는다 성공한 사람들의 공통적인 독서 패턴 주 2회 서점에 간다 꼭 읽어야 하는 장르 전문지식을 습득하려면 같은 분야의 책을 20권 이상 읽는다 같은 책을 여러 권 산다 형광펜으로 표시하면서 읽는다 지식인, 교양인의 독학 요령 흥미를 가지고 즐겁게 임할 수 있는 분야 최고가 될 수 있는 분야 장기간에 걸쳐 계속해서 공부할 수 있는 분야 이왕 신문을 읽는다면, 업계지에 손을 뻗자 테마나 과제를 정하고 읽는다 문장을 요약한다 3종류의 신문을 읽는다","categories":[{"name":"Blog","slug":"Blog","permalink":"http://jacegem.github.io/blog/categories/Blog/"},{"name":"Book","slug":"Blog/Book","permalink":"http://jacegem.github.io/blog/categories/Blog/Book/"}],"tags":[{"name":"성공하는","slug":"성공하는","permalink":"http://jacegem.github.io/blog/tags/%EC%84%B1%EA%B3%B5%ED%95%98%EB%8A%94/"},{"name":"사람들의","slug":"사람들의","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EB%9E%8C%EB%93%A4%EC%9D%98/"},{"name":"자기","slug":"자기","permalink":"http://jacegem.github.io/blog/tags/%EC%9E%90%EA%B8%B0/"},{"name":"시간","slug":"시간","permalink":"http://jacegem.github.io/blog/tags/%EC%8B%9C%EA%B0%84/"},{"name":"연구","slug":"연구","permalink":"http://jacegem.github.io/blog/tags/%EC%97%B0%EA%B5%AC/"}]},{"title":"[Y세미나] 데이터경제, 무엇을 해야 하나","slug":"2019/Y세미나-데이터경제-무엇을-해야-하나","date":"2019-02-22T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2019/Y세미나-데이터경제-무엇을-해야-하나/","link":"","permalink":"http://jacegem.github.io/blog/2019/Y%EC%84%B8%EB%AF%B8%EB%82%98-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B2%BD%EC%A0%9C-%EB%AC%B4%EC%97%87%EC%9D%84-%ED%95%B4%EC%95%BC-%ED%95%98%EB%82%98/","excerpt":"","text":"[Y세미나] 데이터경제, 무엇을 해야 하나 2019-02-21에 진행한 [Y세미나] 데이터경제, 무엇을 해야 하나 세미나 내용을 정리합니다. 데이터 카테고리 데이터 주체와 목적에 따라 구분 데이터 카테고리에 따라 제도 및 실무 성숙 수준이 다름 구분 개념 이슈 정부 기업 연구자 개인 오픈데이터 정부 또는 대기업의 대규모 데이터를 기업 또는 개인이 활용하도록 공개 데이터 품질 및 활용 주체 주체 활용 활용 (빅)데이터 기업 또는 정부가 자체 성과 향상을 위하여 보유 데이터를 활용 개인정보 보호 활용 활용 활용 대상 마이데이터 개인이 자신의 데이터를 자신을 위해 활용 데이터 제공 제도화 제공 제공 활용 연구데이터 연구자의 연구데이터를 다른 연구자에게 제공하여 오픈 사이언스 달성 데이터 지적재산권 등 주체 소셜데이터 개인이 소셜미디어에 스스로 자신의 데이터를 올리고 공유 잊혀질 권리 등 관리 주체 데이터 이슈 : 공개와 활용 예산을 대규모로 투입해서 공개하지만 활용하지 않는다. 활용하려고 해도, 데이터 품질이 문제이다. 품질이 좋아서 활용하는 것이 아니라, 활용하니까 품질이 좋아진다. 오픈 데이터 개요 Open Data 누구나 무료 또는 적정한 비용으로 편리하게 이용할 수 있는 데이터 Open Government Data 정부가 제공하는 오픈데이터 공공데이터 데이터베이스, 전자화된 파일 등 공공기관이 법령 등에서 정하는 목적을 위하여 생성 또는 취득하여 관리하고 있는 광 또는 전자적 방식으로 처리된 자료 또는 정보를 말함 개방 공공기관이 이용자에게 공공데이터를 활용할 수 있는 형태로 제공하고, 제공받은 공공데이터를 영리적·비영리적으로 이용할 권한을 부여하는 것을 말함 오픈데이터 과제 오픈데이터 스타트업 발굴 오픈데이터 품질 제고 민감정보 활용 방안 확산 데이터맵으로 접근성 향상 오픈데이터 스타트업 발굴 컨설팅을 통해서 주도적으로 오픈데이터 비즈니스 시나리오 기획 필요 안전한 해외여행·출장을 위한 필수 앱! 세계여행 지기 국가별 안전정보, 물가정보, 교통정보 등 안전한 여행과 출장을 위한 서비스 제공 좋은 바이어 있으면 소개시켜줘! 국내기업-해외바이어 매칭 서비스 해외 바이어 정보 데이터 활용 수출기업과 해외바이어와 매칭서비스 국가·상품 해외바이어 정보 http://ecrobot.com/ https://www.foreign-trade.com/ http://gobizkorea.com/user/main.do https://www.ecplaza.net/ 국가별 기업데이터 미국 (https://www.data.gov/) 영국 (https://data.gov.uk/) 호주 (https://data.gov.au/) 싱가포르 (https://data.gov.sg/) 캐나다 (https://open.canada.ca/en) 뉴질랜드 (https://data.govt.nz/) 홍콩 (https://data.gov.hk/en/) EU (https://www.europeandataportal.eu/) EU (http://data.europa.eu/euodp/en/home) 벨기에 (http://data.belgium.be/en) 세계은행 (https://data.worldbank.org/) 케냐 (http://www.opendata.go.ke/) 프랑스 (https://www.data.gouv.fr/en/) 미국과 중국의 무역전쟁이 수출활동에 미치는 영향 분석 수출입 관련 마이크로 데이터를 활용 수출 활동이 국내 경제에 미치는 영향 분석 GPS 위치 기반 국가별 무역업무 관련 정보 안내 서비스 앱 무역과 관련있는 해당국가 현지 정보를 위치 기반으로 제공해주는 서비스 상담데이터 트랜드 분석 및 이상 징후 관리 서비스 수출 지원기관의 무역 상담 데이터 통합 기업 맞춤형 상담정보를 제공하는 서비스 산업경제 보고서 맞춤형 서비스 해외진출 관련 산업경제 보고서 통합 분류체계별 산업경제 보고서 제공 서비스 상품을 어디에 수출하지? 국가별 수출 유망상품 추천 스마트 서비스 ITC/코트라 유망 상품 추천 서비스를 활용 수출 유망 국가 정보 제공 서비스 해외시장 관련 뉴스 개인별 맞춤형 정보 제공 해외진출 관련 기관 뉴스를 통합 개인의 취향에 맞게 정보를 제공하는 서비스 해외전시회 &amp; 행사(공연·문화) 융·복합 서비스 활용자 관심 키워드 기반 전시회, 공연, 문화 행사 맞춤형 정보 서비스 해외바이어 신용정보 및 평판 정보 제공 서비스 기업현황, 신용등급, 신용불량정보 등의 기업정보를 제공해주는 서비스 민감정보 활용방안 확산 민감정보 활용 방안으로서 데이터프리존 적용 데이터 프리존 개념 ‘미래의 유전’ 으로 불리는 오픈데이터를 활용한 융합서비스 개발을 위해 공공과 민간데이터를 특정 공간에서 연계 및 분석할 수 있도록 하자는 것 데이터 프리존은 양질의 데이터를 보유한 행정기관의 내부 데이터와 외부(민간) 데이터를 자유롭게 연계·분석한 후 결과물을 안전하게 반출할 수 있는 공간 민간정보 활용방안 확산 보건의료빅데이터개방시스템 빅데이터분석DB 진료내역, 심사기준 처방내역, 평가결과 질병내역, 의약품 요양기관, 지료재료 빅데이터개방DB 진료정보, 청구경향 의약통계, ODBC 통계 공공데이터 오픈API 빅데이터 개방 플랫폼(포털) 공공데이터, 통계정보 공개목록, 질병통계 오픈API, 의약통계 데이터셋, 지원통계 데이터사이언스 자동화 데이터 준비(Data Preparation) 자동화 및 데이터 분석 패턴 제공 데이터 준비에서 데이터 분석, 보고서 작성 까지 전체 과정 통합 지원 데이터 거버넌스 10가지 질문 비즈니스 전략-분석 유스케이스를 실행하기 위해 어떤 데이터가 수집되어야 하나? 얼마나 보관되어야 하나? 데이터 프라이버시와 보안은 어떻게 관리되어야 하나? 어디에 저장되어야 하나? 데이터 위치는 어디인지 알 수 있는가? 어떤 데이터가 표시될 수 있나? 어느 수준의 세부항목을 제공/관리해야 하나 누가 데이터 관리의 책임자인가? 누가 데이터의 소비자인가? 데이터는 어떻게 합쳐지고 변경되는지 추적할 수 있는가? 데이터를 소스형태/접근 위치와 관계없이 가상화하여 제공하는가? 데이터/분석의 성과는 관리되는가? 마이데이터 개념 마이데이터는 개인데이터 활용체계의 새로운 패러다임으로 개인의 데이터 주권을 기반으로 개인데이터 공유 및 활용 권한 행사 데이터 권한 개인의 개인데이터의 접근, 이동, 활용 등에 대한 통제권 및 결정권을 가져야 함 데이터 제공 기관들은 개인이 요구할 때, 개인데이터를 안전한 환경에서 쉽게 접근하여 이용할 수 있는 형식으로 제공하여야 함 데이터 활용 개인 동의에 의한 데이터의 자유로운 이동과 제3자 접근이 가능하여야 함 데이터 보유기업 참여 촉진 데이터보유기업은 선제적 참여보다 제도 발표 및 시장의 반응을 따라가는 중으로 이해득실에 따라 마이데이터 도입 방식 차별화 예상 개인데이터(빅데이터) 판매를 위한 디딤돌 타사 보유 개인데이터 확보 기회 우리기업 중심의 마이데이터 생태계 통합 가능성 서비스 제공기업 제휴를 통해 마이데이터 도입 초반 시장 선점 보유데이터의 적극적 활용 지원 의사결정자들의 인식제고 데이터집중기관 우선 참여로 선도사레 사례 구체적인 가이드라인 및 개인데이터 관리비용 지원 연구데이터 플랫폼 필요 미국 데이터 플랫폼 사례 (https://kbase.us/) 독일 연구 클러스터 사례 (https://www.mpg.de/de) 연구데이터 활용 연구 사례 (http://deepdive.stanford.edu/showcase/apps)","categories":[{"name":"Blog","slug":"Blog","permalink":"http://jacegem.github.io/blog/categories/Blog/"},{"name":"Seminar","slug":"Blog/Seminar","permalink":"http://jacegem.github.io/blog/categories/Blog/Seminar/"}],"tags":[{"name":"Y세미나","slug":"Y세미나","permalink":"http://jacegem.github.io/blog/tags/Y%EC%84%B8%EB%AF%B8%EB%82%98/"},{"name":"데이터","slug":"데이터","permalink":"http://jacegem.github.io/blog/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"경제","slug":"경제","permalink":"http://jacegem.github.io/blog/tags/%EA%B2%BD%EC%A0%9C/"}]},{"title":"내 삶을 바꾸는 52주의 기록","slug":"2019/내-삶을-바꾸는-52주의-기록","date":"2019-02-17T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2019/내-삶을-바꾸는-52주의-기록/","link":"","permalink":"http://jacegem.github.io/blog/2019/%EB%82%B4-%EC%82%B6%EC%9D%84-%EB%B0%94%EA%BE%B8%EB%8A%94-52%EC%A3%BC%EC%9D%98-%EA%B8%B0%EB%A1%9D/","excerpt":"","text":"내 삶을 바꾸는 52주의 기록 ⚡️ 내 삶을 바꾸는 52주의 기록 - 셰릴 리처드슨 저 실천할 수 있는 내용 위주로 정리합니다. 새로운 삶을 살기 위한 네 가지 질문 성격 면에서 보완된 점이 있다면? 선행을 나누거나 다른 사람을 도운 경험이 있다면? 사랑하는 사람들과 만든 특별한 추억이 있다면? 내가 이룬 것이 있다면? (책, 워크샵, 창의적인 일) 내가 이룬 가장 중요한 것 스무 가지는? 진정한 변화는 내면에서 시작된다. 앞으로 1년간 개선하고 싶은 자질은 무엇인가? 어떻게 성장하고 싶은가? 무엇에 집중해야 할지 잘 모르겠다면 다음의 예를 참고 하자. 경제적으로 책임감 있는 사람이 되겠다. 나는 매일 나의 최우선 과제 세 가지에 집중한다. 나의 첫 번째 우선순위가 무엇인지 고민해보고, 그것들에 집중하겠다. 인내심을 기르겠다. 더 많이 사랑하고 친절해지겠다. 적당한 선을 긋고, 싫을 땐 싫다고 말하는 능력을 키우겠다. 두려워하지 않고, 용기를 내고, 대담해지고자 노력하겠다. 열린 마음으로 살겠다. 늘 감사하는 마음을 갖겠다. 끌려다니지 않고 주도하는 삶을 살겠다. 모험심을 갖겠다. 누구에게나 신뢰받는 사람이 되겠다. 나는 매일 나의 최우선 과제 세 가지에 집중한다. 내가 서 있는 위치 알기 가장 개선하고 싶은 점은? 나의 다짐은? 이번 주 실천 사항은? 잃어버린 '나’를 찾아서 일기 쓰기 꿈 적기 지원군 커뮤니티 만들기 영적인 삶 되살리기 나와의 약속 잡기 나를 기록하는 힘 아침 글쓰기는 나에게 다음과 같은 변화를 가져다 주었다. 내 영혼에, 그리고 정말 중요한 것들에 긴밀하게 연결됨을 느낀다. 나의 하루하루는 일관되게 내 삶의 첫 번째 우선순위를 지향한다. 내 삶의 첫 번째 우선순위를 지원해주는 사건들이 연속적으로 일어남을 느낀다. 외부의 영향으로는 한 번도 느껴보지 못했던 안정감을 느낀다. 식습관이 극적으로 개선됐다. 나의 선택들이 내면을 더 지향하게 됐고, 다른 사람의 생각을 덜 의식하게 됐다. 혼자만의 시간을 더 좋아하게 됐다. 일기 쓰기 언제 쓰는 것이 가장 좋을까? (아침 시간) 무엇을 써야 할까? 오늘 아침 나의 감정은 나는 늘 이런 상상을 한다. 내 내면의 목소리는 계속해서 내게 이런 말을 한다. 내 머릿속에서 계속 맴도는 생각은 나의 마음이 간절히 원하는 것은 내가 가장 두려워하는 것은 내 안에서 비판의 목소리가 이렇게 말한다. 내가 가장 감사하게 생각하는 것은 꾸준히 써나갈 동력은 어떻게 얻을까? 아침 일기 쓰기 시간이라는 선물 나의 우선순위 리스트 만들기 지금 나의 삶에서 관심을 기울여야 할 일은 무엇인가? 놓아버려야 할 일은 무엇인가? 무엇이 나를 지치게 하는가? 다음 질문들을 통해 심적으로 지치게 하는 요소들을 찾아보자. 전화 통화를 하거나 만나거나 하는 일을 계속 피하고만 싶은 상대가 있는가? 하겠다고 약속한 일 중에 지금은 후회하는 것이 있는가? 더는 흥미를 느끼지 못하는 프로젝트에서 아직도 발을 빼지 못하고 있는가? 더는 의미 없는 목표를 아직도 밀어붙이고 있는가? 힘들었던 시기를 떠올리게 하거나 과거에 얽매이게 하는 어떤 일에서 아직도 헤어나오지 못하고 있는가? 나를 지치게 하는 요소 제거하기 스스로 동기부여 하는 법 내 삶에 찾아온 마법 알아보기 느긋해지기 위해 필요한 것 검사받기 휴식 시간 갖기 일하는 습관 바꾸기 깊은 호흡 하기 몸의 면역체계를 보강하기 위해 종합 비타민 복용하기 카페인과 이별하기 규칙적으로 운동하기 건강한 습관 만들기 집중력의 힘이 곧 성공의 비결 하나의 목표에 집중하기 저글링을 멈추고 너의 삶을 살아! 내려놓으라고 권하고 싶은 공들 모두를 만족시키겠다는 생각 모두가 나를 좋아하게 만들겠다는 생각 나의 삶을 대가로 인기인이 되겠다는 생각 모든 것을 완벽하게 해내겠다는 생각 모든 것을 하겠다는 생각 아드레날린에 의존하는 것 나의 엔진 확인하기 성취를 위한 자질 계발하기 내가 원하는 일을 하고 있는 사람을 찾는다. 특히 그 분야에서 성공한 사람을 찾자. 그 사람의 성공에 기여한 세 가지 자질을 적어본다. 그중에서 내가 가장 개선해야 하는 자질 한 가지를 선택한다. 나를 가장 흥분시키면서 동시에 두렵게 하는 것을 고르면 정답일 확률이 높다. 이 자질을 매일 연마할 수 있는 현실적인 방법들을 찾는다. 뇌에도 휴가가 필요해 몸을 가꾸는 시간 재미있게 살고 있니? 재미있게 살기 친구들과 놀기 게임하기 장난감 가게에 가기 새끼 고양이 안아보기 아이스크림 먹기 미끄럼틀이나 그네 타고 놀기 해변에 가서 물장구치기 썰매 타기 정글짐에서 놀기 샤워하지 않기 도움을 청해도 괜찮아 멈추고, 보고, 들어봐 삶의 서류함은 절대로 비는 법이 없습니다. 나를 위한 유식 계획하기 가족 중 한 명에서 전화해서 하룻밤만 아이들을 맡아달라고 부탁한다. 마사지를 예약한다. 친구에게 전화를 걸어 도움을 청한다. 꼭 보고 싶었던 영화를 보러 간다. 일과 중에 낮잠을 잔다. 반려자와 한밤의 데이트를 계획한다. 욕조에 몸을 푹 담그고 목욕을 하거나 집에서 스파 분위기를 연출 해 본다. 버리고, 비우기 버려야 할지 말아야 할지 결심이 안 설 때는 내다 버린다. 헷갈릴 때는 내다 버린다. 비우기 훈련 에너지 집중하기 일이 바빠질 때면 더 생산적이고 즐거운 하루하루를 보낼 수 있도록 하는 나만의 비결이 하나 있다. 바쁠 때일수록 아침에 시간을 내어 그날의 중요한 안건들을 정리하는 시간을 갖는 것이다. 그러면 집중력은 높이고 스트레스는 눈에 띄게 줄일 수 있다. 출근전 나는 조용히 않아 다음 세 가지를 차분하게 실행한다. 다이어리에 이번 주의 우선순위 세 가지를 적어본다. 이 우선순위 들에 집중하기 위해 오늘 할 수 있는 가장 중요한 실천 사항 세 가지를 적어본다. 에너지를 분산시킬 만한 요인을 예측하고 미리 제거한다. 이번 주의 운선순위가 다음과 같다고 가정해보자. 운동 보고서 작성 끝내기 가족과 함께 좋은 시간 보내기 오늘의 가장 중요한 실천 과제 세 가지는 다음과 같이 정할 수 있다. 이번 주 일정에 운동할 날 3일을 집어넣고 달력에 표시한다. 보고서 작성에 집중할 수 있는 두 시간을 빼놓는다. 주말에는 가족과의 나들이를 계획한다. 내키는 대로 해도 괜찮아 궁극적 자기 돌보기 연습 기다리는 연습 친구, 팩트 그리고 믿음 나에게 빛날 기회 주기 두려움이 앞선다면 (아마도 그럴 것이다), 한가지만 기억하자. 이 세상에서 실망했다고, 거절당했다고, 실패했다고 죽은 사람은 아무도 없다는 것. 그 순간이 오히려 성공하는 법에 한발 더 가까워지는 때다. 그러니 해보는 거다! 가까이 다가가기 나는 영혼이 깨어 있는 사람인가? 나의 영혼 깨우기 주위 사람들이 뭐라고 하든 나의 신념을 당당히 지켜낸다. 두렵다 해도 진실을 말한다. 내가 소중히 여기는 가치에 어긋나는 행동을 하는 고객과는 함께 일하지 않는다. '에고’라는 적이 내 앞에 나타날 때 당신은 새로운 것을 해보려다가 주저앉은 경험이 몇 번이나 되는가? 이런 상상을 해보자. 어느 날 아침 일어났더니 손바닥에 알약 하나가 쥐여져 있고, 그 약만 꿀꺽 삼키면 부정적인 감정이나 남의 시선에 대한 두려움이 말끔히 사라진다고 한다. 당신은 어떤 모험을 감행하겠는가? 자신에게 어떤 즐거움을 허락하겠는가? 이 별에서의 시간을 정말 소중하다. 그런데 왜 우리는 자신을 주저앉히는 데 그렇게 많은 에너지를 쓰고 있을까. 이제 경계심을 내려놓고, 나를 옥죄는 근심 걱정 따위는 바람결에 날려 보내고, 삶을 멋지게 살아보자. 자의식에 한번 정면으로 맞서보면, 의외로 쉽게 극복할 수 있다는 것을 알게 될 것이다. 경험에서 나온 말이니 믿어도 좋다. 내가 처음 새로 장만한 최신 유행의 헬맷을 썼을 때, ‘바보 같아 보이면 어쩌지?’ 했던 두려움은 페달을 밟자마자 사라져버렸으니까. 누군가의 그림자 안에 있다면 소신 있는 삶을 사는 방법 경제적으로 자유로운 삶이 되려면 돈과 투자에 대해 공부한다. (주식, 채권, 투자 아이디어) 경제에 대한 기준을 한 단계 높이고 저축을 시작한다. 경제적 조언을 해줄 수 있는 파트너를 구한다. 나의 경제적 자유에 투자하기 투자 전문가와 상담 약속을 잡는다. 동네 도서관을 찾아가 경제 관련 책을 읽는다. 은행에서 잠자는 돈을 좀더 수익성 높은 투자 상품으로 옮긴다. 나의 연금제도를 검토한다. 멈추고, 돌아보고, 보상하기 내 안의 어린아이 불러내기 최대한 큰 종이와 파스텔을 사서 그림 그리는 시간을 갖는다. 색을 섞고 문지를 때는 손가락을 사용한다. 친구를 불러 함께 밥을 먹는데, 격식 따위는 잊는다. 손으로 먹기를 적극 추천한다! 고무찰흙을 몇 통 사서 사무실에 보관해두고 나라마 괴물 하나씩을 만들어본다. 숲에서 시간을 보내면 하늘 높이 솟은 나무들과 초록빛 풀, 작은 솔방울, 나뭇가지, 바위들을 감상한다. 거실의 커튼을 치고 제일 좋아하는 댄스 음악을 틀어놓고 한바탕 춤을 춘다. 몸이 더러워지는 걸 신경 쓰지 않는다. 마당에 털썩 주저앉아 잡초를 뽑고, 나무를 심고, 그냥 땅에 구명을 파며 논다. 동네 책방에 가서 아이들 색칠공부 책을 하나 고른다. 이 책을 사무실 서랍에 넣어두고 짬이 날 때마다 꺼내서 색칠해본다. 잠, 잘 자고 있니? 근무 환경 돌아보기 도전해봐, 한 번도 실패하지 않은 것처럼 지금 당신이 하는 일은 세상에 어떻게 기여하고 있는가? 당신의 기여도를 한 차원 끌어올리기 위해 극복해야 할 문제는 무엇인가? 사람들의 반응에 대한 두려움 실패에 대한 두려움 너무 많은 책임에 대한 두려움 거절당하는 것에 대한 두려움 비난 또는 비판에 대한 두려움 실망에 대한 두려움 도움을 청하지 못하는 성격 도움받는 것을 못 견디는 성격 나의 비전 실현하기 나의 일은 다른 사람들에게 어떤 도움을 주는가? 나의 일이 공익에 어떻게 도움이 되길 원하는가? 나의 안식처를 아늑하게 행복한 공간 만들기 집에서 특별한 공간을 하나 선택한다. 깔끔하게 청소한다. 공간을 돌아보고 새로 갖추고 싶은 것들을 생각해본다. 조명, 장식품, 패브릭, 편안한 가구 등이 있을 것이다. 이번 주에는 그중에서 한 가지를 갖추자. 삶의 자산 챙기기 운동화 끈을 미리 고쳐 매는 습관 잠시 호흡 고르기 우선순위 리스트를 재평가해서 나의 시간과 관심을 기꺼이 쏟을 다섯 가지를 명확히 인지하고 있는가? 앞으로 석 달 동안(특히 명절이나 연휴 기간에) 매주 '나’를 위한 시간을 안배했는가? 예전에 잡은 일정이나 약속 중에 마음이 바뀐 것은 없는가? (마음이 바뀌었다고 미안해할 필요는 없다. 그 역시 우리의 정당한 선택이다. 그리고 어차피 바꿀 거것이라면 빨리 바꿀수록 좋다.) 원하지 않는 상황에 안주하지 말 것 꿀 같은 휴식 즐기기 직장에서 자기 돌보기 작지만 확실한 행복 온전히 느끼기 내 안의 사랑 나누기 나의 내면 돌보기 사람과 우선순위 특별한 선물 배우자 또는 연인에게 사랑이 담긴 편지 쓰기 사랑하는 사람을 위한 책 쓰기 깜짝 이벤트 계획하기 나의 시간과 노력 선물하기 어깨의 짐을 떨어주는 선물 ‘고맙습니다’ 선물 무료함이라는 축복 오로지 내가 행복한 시간 만들기 좋은 친구들과 저녁 먹기 의미 있는 추억 만들기 우리 가족만의 새로운 전통 만들기 인터넷 쇼핑 활용하기 오감을 즐겁게 하기 일상 흔들기 제정신을 챙기면서도 아주 특별하게 더 많이 웃기 드라이브 나가기 잠시 혼자 있는 시간 즐기기 부모님께 감사드리기 운전 중에 목청껏 노래 부르기 기도의 힘","categories":[{"name":"Blog","slug":"Blog","permalink":"http://jacegem.github.io/blog/categories/Blog/"},{"name":"Book","slug":"Blog/Book","permalink":"http://jacegem.github.io/blog/categories/Blog/Book/"}],"tags":[{"name":"삶","slug":"삶","permalink":"http://jacegem.github.io/blog/tags/%EC%82%B6/"},{"name":"52주","slug":"52주","permalink":"http://jacegem.github.io/blog/tags/52%EC%A3%BC/"},{"name":"기록","slug":"기록","permalink":"http://jacegem.github.io/blog/tags/%EA%B8%B0%EB%A1%9D/"}]},{"title":"정규표현식 문제 - regexone.com","slug":"2019/정규표현식-문제","date":"2019-01-29T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2019/정규표현식-문제/","link":"","permalink":"http://jacegem.github.io/blog/2019/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EB%AC%B8%EC%A0%9C/","excerpt":"","text":"정규표현식 문제 - regexone.com Problems Problem 1: Matching a decimal numbers 언뜻보기에 숫자와 일치하는 정규식을 작성하는 것이 쉽지 않을까요? 우리는 어떤 숫자와도 일치하는 \\d 특수 문자를 가지고 있으며 소수점과 일치해야합니다. 단순한 숫자의 경우, 맞을 수도 있지만 과학적 또는 재무적인 숫자로 작업 할 때는 종종 양수 및 음수, 유효 숫자, 지수 및 다른 표현 (예 : 수천 및 수백만을 구분하는 데 사용되는 쉼표)을 처리해야 합니다. 다음은 몇 가지 다른 형식의 숫자입니다. 점 메타 문자를 사용하여 임의의 문자가 아닌 소수점 자체를 어떻게 일치시켜야하는지 주목하십시오. 마지막 번호를 건너 뛰는 데 문제가 있는 경우 나머지 숫자와 비교하여 줄 번호가 어떻게 끝나는지 확인하십시오. 1\\d$ 1-?[\\d\\.,e]+$ Problem 2: Matching phone numbers 전화 번호 확인은 받는 입력 유형에 따라 다른 까다로운 작업입니다. 사람들이 전화 번호를 입력 할 때 지역 번호가 필요한 전화 번호나 외부 번호가 필요한 국제 전화 번호를 사용하면 정규 표현식을 복잡하게 만듭니다.(예를 들어 일부는 대시 또는 공백을 넣음) 다음은 실제 데이터를 사용할 때 발생할 수있는 몇 가지 전화 번호입니다. 숫자와 일치하는 단일 정규 표현식을 작성하고 적절한 지역 코드를 캡처합니다. 1(\\d&#123;3&#125;) Problem 3: Matching emails HTML 양식을 처리 할 때 정규 표현식에 대해 양식 입력의 유효성을 검사하는 것이 유용한 경우가 많습니다. 특히 전자 메일은 사양의 복잡성으로 인해 정확하게 일치하기 어렵기 때문에 직접 작성하는 대신 내장된 언어 또는 프레임워크 기능을 사용하는 것이 좋습니다. 그러나 지금까지 배운 것을 사용하여 많은 수의 일반적인 전자 메일과 쉽게 일치하는 매우 견고한 정규식을 작성할 수 있습니다. 주의해야 할 점 중 하나는 많은 사람들이 plus 주소를 사용하는 것입니다. &quot;name@gmail.com&quot;으로 직접 연결되지만 추가 정보로 필터링 할 수 있는 &quot;name+filter@gmail.com&quot;과 같이 추가정보를 제공합니다. 또한 일부 도메인에는 둘 이상의 구성 요소가 있습니다. 예를 들어, &quot;hellokitty.hk.com&quot;에 도메인을 등록하고 &quot;ilove@hellokitty.hk.com&quot;형식의 전자 메일을 받을 수 있습니다. 전자 메일의 도메인 부분과 일치 할 때 주의하십시오. 다음은 몇 가지 일반적인 전자 메일입니다.이 예에서는 필터 (+ 문자 이상)와 도메인 (@ 문자 이상)을 제외하고 전자 메일의 이름을 캡처하려고합니다. 1([^@+]+) Problem 4: Matching HTML HTML을 구문 분석하기 위한 강력한 방법을 찾고 있다면 정규식은 오늘날 인터넷에서 HTML 페이지의 취약성으로 인해 일반적으로 해답이 아닙니다. 예를 들어 끝 태그 누락, 불일치 태그, 속성 인용 부호 닫기 잊음과 같은 일반적인 실수는 모두 완벽하게 좋은 정규 표현식을 탈선 시킵니다. 대신 Beautiful Soup 또는 html5lib (Python) 또는 phpQuery (PHP)와 같은 라이브러리를 사용할 수 있습니다. 이 라이브러리는 HTML을 구문 분석 할 뿐만 아니라 DOM으로 쉽게 이동할 수 있습니다. 즉, 편집기에서 태그와 태그 컨텐츠를 신속하게 일치시키려는 경우가 종종 있으며, 입력을 보증 할 수 있는 경우 정규 표현식을 사용하여 이를 수행 할 수 있습니다. 아래 예제에서 볼 수 있듯이 따옴표 및 중첩 태그가 추가로 이스케이프 된 이상한 속성에 주의해야 할 수도 있습니다. 다음 예제에 대한 정규 표현식을 작성하십시오. 1&lt;(\\w+)\\b Problem 5: Matching specific filenames Linux 나 명령 행을 자주 사용하는 경우, 종종 파일 목록을 처리합니다. 대부분의 파일에는 확장명과 함께 파일 이름 구성 요소가 있지만 Linux에서는 파일 이름이 없는 숨김 파일을 갖는 것이 일반적입니다. 이 간단한 예제에서는 이미지 파일(현재 편집중인 이미지의 임시 파일 제외)에서 파일 이름과 확장명 유형을 추출합니다. 이미지 파일은 .jpg, .png 및 .gif로 정의됩니다. 1(\\w+)\\.(jpg|png|gif)$ Problem 6: Trimming whitespace from start and end of line 경우에 따라 라인의 들여쓰기가 너무 많거나 충분하지 않은 잘못된 형식의 공백이 있는 로그 파일을 발견하게 됩니다. 이 문제를 해결하는 한 가지 방법은 여분의 공백없이 행의 내용을 추출하기 위해 편집기의 검색 대체 및 정규 표현식을 사용하는 것입니다. 이전에 hat ^ 및 달러 기호 $를 사용하여 전체 텍스트 줄을 일치시키는 방법을 살펴 보았습니다. 공백 문자 \\s와 함께 사용하면 앞뒤 공백을 모두 건너 뛸 수 있습니다. 추가 공백없이 각 행의 내용을 캡처하는 간단한 정규 표현식을 작성하십시오. 1^\\s*(.*)$ Problem 7: Extracting information from a log file 이 예제에서는 Android adb 디버깅 세션의 실제 출력을 사용하려고 합니다. 목표는 스택 트레이스의 파일 이름, 메소드 이름 및 라인 번호를 추출하기 위해 지금까지 배웠던 정규 표현식 기술을 사용하는 것입니다 (&quot;at package.class.methodname(filename:linenumber)&quot;형식을 따릅니다). 행운을 빕니다! 1\\.(\\w+)\\((\\w+\\.\\w+):(\\d+) Problem 8: Parsing and extracting data from a URL 네트워크를 통해 파일과 리소스를 사용하여 작업 할 때 URI와 URL을 자주 접할 수 있습니다.이 URI는 파싱되어 직접 작업 할 수 있습니다. 대부분의 표준 라이브러리에는 이러한 종류의 식별자를 구문 분석하고 구성하는 클래스가 있지만 로그나 더 큰 텍스트의 코퍼스와 일치해야하는 경우 정규 표현식을 사용하여 구조화 된 형식의 정보를 아주 쉽게 추출 할 수 있습니다. URI 또는 ​​URI(Uniform Resource Identifier)는 일반적으로 아래에 강조 표시된 구성표, 호스트, 포트 (선택 사항) 및 리소스 경로로 일반적으로 구성된 리소스를 나타냅니다. http://regexone.com:80/page 이 체계는 통신 프로토콜, 호스트 및 포트가 자원의 소스를 설명하며 전체 경로는 자원의 소스 위치를 설명합니다. 아래 연습에서 나열된 모든 리소스의 프로토콜, 호스트 및 포트를 추출하십시오. 1(\\w+)://([\\w\\.-]+):?(\\d+)?","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"General","slug":"Programming/General","permalink":"http://jacegem.github.io/blog/categories/Programming/General/"}],"tags":[{"name":"정규표현식","slug":"정규표현식","permalink":"http://jacegem.github.io/blog/tags/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"문제","slug":"문제","permalink":"http://jacegem.github.io/blog/tags/%EB%AC%B8%EC%A0%9C/"},{"name":"regexone","slug":"regexone","permalink":"http://jacegem.github.io/blog/tags/regexone/"}]},{"title":"정규표현식 연습 - regexone.com","slug":"2019/정규표현식-연습","date":"2019-01-28T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2019/정규표현식-연습/","link":"","permalink":"http://jacegem.github.io/blog/2019/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EC%97%B0%EC%8A%B5/","excerpt":"","text":"정규표현식 연습 - regexone.com Lesson Lesson 1: An Introduction, and the ABCs 정규식은 코드, 로그 파일, 스프레드 시트 또는 문서와 같은 텍스트에서 정보를 추출하는데 매우 유용합니다. 공식 언어에는 많은 이론이 있지만 다음 강의와 예제에서는 정규 표현식을 보다 실용적인 방식으로 사용하여 가능한 한 빨리 사용할 수 있도록 합니다. 정규 표현식을 사용할 때 가장 먼저 알아야 할 것은 모든 것이 본질적으로 문자이며 우리는 특정 문자 시퀀스 (문자열이라고도 함)와 일치하는 패턴을 작성하고 있습니다. 대부분의 패턴은 문자, 숫자, 구두점 및 기타 기호를 % # $ @ !와 같이 키보드에 포함하는 일반 ASCII를 사용하지만 유니 코드 문자는 모든 유형의 국제 텍스트와 일치시키는 데에도 사용할 수 있습니다. 다음은 몇 줄의 텍스트입니다. 아래 입력 필드에 입력 할 때 각 줄의 일치하는 문자를 강조 표시하기 위해 텍스트가 어떻게 변경되는지 확인하십시오. 다음 단원을 계속 진행하려면 각 단원에 소개 된 새로운 구문과 개념을 사용하여 제공되는 모든 줄과 일치하는 패턴을 작성해야 합니다. 3행 모두와 일치하는 패턴을 작성해보십시오. 각 행의 일반 문자만큼 간단 할 수 있습니다. 1abc Lesson 1½: The 123s 문자에는 일반 문자가 포함되지만 숫자도 포함됩니다. 실제로 숫자 0-9는 문자이기도하며 ASCII 테이블을 보면 순차적으로 나열됩니다. 다양한 레슨을 통해 정규 표현식에 사용되는 특정 유형의 문자를 일치시키는 데 사용할 수있는 여러 가지 특수 메타 문자가 소개됩니다. 이 경우 문자 \\d는 0에서 9 사이의 임의의 숫자 대신 사용할 수 있습니다. 앞의 슬래시는 간단한 d 문자와 구별되며 문자가 메타 문자임을 나타냅니다. 다음은 숫자가 포함 된 몇 줄의 텍스트입니다. 아래 문자열의 모든 숫자와 일치하는 패턴을 작성하고 첫 번째 문자에서 시작하는 것뿐만 아니라 문자열 내 어디에서나 패턴이 일치하는지 확인하십시오. 우리는 이후 학습에서 이것을 어떻게 제어하는지 배울 것입니다. 1\\d Lesson 2: The Dot 일부 카드 게임에서 조커는 와일드 카드이며 갑판의 모든 카드를 나타낼 수 있습니다. 정규식을 사용하면 공통된 패턴이나 구조 (예 : 전화 번호 또는 우편 번호)를 공유하는 것 이외에 정확한 내용을 모르는 텍스트 조각과 일치하는 경우가 많습니다. 마찬가지로 와일드 카드라는 개념이 있는데 이는 와일드 카드로 표현됩니다. (점) 메타 문자를 사용하고 단일 문자 (문자, 숫자, 공백, 모든 것)와 일치시킬 수 있습니다. 이것은 실제로 마침표 문자의 일치를 무시하므로 마침표와 특별히 일치 시키려면 점을 슬래시 \\로 이스케이프 처리해야합니다. 아래에는 다양한 문자가 있지만 길이가 같은 몇 개의 문자열이 있습니다. 처음 세 문자열은 일치 할 수 있지만 마지막은 건너 뛸 수 없는 단일 패턴을 작성하십시오. 일부 줄의 마침표와 일치하도록 점 메타 문자를 이스케이프 처리해야 할 수도 있습니다. 1.+\\. Lesson 3: Matching specific characters 마지막 레슨의 점 메타 문자는 매우 강력하지만 때로는 너무 강력합니다. 예를 들어 전화 번호와 일치하는 경우 &quot;(abc) def-ghij&quot;문자를 유효한 숫자로 확인하고 싶지 않습니다! 정규 표현식을 사용하여 특정 문자를 대괄호 안에 정의하여 일치시키는 방법이 있습니다. 예를 들어 [abc] 패턴은 단일 a, b 또는 c 문자와 만 일치하고 다른 문자는 일치하지 않습니다. 다음은 처음 세 개의 문자열만 일치시키고 마지막 세 개의 문자열은 일치시키지 않는 몇 줄입니다. .를 사용하는 경우 마지막 세 문자열의 일치를 피할 수는 없지만 위의 표기법을 사용하여 일치시킬 문자를 구체적으로 정의해야합니다. 1[cmf]an Lesson 4: Excluding specific characters 경우에 따라 일치하지 않는 특정 문자가 있음을 알 수 있습니다. 예를 들어, 지역번호가 650이 아닌 전화 번호만 일치시킬 수 있습니다. 이를 나타 내기 위해 대괄호와 ^(hat)를 사용하여 특정 문자를 제외하는 표현식을 사용합니다. 예를 들어 [^abc] 패턴은 문자 a, b 또는 c를 제외한 모든 단일 문자와 일치합니다. 아래 문자열을 사용하여 살아있는 동물(hog, dog, but not bog)만 일치시키는 패턴을 작성하십시오. 이 유형의 대부분의 패턴이 동일한 동전의 실제 양면이기 때문에 마지막 수업의 기법을 사용하여 작성 될 수 있습니다. 두 가지 선택을 가짐으로써 자신의 패턴을 작성할 때 작성하고 이해하기 쉬운 것을 결정할 수 있습니다. 1[^b]og Lesson 5: Character ranges 우리는 방금 특정 문자와 일치하거나 제외하는 패턴을 만드는 방법을 배웠습니다. 그러나 연속 범위 문자가 될 수있는 문자를 일치 시키려면 어떻게해야합니까? 우리 모두를 나열 할 수 밖에 없을까요? 다행히도 대괄호 표기법을 사용하는 경우 대시를 사용하여 문자 범위를 나타내는 순차 문자 목록에서 문자를 일치시킬 수 있습니다. 예를 들어, 패턴 [0-6]은 0에서 6까지의 임의의 한 자리 문자에만 일치하며 그 밖의 것은 일치하지 않습니다. 마찬가지로 [^n-p]는 n에서 p까지의 문자를 제외하고는 하나의 문자만 일치시킵니다. 여러 문자 범위는 개별 문자와 함께 동일한 대괄호 세트에서 사용될 수 있습니다. 예를 들어 문자 범위 [A-Za-z0-9_]와 동등한 \\w 메타 문자가 있으며 영어 텍스트의 문자를 일치시키는 데 자주 사용됩니다. 아래 연습에서는 모든 일치 및 건너뛰기 패턴을 확인하고 괄호 표기법을 사용하여 각 줄의 각 문자를 일치 시키거나 건너 뜁니다. 패턴은 대소문자를 구분하며 a-z는 A-Z와 문자가 다르다는 점에 유의하십시오 (대문자 vs 소문자). 1;[A - Z] Lesson 6: Catching some zzz’s 참고 : 아래의 반복 구문 중 일부는 모든 정규 표현식 구현에서 지원되지 않습니다. 우리는 지금까지 일치시키고 자하는 문자의 범위를 지정하는 방법을 배웠습니다. 그러나 일치시키고자 하는 문자의 반복 횟수는 어떻게 할까요? 우리가 할 수있는 한 가지 방법은 명시적으로 얼마나 많은 문자가 필요한지 정확하게 명시하는 것입니다. \\d\\d\\d는 정확히 3 자리와 일치합니다. 보다 편리한 방법은 중괄호 표기법을 사용하여 원하는 각 문자의 반복 횟수를 지정하는 것입니다. 예를 들어, &#123;3&#125;은 한 문자를 정확히 3 번 일치시킵니다. 특정 정규식 엔진은 이 반복에 대한 범위를 지정하여 &#123;1,3&#125;이 한 문자이상이며 3회 이하만 일치하도록 허용합니다. 이 한정 기호는 임의의 문자 또는 특수 메타 문자와 함께 사용할 수 있습니다. 예를 들어 w&#123;3&#125; (3 개의 w), [wxy]&#123;5&#125; (5 개의 문자 각각 w, x 또는 y가 될 수 있음) 및 .&#123;2,6&#125; (임의의 문자 2-6 사이) 아래의 줄에서 하나의 z만있는 마지막 문자열은 &quot;wazzup&quot;이라는 속어의 철자가 올바른지 생각하지 않습니다. 위의 중괄호 표기법을 사용하여 처음 두 개의 철자와 일치하는 패턴을 작성하십시오. 1z&#123;2,5&#125; Lesson 7: Mr. Kleene, Mr. Kleene 정규 표현식의 강력한 개념은 임의의 수의 문자를 일치시키는 기능입니다. 예를 들어 달러로 숫자 값을 입력하는 기부 필드가 있는 양식을 작성했다고 가정 해보십시오. 부유한 사용자는 2만 5천 달러를 기부하고 일반 사용자는 25 달러를 기부 할 수 있습니다. 그러한 패턴을 표현하는 한 가지 방법은 Kleene Star와 Kleene Plus로 알려진 것을 사용하는 것입니다. Kleene Plus는 본질적으로 0 또는 1 또는 그 이상의 문자를 나타냅니다 (항상 문자 또는 그룹을 따릅니다). 예를 들어, 위의 기부금을 일치 시키려면 \\d* 패턴을 사용하여 임의의 자릿수를 일치시킬 수 있지만 더 엄격한 정규 표현식은 \\d+ 가되어 입력 문자열에 적어도 하나의 숫자가 있어야합니다. 이러한 한정 기호는 임의의 문자 또는 특수 메타 문자 (예 : a+ (하나 이상의 a)), [abc]+ (a, b 또는 c 문자 중 하나 이상) 및 .* (0 개 이상의 문자 ). 다음은 별표와 더하기 메타 문자를 사용하여 일치시킬 수있는 간단한 문자열입니다. 1aa.+ Lesson 8: Characters optional 이전 강의에서 보았 듯이, Kleene 별(*)과 플러스(+)는 반복 된 문자를 한 줄에 일치시킬 수 있게합니다. 텍스트를 매칭하고 추출 할 때 정말로 일반적으로 사용되는 다른 한정 기호는 ?(물음표) 메타 문자입니다. 이 메타 문자를 사용하면 앞의 문자 또는 그룹 중 0 또는 하나를 일치시킬 수 있습니다. 예를 들어, 패턴 ab?c는 b가 선택적으로 간주되기 때문에 &quot;abc&quot;또는 &quot;ac&quot;문자열과 일치합니다. 점 메타 문자와 마찬가지로 물음표는 특수 문자이므로 슬래시를 사용하여 이스케이프 처리해야합니다. 문자열의 일반 물음표 문자와 일치시킵니다. 아래 문자열에서 단어 &quot;파일&quot;의 복수가 발견 된 파일의 수에 따라 어떻게 달라지는 지주의하십시오. 옵션 메타 문자를 사용하는 패턴을 작성하여 하나 이상의 파일이있는 행만 일치 시키십시오. 1\\? Lesson 9: All this whitespace 로그 파일 및 사용자 입력과 같은 실제 입력을 처리 할 때 공백이 발생합니다. 시각적으로 읽기 및 스캔을 쉽게하기 위해 정보의 형식을 지정하는 데 이 정보를 사용하고 단일 공간으로 렌치를 간단한 정규 표현식에 넣을 수 있습니다. 정규 표현식과 함께 사용할 공백의 가장 일반적인 형태는 공백(␣), 탭(\\t), 줄 바꾸기(\\n) 및 캐리지 리턴(\\r) (Windows 환경에서 유용함)이며 특수 문자는 각 공백과 일치합니다. 또한 공백 특수 문자 \\s는 위의 특정 공백과 일치하며 원시 입력 텍스트를 처리 할 때 매우 유용합니다. 아래 문자열에서 각 줄의 내용은 줄의 색인에서 공백으로 약간 들여 쓰는 것을 볼 수 있습니다 (숫자는 일치시킬 텍스트의 일부 입니다). 숫자와 내용 사이의 공백 정도에 관계없이 각 줄을 일치시킬 수 있는 패턴을 작성하십시오. 공백 문자는 다른 문자와 같으며 별과 플러스 같은 특수 메타 문자도 사용할 수 있습니다. 1\\d\\.\\s+\\w+ Lesson 10: Starting and ending 지금까지는 모든 텍스트에서 부분적으로 일치하는 정규식을 작성했습니다. 때로는 바람직하지 않습니다. 예를 들어 로그 파일에서 &quot;success&quot;라는 단어를 일치 시키려고 했습니다. 확실히 그 패턴이 &quot;Error : failed operation&quot;이라는 줄과 일치하는 것을 원하지 않습니다! 따라서 실제 텍스트와 비교할 때 오탐지 (false positives)가 발생하지 않도록 가능한 한 특정 정규 표현식으로 작성하는 것이 가장 좋습니다. 패턴을 강화하는 한 가지 방법은 특수 ^(모자) 및 $(달러 기호) 메타 문자를 사용하여 행의 시작과 끝을 모두 설명하는 패턴을 정의하는 것입니다. 위 예제에서 패턴 &quot;successful&quot;을 사용하여 단어 &quot;successful&quot;으로 시작하는 행만 일치시킬 수 있지만 &quot;오류 : 실패한 조작&quot;행은 일치시키지 않습니다. 모자와 달러 기호를 결합하면 시작과 끝 부분에서 전체 선과 완전히 일치하는 패턴을 만들 수 있습니다. 이것은 정규 표현식을 읽을 때 혼동을 줄 수있는 문자를 제외하기 위해 [^…] 괄호 안에 사용 된 모자와는 다릅니다. 이 새로운 특수 문자를 사용하여 아래의 각 문자열을 일치 시키십시오. 1\\ssuccessful$ Lesson 11: Match groups 정규 표현식을 사용하면 텍스트를 일치시킬 뿐만 아니라 추가 처리를 위해 정보를 추출 할 수 있습니다. 이것은 문자 그룹을 정의하고 특수 괄호 및 메타 문자를 사용하여 문자 그룹을 캡처하여 수행됩니다. 괄호 안에 있는 하위 패턴은 그룹으로 캡처됩니다. 실제로 이것은 모든 종류의 데이터에서 전화번호나 전자 메일과 같은 정보를 추출하는 데 사용할 수 있습니다. 예를 들어 클라우드에있는 모든 이미지 파일을 나열하는 명령 줄 도구가 있다고 상상해보십시오. 그런 다음 ^(IMG\\d+\\.png)$와 같은 패턴을 사용하여 전체 파일 이름을 캡처하고 추출 할 수 있지만 확장자없이 파일 이름 만 캡처하려는 경우 ^(IMG\\d+) 패턴을 사용할 수 있습니다. \\.png$는 기간 이전에 부분 만 캡처합니다. 앞으로이 파일을 사용하여 아래 PDF 파일의 파일 이름 (확장명 제외)과 일치하는 정규 표현식을 작성하십시오. 1(\\w+).pdf$ Lesson 12: Nested groups 복잡한 데이터로 작업 할 때 여러 계층의 정보를 추출해야하는 것을 쉽게 발견 할 수 있으므로 중첩 된 그룹이 될 수 있습니다. 일반적으로 캡처 된 그룹의 결과는 정의 된 순서대로 나타납니다 (순서대로 괄호로 묶음). 이전 수업에서 보여준 예제를 사용하면 목록에있는 모든 이미지 파일의 파일 이름을 캡처 할 수 있습니다. 이러한 이미지 파일 각각에 파일 이름에 순차적 인 그림 번호가있는 경우 동일한 패턴을 사용하여 ^(IMG(\\d+))\\.png$와 같은 표현식을 작성하여 파일 이름과 그림 번호를 모두 추출 할 수 있습니다 (중첩 자리를 캡처하는 괄호). 중첩 된 그룹은 패턴에서 왼쪽에서 오른쪽으로 읽히고 첫 번째 캡처 그룹은 첫 번째 괄호 그룹의 내용이 됩니다. 다음 문자열의 경우 날짜의 전체 날짜와 연도를 일치시키고 캡처하는 식을 작성하십시오. 1((\\w+) (\\d+)) Lesson 13: More group work 이전 수업에서 보았듯이 별 *, 더하기 +, 반복 &#123;m, n&#125;을 비롯한 모든 수량 기호와 물음표가 모두 캡처 그룹 패턴 내에서 사용할 수 있습니다. 이 방법은 개별 문자 자체 대신 문자 시퀀스에 수량 기호를 적용하는 유일한 방법입니다. 예를 들어 전화 번호에 지역 번호가 포함되어 있거나 없을 수도 있다는 것을 알고 있다면 올바른 패턴은 전체 숫자 그룹 (\\d&#123;3&#125;)의 존재 여부를 테스트합니다. 개별 문자 자체가 아닙니다 (잘못된 것입니다). 사용중인 정규 표현식 엔진에 따라 그룹을 일치시킬 수도 있지만 결과에 나타나지 않는 비 캡처 그룹을 사용할 수도 있습니다. 다음은 몇 가지 일반적인 디스플레이 해상도입니다. 각 디스플레이의 너비와 높이를 캡처하십시오. 1(\\d&#123;4&#125;)x(\\d&#123;3,4&#125;) Lesson 14: It’s all conditional 앞에서 언급했듯이 코딩은 항상 정확해야하며 코딩, 말하기, 정규 표현식에도 적용됩니다. 예를 들어, 다른 사람이 더 많은 것을 사기위한 식료품 목록을 작성하지 않을 것입니다. 대신에 더 많은 우유를 사거나 빵을 더 사야한다고 쓰면 정규 표현식에서 이러한 조건부를 명시 적으로 정의 할 수 있습니다. 특히 그룹을 사용할 때 | (논리적 OR, 일명 파이프) 다른 가능한 문자 집합을 나타냅니다. 위의 예에서, 문자열만 일치시키기 위해 &quot;Buy more (milk|bread|juice)&quot;패턴을 작성하여 더 많은 우유를 사거나, 빵을 더 구입하거나, 더 많은 주스를 구입할 수 있습니다. 일반 그룹과 마찬가지로 조건에서 문자 또는 메타 문자 시퀀스를 사용할 수 있습니다. 예를 들어 ([cb]ats*|[dh]ogs?)는 고양이 또는 박쥐 또는 개 또는 돼지와 일치합니다. 많은 조건을 가진 패턴을 쓰는 것은 읽기가 어려울 수 있으므로 너무 복잡한 경우 패턴을 개별적으로 만드는 것을 고려해야합니다. 아래의 작은 생물이 있는 라인만 일치시키는 조건부 패턴을 작성해보십시오. 1(cats|dogs) Lesson 15: Other special characters 이 강의에서는 캡처 된 그룹의 결과 뿐만 아니라 일부 추가 메타 문자를 다룹니다. \\d를 사용하여 숫자를 캡처하는 가장 일반적인 메타 문자 및 \\w를 사용하여 영숫자와 숫자를 배웠지만 정규 표현식은 대문자를 사용하여 각 메타 문자의 반대 세트를 지정하는 방법을 제공합니다 소문자. 예를 들어 \\D는 임의의 비 숫자 문자, \\S 임의의 비 공백 문자 및 \\W 영숫자가 아닌 임의의 문자 (예 : 구두점)를 나타냅니다. 정규식 작성 방법에 따라 둘 중 하나를 사용하는 것이 더 쉬울 수도 있습니다. 또한 단어와 단어가 아닌 문자의 경계를 일치시키는 특수 메타 문자 \\b가 있습니다. 전체 단어를 캡처하는 데 가장 유용합니다 (예 : \\w+\\b 패턴 사용). 이 레슨에서 자세히 살펴 보지 않을 개념 중 하나는 역 참조입니다. 이는 주로 구현에 따라 달라지기 때문입니다. 그러나 대부분의 시스템에서는 \\0 (일반적으로 전체 일치 텍스트), \\1 (그룹 1), \\2 (그룹 2) 등을 사용하여 캡처 된 그룹을 참조 할 수 있습니다. 예를 들어 텍스트를 사용할 때 유용합니다. 편집기를 사용하고 검색을 수행하고 정규 표현식을 사용하여 두 개의 숫자를 바꾼다면 &quot;(\\d+) - (\\d+)&quot;를 검색하고 &quot;\\2 - \\1&quot;로 바꿀 수 있습니다. 아래에 여러 문자열이 있습니다. 다른 유형의 메타 문자나 이전 학습에서 배운 내용을 시험해보고 준비가 되면 계속하십시오. 1.*","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"General","slug":"Programming/General","permalink":"http://jacegem.github.io/blog/categories/Programming/General/"}],"tags":[{"name":"정규표현식","slug":"정규표현식","permalink":"http://jacegem.github.io/blog/tags/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"regexone","slug":"regexone","permalink":"http://jacegem.github.io/blog/tags/regexone/"},{"name":"연습","slug":"연습","permalink":"http://jacegem.github.io/blog/tags/%EC%97%B0%EC%8A%B5/"}]},{"title":"AWS Community Day 참관 사진","slug":"2019/AWS-Community-Day-참관-사진","date":"2019-01-24T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2019/AWS-Community-Day-참관-사진/","link":"","permalink":"http://jacegem.github.io/blog/2019/AWS-Community-Day-%EC%B0%B8%EA%B4%80-%EC%82%AC%EC%A7%84/","excerpt":"","text":"AWS Community Day 참관 사진 2019년 1월 25일(금) 오후 1시~6시 세종대 컨벤션 광개토홀에서 진행되었습니다. 세부일정은 이곳에서 확인할 수 있습니다. 인사말 AWS re:Invent 2018를 통해 본 개발자들이 원하는 4가지 클라우드 동향 컴퓨팅 - 다양한 선택의 폭과 낮은 개발 비용 요구사항에 맞는 데이터베이스 선택의 자유 좀 더 자동 및 실용적 AI 플랫폼 제공 미래 산업에 대한 진입 창벽 철폐 AWS 서비스 특징 및 트렌드 PRIMITIVES FULLY-MANAGED SERVERLESS AWS 서비스 특징 및 트렌드 점점 Serverless 쪽으로 이동하고 있다. 마이크로 서비스를 위한 다양한 컨테이너 선택 옵션 제공 사용자 요구에 따라 다양한 옵션을 제공한다. 서버리스 및 컨테이너 구현을 위한 두가지 접근법 Firecracker 아키텍처 및 이점 Firecracker 마이크로 VM은 KVM과 동일한 보안 기능 제공 불필요한 기능을 줄이고 빠른 시작 시간을 위해 설계 컨테이너 및 람다 함수 최적화로 125ms 이내 초당 150개 부터 수 천개까지 동시에 VM 생성 가능 다양한 데이터베이스 선택 옵션 제공 진정한 데이터베이스 자유를 위한 시점 도래 모든 개발자를 위한 인공 지능 도구 제공 Amazon SageMaker - 손쉬운 기계 학습 모델 생성, 훈련 및 서비스 배포 완전 관리 서비스 인공지능/딥러닝 세션을 들었는데, 거의 SageMaker에 대한 이야기였습니다. Amazon SageMaker Ground Truth Amazon SageMaker RL AWS RoboMaker - 지능형 어플리케이션 손쉽게 개발, 테스트 및 배포 서비스 AWS Ground Station - 우주 산업 서비스 딥러닝@EDM페스티발, 누가누가 잘노나? AWS DeepLens 소개 Amazon SageMaker 소개 딥렌즈 아키텍처 구성도 결과 데이터 라벨링 노가다는 이제 그만 Amazon SageMaker Ground Truth 머신러닝과 Amazon SageMaker 데이터와 라벨링 작업 Amazon Sagemaker Ground Truth 소개 Amazon Sagemaker Ground Truth 속의 데이터과학 머신러닝과 Amazon Sagemaker Build 사전에 빌드된 Jupyter 노트북 인스턴스 Tensorflow, mxnet, Pytorch, Glueon 등 머신러닝을 위한 환경 구성되어 있음 최적화된 머신러닝 알고리즘 제공 자신만의 환경 셋업도 가능 Train 학습을 위한 클러스터 구성 및 관리 여러 인스턴스를 사용할 수 있는 분산 학습 알고리즘 대용량 데이터를 수용할 수 있는 확장성 구조 모델 결과물에 대한 보안 Tune 하이퍼파라미터 최적화 작업 단순화 최적화 작업 병렬처리 기존에 값들을 조정해가며 반복적으로 변경의 효과를 관찰하는 시간과 비용 절감 Deploy 추론을 위한 인스턴스 구성 및 관리 확장성 있는 추론 API 모델 버져닝과 성능추적 엔지니어링 노력이 필요없는 손쉬운 배포 왜 라벨링 작업은 힘들까? 사람이 이미지에서 색상을 분류하는 것은 쉽다. 사람이 수천/수만장의 이미지의 색상을 분류하는 것은 어렵다. AWSKRUG Hands-on Lab 2018 - 색상분류모델 만들기 https://github.com/yansonz/2018-handson-data-02 그럼에도 불구하고 왜 라벨링 작업은 중요할까? 좋은 ML모델이 좋은 결과를 이끄는 만큼 좋은 학습 데이터가 좋은 결과를 만든다. Imagenet: 14M 이미지, 22K 카테고리 Microsoft COCO: 33K 이미지, 80 카테고리 MNIST: 70K 이미지, 10 카테고리 Open Images Datasets: 9M URL 이미지, 5K 카테고리 CIFAR-10: 60K 이미지, 10 카테고리 Fashion-MNIST: 70K 이미지, 10 카테고리 자신의 비지니스 문제를 ML로 해결하기 위해서는 데이터셋을 만드는 때가 온다. 가능한 라벨링 작업 Active Learning 과 Auto Data Labeling 아직 서울 리전에 없습니다. Labeling Consolidation: Probabilities SageMaker로 강화학습(RL) 마스터링 목차 강화학습(Reinforcement Learning) SageMaker RL Demo - SageMaker RL &amp; Auto Scaling DeepRacer Amazon SageMaker Build 학습 데이터 수집 및 준비 데이터 라벨링 및 일반적인 문제를 위한 기본 노트북 최적화된 머신러닝 알고리즘 제공 모델 및 알고리즘 마켓 플레이스, 고성능 알고리즘 내장 Train 학습을 위한 클러스터 구성 및 관리 고성능 인프라에서 원클릭 학습 모델 학습 및 튜닝 한 번의 학습을 통해 어디서나 실행, 모델 최적화 Deploy 프로덕션 환경에 모델 배포 확장성 있는 추론 API 모델 버져닝과 성능추적 엔지니어링 노려이 필요없는 손쉬운 배포 최신 알고리즘을 사용한 RL 모델 훈련 시뮬레이션 환경 통합 Example: Auto Scaling 목표: 적절한 Scale up &amp; out 을 통해 트랜잭션 손실과 비용낭비를 최소화 Environment: 로드프로필 &amp; 인스턴스 Action: 인스턴스 추가/제거 State: (인스턴스 용량, 실패한 트랜잭션) Reward: R(인스턴스 용량, 실패한 트랜잭션)","categories":[{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"AWS","slug":"Conference/AWS","permalink":"http://jacegem.github.io/blog/categories/Conference/AWS/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"http://jacegem.github.io/blog/tags/AWS/"},{"name":"Community","slug":"Community","permalink":"http://jacegem.github.io/blog/tags/Community/"},{"name":"Day","slug":"Day","permalink":"http://jacegem.github.io/blog/tags/Day/"},{"name":"참관","slug":"참관","permalink":"http://jacegem.github.io/blog/tags/%EC%B0%B8%EA%B4%80/"}]},{"title":"텐트와 나무","slug":"2019/텐트와-나무","date":"2019-01-21T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2019/텐트와-나무/","link":"","permalink":"http://jacegem.github.io/blog/2019/%ED%85%90%ED%8A%B8%EC%99%80-%EB%82%98%EB%AC%B4/","excerpt":"","text":"텐트와 나무 나무가 펼쳐져 있고, 그 옆에 있는 텐트를 찾아내는 게임입니다. 9x9 [A] 13번째 퍼즐을 진행합니다. 게임이 시작되었습니다. 먼저 0으로 되어 있는 줄을 모두 잔디로 변경합니다. 안탑깝게도, 0이 한줄밖에 없네요. 많았으면 좋았을 것을. 다음 텐트가 올수 없는 곳을 잔디로 변경합니다. 텐트는 나무의 바로 옆, 상하좌우에만 올 수 있습니다. 텐트는 텐트의 상하좌우, 대각선에 올 수 없습니다. 텐트가 올 수 없는 곳을 잔디로 변경합니다. 가장 우측 열의 텐트의 수는 3 입니다. 빨간색으로 영역을 표시했습니다. 텐트가 올 수 있는 곳은 1, 2, 3, 4. 네 곳이 있습니다. 1의 경우 2칸이지만, 텐트는 바로 옆에 텐트가 올 수 없기에 1 영역에 하나의 텐트만 올 수 있습니다. 네 곳에 3개의 텐트가 올 수 있습니다. 여기에서 5번을 잔디로 변경할 수 있습니다. 왜냐하면 네 곳에 3개의 텐트가 올 수 있는 경우는 언제나, 2 또는 3을 포함하게 됩니다. 2 또는 3에 텐트가 온다면 대각선 방향인 5 영역에는 텐트가 올 수 없게 되기 때문입니다. 텐트가 올 수 있는 곳을 찾습니다. 표시한 열의 텐트의 수는 3 입니다. 텐트가 올 수 있는 영역 또한 1,2,3 세개 입니다. 그중에서 3영역은 단 한칸이므로, 이 곳에 텐트가 온다는 것을 알 수 있습니다. 잔디 또는 텐트가 올 수 밖에 없는 곳을 찾습니다. 표시한 열의 텐트의 수는 3 입니다. 텐트가 올 수 있는 영역은 1, 2, 3, 4. 네 개 입니다. 텐트 3개가 네 개의 영역에 올 수 있는 경우의 수는 무조건 1또는 2를 포함하게 됩니다. 텐트는 대각선으로 텐트가 올 수 없기 때문에 역시 5 영역에는 잔디가 올 수 밖에 없습니다. 전체 플레이 영상","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Game","slug":"Application/Game","permalink":"http://jacegem.github.io/blog/categories/Application/Game/"}],"tags":[{"name":"게임","slug":"게임","permalink":"http://jacegem.github.io/blog/tags/%EA%B2%8C%EC%9E%84/"},{"name":"텐트","slug":"텐트","permalink":"http://jacegem.github.io/blog/tags/%ED%85%90%ED%8A%B8/"},{"name":"나무","slug":"나무","permalink":"http://jacegem.github.io/blog/tags/%EB%82%98%EB%AC%B4/"},{"name":"퍼즐","slug":"퍼즐","permalink":"http://jacegem.github.io/blog/tags/%ED%8D%BC%EC%A6%90/"}]},{"title":"Vworld 3D Data를 Three.js로 출력하기","slug":"2018/Vworld-3D-Data를-Three.js로-출력하기","date":"2018-10-16T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Vworld-3D-Data를-Three.js로-출력하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/Vworld-3D-Data%EB%A5%BC-Three.js%EB%A1%9C-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/","excerpt":"","text":"Vworld 3D Data를 Three.js로 출력하기 Vworld WebGL기반 3차원 지도 Vworld WebGL기반 3차원 지도 에 접속하시면 아래와 같은 화면을 볼 수 있습니다. 여기서 WebGL 이란 웹 기반의 그래픽 라이브러리 자바스크립트 프로그래밍 언어를 통해서 사용 호환성이 있는 웹 브라우저에서 인터랙티브한 3D 그래픽을 사용할 수 있도록 제공 (출처: 위키피디아) 3D 데이터API 레퍼런스 소개 데이터 API는 브이월드에서 제공하는 다양한 국가공간정보를 외부(기관,기업,개인등)에서 활용할 수 있도록 XML또는 JSON형식으로 데이터를 제공하는 API서비스 입니다. 어떻게 사용해야 하나요? 어떤 데이터가 어떻게 제공 되나요? 3D 데이터API 레퍼런스 키 발급 개발자센터 &gt; 인증키 &gt; 인증키 발급에서 키를 발급 받을 수 있습니다. (로그인 되어 있어야 이용 가능합니다. ) 1234// 발급 받은 키3XE3C10E-82B7-3E7F-AC31-37175F32CDE4 개인 키를 발급 받아서 사용하시기 바랍니다. 레이어 목록 요청 API 출력 결과 각 요소별 정의 데이터 요청 발급받은 키를 사용하여 요청합니다. URL http://xdworld.vworld.kr:8080/XDServer/3DData Version 2.0.0.0 Request GetCapabilites Key 3XE3C10E-82B7-3E7F-AC31-37175F32CDE4 // 요청 URL http://xdworld.vworld.kr:8080/XDServer/3DData?Version=2.0.0.0&amp;Request=GetCapabilities&amp;Key=3XE3C10E-82B7-3E7F-AC31-37175F32CDE4 요청 결과 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;GetCapabilities&gt;&lt;SCRIPT id=&quot;allow-copy_script&quot;&gt;(function agent() &#123; let isUnlockingCached = false const isUnlocking = () =&gt; isUnlockingCached document.addEventListener(&#x27;allow_copy&#x27;, event =&gt; &#123; const &#123; unlock &#125; = event.detail isUnlockingCached = unlock &#125;) const copyEvents = [ &#x27;copy&#x27;, &#x27;cut&#x27;, &#x27;contextmenu&#x27;, &#x27;selectstart&#x27;, &#x27;mousedown&#x27;, &#x27;mouseup&#x27;, &#x27;mousemove&#x27;, &#x27;keydown&#x27;, &#x27;keypress&#x27;, &#x27;keyup&#x27;, ] const rejectOtherHandlers = e =&gt; &#123; if (isUnlocking()) &#123; e.stopPropagation() if (e.stopImmediatePropagation) e.stopImmediatePropagation() &#125; &#125; copyEvents.forEach(evt =&gt; &#123; document.documentElement.addEventListener(evt, rejectOtherHandlers, &#123; capture: true, &#125;) &#125;) &#125;)()&lt;/SCRIPT&gt;&lt;Version&gt;2.0.0.0&lt;/Version&gt;&lt;Layers Count=&quot;77&quot;&gt;&lt;Layer Name=&quot;tile&quot; Type=&quot;terrainImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;dem&quot; Type=&quot;terrainDEM&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;2015&quot; Type=&quot;time&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;2016&quot; Type=&quot;time&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;2017&quot; Type=&quot;time&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;2018&quot; Type=&quot;time&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;tile_mo&quot; Type=&quot;terrainImg_MO&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;18&quot;/&gt;&lt;Layer Name=&quot;tile_mo_2015&quot; Type=&quot;terrainImg_2015&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;18&quot;/&gt;&lt;Layer Name=&quot;tile_mo_HD&quot; Type=&quot;terrainImg_MO_HD&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;18&quot;/&gt;&lt;Layer Name=&quot;tile_mo2d&quot; Type=&quot;terrainImg_MO2D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;tile_mo2d_HD&quot; Type=&quot;terrainImg_MO2DHD&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;dem_mo&quot; Type=&quot;terrainDEM_MO&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;indoor_build&quot; Type=&quot;Indoor&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;indoor_build_HD&quot; Type=&quot;Indoor&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_build_boan&quot; Type=&quot;boan1&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_bridge_boan&quot; Type=&quot;boan1&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_build_lod1&quot; Type=&quot;boan1&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;hybrid_2017&quot; Type=&quot;boan2&quot; MinLevel=&quot;5&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_build&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_build_world&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_build_world_mo&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_bridge&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;facility_dokdo&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;13&quot;/&gt;&lt;Layer Name=&quot;facility_build_at&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_build_mo&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_dokdo_mo&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;13&quot;/&gt;&lt;Layer Name=&quot;facility_bridge_mo&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;facility_bridge_ag&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;facility_build_ag&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_bridge_ag_mo&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;facility_build_ag_mo&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_indoor&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;facility_olympic2018&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;tile_bridge_mo&quot; Type=&quot;terrainImg_wgt&quot; MinLevel=&quot;10&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;tile_build_mo&quot; Type=&quot;terrainImg_wgt&quot; MinLevel=&quot;10&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;poi_base&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;poi_base_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;poi_base_north&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_base_world&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_bound&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;11&quot;/&gt;&lt;Layer Name=&quot;poi_bound_north&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;8&quot;/&gt;&lt;Layer Name=&quot;poi_bound_world&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;7&quot;/&gt;&lt;Layer Name=&quot;poi_road&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_road_north&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_em_base&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;poi_em_bound&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;12&quot;/&gt;&lt;Layer Name=&quot;poi_em_dept&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;7&quot;/&gt;&lt;Layer Name=&quot;poi_em_dokdo&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;poi_em_embassy&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;6&quot;/&gt;&lt;Layer Name=&quot;poi_em_issue&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;4&quot;/&gt;&lt;Layer Name=&quot;poi_em_korea&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;4&quot;/&gt;&lt;Layer Name=&quot;poi_em_park&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;4&quot;/&gt;&lt;Layer Name=&quot;poi_em_whc&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;4&quot;/&gt;&lt;Layer Name=&quot;poi_base_north_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_base_world_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_bound_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;11&quot;/&gt;&lt;Layer Name=&quot;poi_bound_north_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;8&quot;/&gt;&lt;Layer Name=&quot;poi_bound_world_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;7&quot;/&gt;&lt;Layer Name=&quot;poi_road_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_road_north_u8&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;poi_indoor&quot; Type=&quot;Point3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;hybrid_road&quot; Type=&quot;HybridImg&quot; MinLevel=&quot;5&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;hybrid_bound&quot; Type=&quot;HybridImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;hybrid_add_sansatai&quot; Type=&quot;HybridImg&quot; MinLevel=&quot;5&quot; MaxLevel=&quot;14&quot;/&gt;&lt;Layer Name=&quot;hybrid_road_mo&quot; Type=&quot;HybridImg&quot; MinLevel=&quot;5&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;hybrid_silgam&quot; Type=&quot;HybridImg&quot; MinLevel=&quot;5&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;hybrid_2016&quot; Type=&quot;HybridImg&quot; MinLevel=&quot;5&quot; MaxLevel=&quot;15&quot;/&gt;&lt;Layer Name=&quot;bill_Tree&quot; Type=&quot;Billboard3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;timeseries&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T197801&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T198901&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T195001&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T195101&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T195212&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T199601&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T200601&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;16&quot;/&gt;&lt;Layer Name=&quot;T200712&quot; Type=&quot;TimeseriesImg&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;14&quot;/&gt;&lt;/Layers&gt;&lt;/GetCapabilities&gt; 이 중에서 facility_build 를 사용하겠습니다. 1&lt;Layer Name=&quot;facility_build&quot; Type=&quot;Real3D&quot; MinLevel=&quot;0&quot; MaxLevel=&quot;15&quot;/&gt; 데이터 검색 요청 API(GetLayerExists) 요청 변수 출력결과 각 요소별 정의 데이터 요청 발급받은 키를 사용하여 요청합니다. URL http://xdworld.vworld.kr:8080/XDServer/3DData Version 2.0.0.0 Request GetLayerExists Key 3XE3C10E-82B7-3E7F-AC31-37175F32CDE4 추가 되는 내용들 Layer facility_build Level 15 BBOX 126.976987,37.570187,126.979433,37.574251 CheckFlag True http://xdworld.vworld.kr:8080/XDServer/3DData?Version=2.0.0.0&amp;Request=GetLayerExists&amp;Key=3XE3C10E-82B7-3E7F-AC31-37175F32CDE4&amp;Layer=facility_build&amp;Level=15&amp;BBOX=126.976987,37.570187,126.979433,37.574251&amp;CheckFlag=True 요청 결과 123456789101112131415161718192021222324252627&lt;SearchResult&gt;&lt;Version&gt;2.0.0.0&lt;/Version&gt;&lt;Layer Name=&quot;facility_build&quot;&gt;&lt;Nodes Level=&quot;15&quot; NodeCount=&quot;18&quot;&gt;&lt;Node IDX=&quot;279417&quot; IDY=&quot;116117&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279418&quot; IDY=&quot;116117&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279419&quot; IDY=&quot;116117&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279420&quot; IDY=&quot;116117&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279417&quot; IDY=&quot;116118&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279418&quot; IDY=&quot;116118&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279419&quot; IDY=&quot;116118&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279420&quot; IDY=&quot;116118&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279417&quot; IDY=&quot;116119&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279418&quot; IDY=&quot;116119&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279419&quot; IDY=&quot;116119&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279420&quot; IDY=&quot;116119&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279417&quot; IDY=&quot;116120&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279418&quot; IDY=&quot;116120&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279419&quot; IDY=&quot;116120&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279420&quot; IDY=&quot;116120&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279417&quot; IDY=&quot;116121&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279418&quot; IDY=&quot;116121&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279419&quot; IDY=&quot;116121&quot; Flag=&quot;false&quot;/&gt;&lt;Node IDX=&quot;279420&quot; IDY=&quot;116121&quot; Flag=&quot;false&quot;/&gt;&lt;/Nodes&gt;&lt;/Layer&gt;&lt;/SearchResult&gt; 이 중에서 가장 마지막에 있는 것을 이용해보도록 하겠습니다. 1&lt;Node IDX=&quot;279420&quot; IDY=&quot;116121&quot; Flag=&quot;false&quot;/&gt; 레이어 노드 및 객체 요청 API(GetLayer) 요청 URL 요청 변수 데이터 요청 URL http://xdworld.vworld.kr:8080/XDServer/3DData Version 2.0.0.0 Request GetLayer Key 3XE3C10E-82B7-3E7F-AC31-37175F32CDE4 추가 되는 내용들 Layer facility_build Level 15 IDX 279420 IDY 116121 http://xdworld.vworld.kr:8080/XDServer/3DData?Version=2.0.0.0&amp;Request=GetLayer&amp;Key=3XE3C10E-82B7-3E7F-AC31-37175F32CDE4&amp;Layer=facility_build&amp;Level=15&amp;IDX=279420&amp;IDY=116121 위의 요청을 보내면 3DData 바이너리 파일이 리턴됩니다. 요청 결과 VWorld 3D Map Binary Data File Format을 확인하여 리턴된 바이너리 파일을 분석합니다. Header 정보 Name Size(byte) Type 설명 Level 4 u32 레벨 (0 베이스) IDX 4 u32 경도 ID IDY 4 u32 위도 ID Object Count 4 u32 객체의 총수 Model Object 정보 Name Size(byte) Type 설명 Version 4 u32 객체의 등록 버전 (XDO 파일의 버전정보) Type 1 u8 객체의 타입 (객체의 타입정보 - 8로 고정: 예약됨) KeyLen 1 u8 객체의 키값 크기 Key KeyLen char* 객체의 키값 (객체의 고유 ID 값) CenterPos 16 vector2dd 객체의 중심좌표 (경위도 radian) (Model이 위치 할 공간좌표 경위도값) altitude 4 f32 객체의 고도값 (Model이 위치 할 공간의 해발고도 높이) box 48 aabbox3dd 객체의 바운더리 (구면 Vector) (Model 의 3차원 최대, 최소 공간 영역 좌표 정보) ImgLevel 1 u8 이미지 레벨 (사용되는 LOD 레벨의 수) dataFileLen 1 u8 객체의 파일이름 길이 dataFile dataFileLen char* 객체의 파일이름 (확장자 포함) (Tile 내에 실제 Model의 XDO 파일명) imgFileNameLen 1 u8 이미지 파일이름 길이 imgFileName imgFileNameLen char* 이미지 파일이름 (XDO 파일이 사용하는 Texture 이미지 명) Parsing 1234567891011121314151617181920212223242526272829303132333435363738394041var idx = 279420var idy = 116121var layerUrl = `http://xdworld.vworld.kr:8080/XDServer/3DData?Version=2.0.0.0&amp;Request=GetLayer&amp;Key=3XE3C10E-82B7-3E7F-AC31-37175F32CDE4&amp;Layer=facility_build&amp;Level=15&amp;IDX=$&#123;idx&#125;&amp;IDY=$&#123;idy&#125;`;var promise = $.ajax(&#123; url: layerUrl, dataType: &quot;binary&quot;,&#125;);promise.done(function (data) &#123; var p = new Parser(data); // header _data.level = p.getUint4(); _data.idx = p.getUint4(); _data.idy = p.getUint4(); _data.objectCount = p.getUint4(); // model object _data.version = p.getVersion(); _data.type = p.getUint1(); var lenStr = p.getLenStr(); _data.keyLen = lenStr.len; _data.key = lenStr.str; _data.centerPosX = p.getFloat8(); _data.centerPosY = p.getFloat8(); _data.altitude = p.getFloat4(); _data.box = p.getBox3dd(); _data.imgLevel = p.getUint1(); var lenStr = p.getLenStr(); _data.dataFileLen = lenStr.len; _data.dataFileName = lenStr.str; var lenStr = p.getLenStr(); _data.imgFileLen = lenStr.len; _data.imgFileName = lenStr.str; resolve();&#125;); 이렇게 하면 아래와 같은 정보를 얻을 수 있습니다. 여기서 얻은 파일명을 사용하여 3D data 를 조회합니다. dataFileName : a13_52.xdo imgFileName: a13_52.jpg Parser Class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193$(document).ready(function () &#123; $.ajaxSetup(&#123; beforeSend: function (jqXHR, settings) &#123; if (settings.dataType === &#x27;binary&#x27;) &#123; settings.xhr().responseType = &#x27;blob&#x27;; &#125; &#125; &#125;); $.ajaxTransport(&quot;+binary&quot;, function (options, originalOptions, jqXHR) &#123; if (window.FormData &amp;&amp; ((options.dataType &amp;&amp; (options.dataType == &#x27;binary&#x27;)) || (options.data &amp;&amp; ((window.ArrayBuffer &amp;&amp; options.data instanceof ArrayBuffer) || (window.Blob &amp;&amp; options.data instanceof Blob))))) &#123; return &#123; send: function (headers, callback) &#123; var xhr = new XMLHttpRequest(), url = options.url, type = options.type, async = options.async || true, dataType = options.responseType || &quot;arraybuffer&quot;, data = options.data || null; xhr.addEventListener(&#x27;load&#x27;, function () &#123; var data = &#123;&#125;; data[options.dataType] = xhr.response; callback(xhr.status, xhr.statusText, data, xhr.getAllResponseHeaders()); &#125;); xhr.open(type, url, async); for (var i in headers) &#123; xhr.setRequestHeader(i, headers[i]); &#125; xhr.responseType = dataType; xhr.send(data); &#125;, abort: function () &#123; &#125; &#125;; &#125; &#125;);&#125;);class Parser &#123; constructor(data) &#123; this.dv = new DataView(data); this.endian = true; this.offset = 0; &#125; getUint4() &#123; const val = this.dv.getUint32(this.offset, this.endian); this.offset += 4; return val; &#125; getUint1() &#123; const val = this.dv.getUint8(this.offset, this.endian); this.offset += 1; return val; &#125; getUint2() &#123; const val = this.dv.getUint16(this.offset, this.endian); this.offset += 2; return val; &#125; getLenStr() &#123; const len = this.getUint1(); var str = &quot;&quot;; var val = &quot;&quot;; for (var i = 0; i &lt; len; i++) &#123; val = this.getUint1(); str += String.fromCharCode(val); &#125; return &#123; len: len, str: str, &#125;; &#125; getFloat8() &#123; const val = this.dv.getFloat64(this.offset, this.endian); this.offset += 8; return val; &#125; getFloat4() &#123; const val = this.dv.getFloat32(this.offset, this.endian); this.offset += 4; return val; &#125; getVersion() &#123; const val = `$&#123;this.getUint1()&#125;.$&#123;this.getUint1()&#125;.$&#123;this.getUint1()&#125;.$&#123;this.getUint1()&#125;`; return val; &#125; getBox() &#123; var minX = this.getFloat8(); var maxX = this.getFloat8(); var minY = this.getFloat8(); var maxY = this.getFloat8(); var minZ = this.getFloat8(); var maxZ = this.getFloat8(); return &#123; minX: minX, maxX: maxX, minY: minY, maxY: maxY, minZ: minZ, maxZ: maxZ &#125; &#125; getVector2df() &#123; var x = this.getFloat4(); var y = this.getFloat4(); return &#123; x: x, y: y &#125; &#125; getVector3df() &#123; var x = this.getFloat4(); var y = this.getFloat4(); var z = this.getFloat4(); return &#123; x: x, y: y, z: z &#125; &#125; getVector3dd() &#123; var x = this.getFloat8(); var y = this.getFloat8(); var z = this.getFloat8(); return &#123; x: x, y: y, z: z &#125; &#125; //http://irrlicht.sourceforge.net/docu/structirr_1_1video_1_1_s3_d_vertex.html getCountVert() &#123; const count = this.getUint4(); var vert = []; for (var i = 0; i &lt; count; i++) &#123; const pos = this.getVector3df(); const normal = this.getVector3df(); const uv = this.getVector2df(); vert.push(&#123; pos: pos, normal: normal, uv: uv &#125;) &#125; return &#123; count: count, vert: vert &#125;; &#125; getCountIndex() &#123; const count = this.getUint4(); var index = []; for (var i = 0; i &lt; count; i++) &#123; const val = this.getUint2(); index.push(val) &#125; return &#123; count: count, index: index &#125;; &#125; getBox3dd() &#123; const min = this.getVector3dd(); const max = this.getVector3dd(); return &#123; min: min, max: max &#125; &#125;&#125; 데이터 파일 조회 위에서 얻은 데이터 파일명을 사용하여 조회합니다. URL http://xdworld.vworld.kr:8080/XDServer/3DData Version 2.0.0.0 Request GetLayer Key 3XE3C10E-82B7-3E7F-AC31-37175F32CDE4 Layer facility_build Level 15 IDX 279420 IDY 116121 DataFile a13_52.xdo 요청 URL http://xdworld.vworld.kr:8080/XDServer/3DData?Version=2.0.0.0&amp;Request=GetLayer&amp;Key=3XE3C10E-82B7-3E7F-AC31-37175F32CDE4&amp;Layer=facility_build&amp;Level=15&amp;IDX=279420&amp;IDY=116121&amp;DataFile=a13_112.xdo VWorld 3D Map Binary Data File Format을 확인하여 리턴된 바이너리 파일을 분석합니다. Real3D Model Data (*.xdo) Format 구성 Object Attribute Name Size(byte) Type 설명 Type 1 u8 객체의 타입 (객체의 형식 Real3D Model 은 8 고정으로 사용) Object ID 4 u32 객체의 고유번호 (객체의 고유 ID 식별번호, 레이어 기준으로 객체 등록 번호) KeyLen 1 u8 객체의 키값 길이 Key KeyLen char* 객체의 키값 (객체의 고유 식별 문자열) Object Box 48 aabbox3dd 객체의 범위 (구면 Vector) (객체의 최대 최소 영역 범위, World Wind 구면 Vector 좌표계) Altitude 4 f32 객체의 높이 (객체의 바닥면 기준 해발고도 높이) 3D Mesh Data Name Size (byte) Type 설명 Vertex Count 4 u32 버텍스 총수 Vertex Vertex Count S3DVertex* 버텍스 값 (형상을 구성하는 정규화된 공간 좌표점) Indexed Count 4 u32 인덱스 총수 Indexed Indexed Count u16* 인덱스 값 (Vertex 정점을 삼각형 그릴 시에 그리는 순서 리스트) Color 4 u32 객체색상 (Mesh의 재질의 색상(A8R8G8B8)) ImageLevel 1 byte 이미지 LOD 총 레벨 (LOD 텍스처의 레벨 단계) ImageNameLen 1 byte 텍스쳐 이미지명 길이 imageName ImageNameLen char* 텍스처 이미지명(확장자 제외, jpg) (LOD 텍스처 파일명) index를 확인합니다. vertex 를 확인합니다. V-World 2013 Data Format Schema S3DVertex Name Size(byte) Type 설명 Pos 12 vector3df 버텍스 좌표 Normal 12 vector3df 버텍스 노말 UV 8 vector2df 텍스처 UV aabbox3d Name Size(byte) Type 설명 Min 24 vector3dd 최소 좌표점 Max 24 vector3dd 최대 좌표점 vector2df Name Size(byte) Type 설명 x 4 float x축 값 y 4 float y축 값 vector2dd Name Size(byte) Type 설명 x 8 double x축 값 y 8 double y축 값 vector3df Name Size(byte) Type 설명 x 4 float x축 값 y 4 float y축 값 z 4 float z축 값 vector3dd Name Size(byte) Type 설명 x 8 double x축 값 y 8 double y축 값 z 8 double z축 값 이미지 파일 조회 위에서 얻은 이미지 파일명을 사용하여 조회합니다. URL http://xdworld.vworld.kr:8080/XDServer/3DData Version 2.0.0.0 Request GetLayer Key 3XE3C10E-82B7-3E7F-AC31-37175F32CDE4 Layer facility_build Level 15 IDX 279420 IDY 116121 DataFile a13\\_52.jpg http://xdworld.vworld.kr:8080/XDServer/3DData?Version=2.0.0.0&amp;Request=GetLayer&amp;Key=3XE3C10E-82B7-3E7F-AC31-37175F32CDE4&amp;Layer=facility_build&amp;Level=15&amp;IDX=279420&amp;IDY=116121&amp;DataFile=a13_52.jpg 다운로드 받은 파일의 확장자를 jpg로 변경하여 이미지를 확인할 수 있습니다. 여기까지 해서 오브젝트 생성을 위한 데이터를 모두 얻었습니다. 오브젝트 생성 (Three.js 사용) 기본 구조는 이렇습니다. Geometry 생성 버텍스 추가 버텍스 인덱스 추가 UV 추가 이미지 파일 추가 메테리얼 생성 메시 생성 샘플 코드 123456789101112131415161718192021222324252627282930313233343536373839404142var vert = data.vert;var index = data.index;// 1. Geometry 생성var geometry = new THREE.Geometry();for (var i = 0; i &lt; vert.length; i += 3) &#123; var v1 = vert[i]; var v2 = vert[i + 1]; var v3 = vert[i + 2]; // 2. 버텍스 추가 geometry.vertices.push(new THREE.Vector3(v1.pos.x, v1.pos.y, v1.pos.z)); geometry.vertices.push(new THREE.Vector3(v2.pos.x, v2.pos.y, v2.pos.z)); geometry.vertices.push(new THREE.Vector3(v3.pos.x, v3.pos.y, v3.pos.z)); // 3. 버텍스 인덱스 추가 geometry.faces.push(new THREE.Face3(index[i], index[i + 1], index[i + 2])); // 4. UV 추가 geometry.faceVertexUvs[0].push([ new THREE.Vector2(v1.uv.x, 1 - v1.uv.y), new THREE.Vector2(v3.uv.x, 1 - v3.uv.y), new THREE.Vector2(v2.uv.x, 1 - v2.uv.y) ]);&#125;geometry.uvsNeedUpdate = true;// 5. 이미지 파일 추가const textureLoader = new THREE.TextureLoader();textureLoader.crossOrigin = &quot;Anonymous&quot;;const myTexture = textureLoader.load(jpgUrl);// 6. 메테리얼 생성var material = new THREE.MeshBasicMaterial(&#123; side: THREE.DoubleSide, map: myTexture&#125;);// 7. 메시 생성var build = new THREE.Mesh(geometry, material); 코드상에 잘못된 부분이 있으면 말씀해 주세요. 여기까지가 메시를 생성하는 부분이고, 이후에는 Three.js Scene에 추가합니다. Scene 생성 카메라 생성 렌더러 생성 컨테이너에 추가 메쉬 추가 1234567891011121314151617181920212223242526272829303132333435&lt;html&gt; &lt;div id=&quot;ThreeContainer&quot;&gt;&lt;/div&gt; &lt;script&gt; function initThree() &#123; var fov = 45; var width = window.innerWidth; var height = window.innerHeight; var aspect = width / height; var near = 1; var far = 10 * 1000 * 1000; // 1. Scene 생성 _three.scene = new THREE.Scene(); // 2. 카메라 생성 _three.camera = new THREE.PerspectiveCamera(fov, aspect, near, far); // 3. 렌더러 생성 _three.renderer = new THREE.WebGLRenderer(&#123;alpha: true&#125;); // 4. 컨테이너에 추가 _ThreeContainer.appendChild(_three.renderer.domElement); &#125; function init3DObject()&#123; // ... 위의 코드 ... var buildGroup = new THREE.Group(); buildGroup.add(build); // 5. 메쉬 추가 _three.scene.add(buildGroup); // don’t forget to add it to the Three.js scene manually &#125; initThree(); // Initialize Three.js renderer init3DObject(); // Initialize Three.js object mesh with Cesium Cartesian coordinate system &lt;/script&gt;&lt;/html&gt; 이렇게 하면 Vworld 로 부터 받은 3D data 를 Three.js 로 그릴 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"threejs","slug":"threejs","permalink":"http://jacegem.github.io/blog/tags/threejs/"},{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vworld","slug":"vworld","permalink":"http://jacegem.github.io/blog/tags/vworld/"},{"name":"3d","slug":"3d","permalink":"http://jacegem.github.io/blog/tags/3d/"},{"name":"data","slug":"data","permalink":"http://jacegem.github.io/blog/tags/data/"}]},{"title":"[Spring] PostgreSQL에 파일 저장하고 불러오기","slug":"2018/Spring-PostgreSQL에-파일-저장하고-불러오기","date":"2018-09-20T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Spring-PostgreSQL에-파일-저장하고-불러오기/","link":"","permalink":"http://jacegem.github.io/blog/2018/Spring-PostgreSQL%EC%97%90-%ED%8C%8C%EC%9D%BC-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B3%A0-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/","excerpt":"","text":"[Spring] PostgreSQL에 파일 저장하고 불러오기 bytea 컬럼 생성 파일(바이너리)을 저장하기 위한 컬럼을 생성합니다. 1234567CREATE TABLE public.attach_file_info( file_size integer NOT NULL, -- 파일크기 file_type character varying(4), -- 파일유형 thumbnail text, -- 썸네일 file bytea,) 마지막 file 컬럼을 bytea 타입으로 생서합니다. 파일 전송 이부분은 자바로 전송하는 코드를 사용하였습니다. 12345678910111213141516171819202122private void fileUploadWithThumbnail(String attach_file_seq, String file_path, String user_id, String thumbnail) &#123; File uploadFile = new File(file_path); MultipartEntityBuilder builder = MultipartEntityBuilder.create() //객체 생성 .setCharset(Charset.forName(&quot;UTF-8&quot;)) //인코딩을 UTF-8로 .setMode(HttpMultipartMode.BROWSER_COMPATIBLE); builder.addPart(&quot;file&quot;, new FileBody(uploadFile)); //빌더에 FileBody 객체에 인자로 File 객체를 넣어준다. builder.addTextBody(&quot;attach_file_seq&quot;, attach_file_seq, ContentType.create(&quot;Multipart/related&quot;, &quot;UTF-8&quot;)); builder.addTextBody(&quot;user_id&quot;, user_id, ContentType.create(&quot;Multipart/related&quot;, &quot;UTF-8&quot;)); builder.addTextBody(&quot;thumbnail&quot;, thumbnail, ContentType.create(&quot;Multipart/related&quot;, &quot;UTF-8&quot;)); try &#123; InputStream inputStream = null; HttpClient httpClient = new DefaultHttpClient(); HttpPost post = new HttpPost(server_domain + &quot;/file/fileUploadDisk.json&quot;); //전송할 URL HttpEntity multipart = builder.build(); post.setEntity(multipart); HttpResponse httpResponse = httpClient.execute(post); HttpEntity httpEntity = httpResponse.getEntity(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; MultipartEntityBuilder 를 사용하여 파일을 전송합니다. file 에 전송할 파일을 담습니다. 추가적으로 필요한 정보들을 넣습니다. Post 로 해당 내용을 전송합니다. 서버에서 파일 저장 12345678910@RequestMapping(&quot;/fileUploadDisk.json&quot;)public void fileUploadDisk(RMap rmap, ModelMap model, @RequestParam(&quot;file&quot;) MultipartFile file) throws IOException &#123; // 파일정보가 없는 경우가 리턴합니다. if (file.isEmpty()) return; rmap.put(&quot;file&quot;, file.getBytes()); commonFileService.insertAttachFileInfo(rmap, model);&#125; getBytes로 파일을 byte array 로 받습니다. 그리고 mybatis 로 전달합니다. insert Query 123456789101112131415&lt;!-- 파일 등록 --&gt;&lt;INSERT id=&quot;insertAttachFileInfo&quot;&gt; /* file.insertAttachFileInfo */ INSERT INTO ATTACH_FILE_INFO ( thumbnail, file ) VALUES ( #&#123;thumbnail&#125;, #&#123;file&#125; )&lt;/INSERT&gt; byte array 를 쿼리를 통해 그대로 저장합니다. 이미지 불러오기 1234567891011121314151617@RequestMapping(&quot;/attachImage.do&quot;)public void attachImage(RMap rmap, ModelMap model, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; // 파일 조회 UMap umap = commonService.selectAttachFile(rmap, model); byte[] data = (byte[]) umap.get(&quot;file&quot;); String file_type = (String)umap.get(&quot;file_type&quot;); if (data == null || !file_type.equals(&quot;0001&quot;))&#123; String thumbnail = (String) umap.get(&quot;thumbnail&quot;); data = Base64.decodeBase64(thumbnail.split(&quot;base64,&quot;)[1]); &#125; // 이미지를 전송한다. response.setContentType(&quot;image/jpeg&quot;); response.getOutputStream().write(data);&#125; 다운로드 하기 12345678910111213@RequestMapping(&quot;/fileDownload.do&quot;)public void fileDownload(RMap rmap, ModelMap model, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; UMap umap = commonService.selectAttachFile(rmap, model); String filename = (String) umap.get(&quot;original_file_name&quot;); String fileNm = new String(filename.getBytes(&quot;UTF-8&quot;), &quot;ISO-8859-1&quot;); response.setContentType(&quot;application/octet-stream&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename=&quot; + fileNm); byte[] data = (byte[]) umap.get(&quot;file&quot;); response.getOutputStream().write(data);&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Spring","slug":"Programming/Spring","permalink":"http://jacegem.github.io/blog/categories/Programming/Spring/"}],"tags":[{"name":"file","slug":"file","permalink":"http://jacegem.github.io/blog/tags/file/"},{"name":"spring","slug":"spring","permalink":"http://jacegem.github.io/blog/tags/spring/"},{"name":"mybatis","slug":"mybatis","permalink":"http://jacegem.github.io/blog/tags/mybatis/"},{"name":"postgresql","slug":"postgresql","permalink":"http://jacegem.github.io/blog/tags/postgresql/"},{"name":"psql","slug":"psql","permalink":"http://jacegem.github.io/blog/tags/psql/"},{"name":"bytea","slug":"bytea","permalink":"http://jacegem.github.io/blog/tags/bytea/"}]},{"title":"[도쿠위키] 파일명 인코딩을 urlencode 에서 utf8로 변경하기","slug":"2018/도쿠위키-파일명-인코딩을-urlencode-에서-utf8로-변경하기","date":"2018-09-04T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/도쿠위키-파일명-인코딩을-urlencode-에서-utf8로-변경하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EB%8F%84%EC%BF%A0%EC%9C%84%ED%82%A4-%ED%8C%8C%EC%9D%BC%EB%AA%85-%EC%9D%B8%EC%BD%94%EB%94%A9%EC%9D%84-urlencode-%EC%97%90%EC%84%9C-utf8%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0/","excerpt":"","text":"[도쿠위키] 파일명 인코딩을 urlencode 에서 utf8로 변경하기 오래전에 설치한 도쿠위키라서 파일 저장시에 url로 인코딩 되도록 지정되어 있었습니다. 이것을 utf-8로 변경하니 문서를 읽지 못하게 되었습니다. UTF-8 로 변경 그리하여, 저장된 파일명들을 모두 utf-8로 변경하기로 합니다. 도쿠위키에서 파일들은 /data/pages 밑에 저장됩니다. 1234567891011121314151617181920212223242526272829303132import osfrom glob import globimport urllib.parsedef change_file(path): files = glob(path, recursive=True) for file in files: if os.path.isfile(file): dir_name = os.path.dirname(file) file_name = os.path.basename(file) print(&#x27;&#123;&#125; and &#123;&#125;&#x27;.format(dir_name, file_name)) new_name = urllib.parse.unquote(file_name) print(&quot;encode to &#123;&#125;&quot;.format(new_name)) os.rename(os.path.join(dir_name, file_name), os.path.join(dir_name, new_name))def change_folder(path): files = glob(path, recursive=True) for file in files: if os.path.isdir(file): new_name = urllib.parse.unquote(file) print(&quot;encode to &#123;&#125;&quot;.format(new_name)) os.rename(file, new_name)if __name__ == &quot;__main__&quot;: base_folder = &#x27;/YOUR_PATH/pages&#x27; change_file(base_folder + &#x27;/**/*.txt&#x27;) change_folder(base_folder + &#x27;/**/&#x27;) 디렉토리 구조가 깊게 되어 있다면 폴더명 변경시에 해당 디렉토리가 변경되므로, 폴더명 변경을 여러번 해야 합니다. 에러 처리 You should check your config and permission settings. 에러 발생시 폴더에 권한을 부여합니다. 1chmod -R 777 data/ ; chmod -R 777 lib/ ; chmod -R 777 conf/ 참고 https://forum.dokuwiki.org/post/56689","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Wiki","slug":"Application/Wiki","permalink":"http://jacegem.github.io/blog/categories/Application/Wiki/"}],"tags":[{"name":"도쿠위키","slug":"도쿠위키","permalink":"http://jacegem.github.io/blog/tags/%EB%8F%84%EC%BF%A0%EC%9C%84%ED%82%A4/"},{"name":"파일명","slug":"파일명","permalink":"http://jacegem.github.io/blog/tags/%ED%8C%8C%EC%9D%BC%EB%AA%85/"},{"name":"인코딩","slug":"인코딩","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%B8%EC%BD%94%EB%94%A9/"},{"name":"urlencode","slug":"urlencode","permalink":"http://jacegem.github.io/blog/tags/urlencode/"},{"name":"utf-8","slug":"utf-8","permalink":"http://jacegem.github.io/blog/tags/utf-8/"}]},{"title":"localStorage 에 checkbox 상태 저장","slug":"2018/localStorage-에-checkbox-상태-저장","date":"2018-09-03T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/localStorage-에-checkbox-상태-저장/","link":"","permalink":"http://jacegem.github.io/blog/2018/localStorage-%EC%97%90-checkbox-%EC%83%81%ED%83%9C-%EC%A0%80%EC%9E%A5/","excerpt":"","text":"localStorage 에 checkbox 상태 저장 change 이벤트 받기 HTML 에서 checkbox input 삽입 1&lt;input type=&quot;checkbox&quot; id=&quot;checkboxShowGPSInfo&quot; /&gt; 자바스크립트에서 change 이벤트 정의 123456789$(function() &#123; $(&quot;#checkboxShowGPSInfo&quot;).change(function() &#123; if ($(&quot;#checkboxShowGPSInfo&quot;).is(&quot;:checked&quot;)) &#123; alert(&quot;체크박스 체크했음!&quot;) &#125; else &#123; alert(&quot;체크박스 체크 해제!&quot;) &#125; &#125;)&#125;) localStorage 에 상태저장 12345678$(function() &#123; var checkboxShowGPSInfo = $(&quot;#checkboxShowGPSInfo&quot;) checkboxShowGPSInfo.change(function() &#123; showGPSInfo = !!checkboxShowGPSInfo.is(&quot;:checked&quot;) localStorage[&quot;showGPSInfo&quot;] = showGPSInfo &#125;)&#125;) change 이벤트시에 showGPSInfo 이름으로 상태값을 저장합니다. localStorage에서 값 불러오기 123456789101112$(function() &#123; showGPSInfo = localStorage[&quot;showGPSInfo&quot;] || false showGPSInfo = showGPSInfo === &quot;true&quot; var checkboxShowGPSInfo = $(&quot;#checkboxShowGPSInfo&quot;) checkboxShowGPSInfo.prop(&quot;checked&quot;, showGPSInfo) checkboxShowGPSInfo.change(function() &#123; showGPSInfo = !!checkboxShowGPSInfo.is(&quot;:checked&quot;) localStorage[&quot;showGPSInfo&quot;] = showGPSInfo &#125;)&#125;) localStorage 에서는 모든값을 문자열로 저장하기 때문에 이를 확인하여 boolean으로 변경합니다. 1showGPSInfo = showGPSInfo === &quot;true&quot; showGPSInfo 의 값이 “true” 이면 true 를 할당합니다. 아니면 false 입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"input","slug":"input","permalink":"http://jacegem.github.io/blog/tags/input/"},{"name":"localStorage","slug":"localStorage","permalink":"http://jacegem.github.io/blog/tags/localStorage/"},{"name":"checkbox","slug":"checkbox","permalink":"http://jacegem.github.io/blog/tags/checkbox/"}]},{"title":"vscode 에서 revealjs 사용","slug":"2018/VScode-에서-revealjs-사용","date":"2018-08-05T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/VScode-에서-revealjs-사용/","link":"","permalink":"http://jacegem.github.io/blog/2018/VScode-%EC%97%90%EC%84%9C-revealjs-%EC%82%AC%EC%9A%A9/","excerpt":"","text":"vscode 에서 revealjs 사용 vscode : https://code.visualstudio.com/ revealjs : https://revealjs.com note: visual studio 코드에서 revealjs 를 사용하는 법을 알아보겠습니다. reveal.js 프레임워크만을 가지고 프리젠테이션을 만들 수 있습니다. 그러기 위해서는 node 를 설치하고 명령어를 입력해야 하는 번거로움이 있습니다. vscode 를 통해서 쉽게 사용해 보도록 하겠습니다. – vscode? 비주얼 스튜디오 코드(영어: Visual Studio Code)는 마이크로소프트가 마이크로소프트 윈도우, macOS, 리눅스용으로 개발한 소스 코드 편집기 출처: 위키피디아 note: vscode 에 대해서 먼저 살펴보겠습니다. 위키피디아예서 비주얼 스튜디오 코드(영어: Visual Studio Code)는 마이크로소프트가 마이크로소프트 윈도우, macOS, 리눅스용으로 개발한 소스 코드 편집기로 설명되어 있습니다. 제가 요즘 가장 많이 사용하는 에디터가 vscode 입니다. 중요한 것은 무료라는 것입니다. 그리고 어느 플랫폼에서도 사용할 수 있는 장점이 있습니다. 크로스플랫폼으로 윈도우, 리눅스, 맥을 모두 지원합니다. 비슷한 에디터로는 github 에서 만든 Atom 이 있습니다. – vscode 설치 https://code.visualstudio.com/ note: 홈페이지에서 다운로드 받아서 vscode 를 설치합니다. 설치는 기본값으로 진행하면 됩니다. 설치가 되어있자면 다음 단계로 진행하시면 됩니다. – vscode 실행 화면 note: 설치된 vscode 를 실행을 하면 이와 같은 첫페이지를 볼 수 있습니다. – reveal? 홈페이지: https://revealjs.com HTML 프리젠테이션 프레임워크 note: reveal js 는 HTML 을 이용하여 프리젠테이션을 할 수 있는 프레임워크입니다. html 로 작성하면 다양한 형태로 작성이 가능하지만 html 문법을 알아야 하는 합니다. 다행히 reveal 에서 markdown 을 지원하기 때문에 마크다운으로 문서를 작성하면 쉽게 프리젠테이션 문서를 만들 수 있습니다. 확장 설치 vscode 에서 확장 vscode-reveal 설치 단축키 : Ctrl + Shift + X note: vscode 에서 reveal 을 사용하기 위해 vscode-reveal 확장을 설치합니다. 왼쪽 메뉴에서 위에서 다섯번째에 있는 확장을 선택합니다. 단축키는 Ctrl + Shift + X 입니다. 여기에서 revealjs 를 검색합니다. – 확장 설치 확인 html 파일로 출력 pdf 파일로 출력 브라우저에서 미리보기 사이드에서 미리보기 note: vscode 의 탐색기 패널에 SLIDES 가 생긴것을 확인할 수 있습니다. 이제부터 reveal.js 를 사용할 수 있습니다. slides 패널 상단 우측에 보이는 각각의 버튼은 다음과 같습니다. html 파일로 출력 pdf 파일로 출력 브라우저에서 미리보기 사이드에서 미리보기 Markdown 마크다운 문서 작성 #### 참고 링크 https://www.markdownguide.org/basic-syntax https://guides.github.com/features/mastering-markdown/ note: 마크다운으로 문서를 작성하기에 기본적인 문법을 알고 있어야 합니다. 마크다운 문법을 사용하여 헤더, 리스트, 이미지 등등을 작성합니다. https://www.markdownguide.org/basic-syntax 에서 기본 문법을 확인 할 수 있습니다. 이 곳 외에 검색을 하면 다양한 곳에서 확인 할 수 있습니다. github 에서도 마크다운을 지원하며, 문법 관련 문서도 확인할 수 있습니다. – 헤더 123# Heading level 1## Heading level 2### Heading level 3 Heading level 1 Heading level 2 Heading level 3 note: 먼저 헤더를 작성하는 법을 알아보겠습니다. 샵을 입력하여 헤더를 작성합니다. – 순서 있는 리스트 입력 12341. First item2. Second item3. Third item4. Fourth item 결과 First item Second item Third item Fourth item note: 순서가 있는 리스트는 숫자를 입력하고 .(점)을 붙여쓰고 한칸을 띄어줍니다. – 순서 없는 리스트 입력 1234- First item- Second item- Third item- Fourth item 결과 First item Second item Third item Fourth item note: 순서가 없는 리스트의 경우에는 대쉬(-)를 입력하고 한칸을 띄어줍니다. – 이미지 1![Tux, the Linux mascot](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/100px-Tux.svg.png) 1![](https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/100px-Tux.svg.png) https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Tux.svg/100px-Tux.svg.png note: 이미지를 보여주는 마크다운 문법입니다. 느낌표 뒤에 대괄호로 이미지의 설명을 입력하고, 괄호안에 이미지의 주소를 입력합니다. 이미지의 설명은 생략될 수 있습니다. – 코드 작성 예제코드 1234new_list = []for i in old_list: if filter(i): new_list.append(expressions(i)) https://highlightjs.org/ 176 languages and 79 styles note: 어퍼스트로피 3 개를 이어서 작성하여 코드 블럭의 시작과 끝을 표시합니다. 시작부분에 코드의 언어를 지정합니다. 지정할 수 있는 언어의 목록은 https://highlightjs.org/ 에서 확인 할 수 있습니다. 내부적으로 hightlightjs 를 사용하고 있으므로, 여기서 제공하는 176 가지 언어와 79 가지의 스타일을 지정할 수 있습니다. 작성 helloworld.md 파일 생성 12345678# Hello World- First item- Second item- Third item- Fourth item![](https://code.visualstudio.com/assets/images/home-intellisense.svg) note: 먼저 간단한 문서를 만들고 테스트 해보겠습니다. 새 문서를 만들고, helloworld.md 로 이름을 변경합니다. 확장자를 md 로 지정합니다. md 는 마크다운을 의미합니다. 내용에는 위와 같이 #(샵) 한칸 띄어쓰고 Hello World 를 입력합니다. 기능확인 html 파일로 출력 pdf 파일로 출력 브라우저에서 미리보기 사이드에서 미리보기 – html 출력 /helloworld-export 폴더 /helloworld-export/index.html 파일 12345678910&lt;div class=&quot;reveal&quot;&gt; &lt;div class=&quot;slides&quot;&gt;&lt;section data-markdown&gt;&lt;script type=&quot;text/template&quot;&gt;# Hello World- First item- Second item- Third item- Fourth item![](https://code.visualstudio.com/assets/images/home-intellisense.svg)&lt;/script&gt;&lt;/section&gt;&lt;/div&gt; note: 작성한 마크다운 파일이 있는 곳에 helloworld-export 폴더가 생성됩니다. 그리고 그 안에 들어가 보면 프리젠테이션을 위한 파일들이 생성되어 있는 것을 확인할 수 있습니다. 여기서 index.html 파일이 작성한 프리젠테이션 파일입니다. 파일의 내용을 열어보면 작성한 내용을 확인할 수 있습니다. revealjs 만들 사용하여 만들경우 위와 같은 내용을 직접 작성해주면 됩니다. 조금더 작성해야 할 내용이 늘어나게 됩니다. – 미리보기 먼저 SLIDES 에 있는 버튼 중 가장 오른쪽 버튼을 눌러서 오른쪽 사이드에서 미리보기를 실행합니다. 한페이지에 모두 나오게 되므로, 페이지 분할이 필요합니다. 페이지 분할 — : 수평분할 – : 수직분할 note: — 를 사용하여 수평분할, – 를 사용하여 수직분할 할 수 있습니다. 기본적으로 대쉬 3 개를 사용하여 수평분할로 페이지를 작성합니다. 수평분할된 페이지는 오른쪽으로 이동합니다. 세부내용의 페이지를 작성할 경우 대쉬 2 개를 사용하여 페이지를 작성합니다. 이때 페이지는 아래쪽으로 이동합니다. 화면 오른쪽 아래위치에 수평으로 페이지가 더 있으면 오른쪽 화살표가 나타나며 수직으로 페이지가 더 있으면 아래쪽 화살표가 나타납니다. – 수평 분할 — 를 입력하여 페이지 분할 note: — 사용하여 페이지를 분할하면 SLIDES 패널에서 다음과 같은 목록을 볼 수 있습니다. – 수직 분할 – 를 사용하여 수직분할 우측 하단 화살표 note: – 를 사용하여 수직분할하면 해당 페이지 하위로 구분됩니다. 페이지를 분할하면 우측 하단에 화살표가 생긴것을 확인할 수 있습니다. 하위 페이지가 있는 경우 아래 화살표가 생깁니다. 애니메이션 … a fragmented slide. grow shrink fade-out fade-up (also down, left and right!) current-visible Highlight red blue green 출처: https://raw.githubusercontent.com/evilz/vscode-reveal/master/sample.md note: 애니메이션에 어떤 것이 있는지 먼저 확인해 보겠습니다. 하나씩 나타나는 것 커지고 작아지고 사라지고 나타나는 것 색을 변경할 수 있습니다. – 글자 단위 입력 123&lt;span class=&quot;fragment&quot;&gt;... a&lt;/span&gt;&lt;span class=&quot;fragment&quot;&gt;fragmented&lt;/span&gt;&lt;span class=&quot;fragment&quot;&gt;slide.&lt;/span&gt; 결과 … a fragmented slide. 1&lt;span class=&quot;fragment&quot;&gt;... a&lt;/span&gt;&lt;span class=&quot;fragment&quot;&gt;fragmented&lt;/span&gt;&lt;span class=&quot;fragment&quot;&gt;slide.&lt;/span&gt; note: 이렇게 작성하면 다음 내용들이 순차적으로 나타나게 됩니다. span 태그로 작성되어 있기때문에 옆으로 붙여서 작성할 수도 있습니다. – 색상변경 1234Highlight&lt;span class=&quot;fragment highlight-red&quot;&gt;red&lt;/span&gt;&lt;span class=&quot;fragment highlight-blue&quot;&gt;blue&lt;/span&gt;&lt;span class=&quot;fragment highlight-green&quot;&gt;green&lt;/span&gt; Highlight red blue green note: 이렇게 작성하면 각각의 red, blue, green 의 글자색이 변경됩니다. span 태그를 사용하여 작성합니다. class 에 fragment 를 추가합니다. 그리고 클래스에 변경될 색상을 작성합니다. 사전에 정의된 hightligh-red, highlight-blue, hightlight-green 을 사용할 수 있습니다. – html 주석 1&lt;!-- 주석 내용 --&gt; 예제 12345&lt;!-- 본문 시작 --&gt;&lt;div class=&quot;main-article&quot;&gt; ...&lt;/div&gt;&lt;!-- 본문 끝 --&gt; note: 문단 단위로 애니메이션을 지정할 수 있습니다. 확대, 축소, 사라지기, 나타나기 를 표현할 수 있습니다. 작성은 html 주석 코드를 사용합니다. Left Angle Braket 느낌표, 대쉬 2 개 로 열고 대쉬 2 개 Right Angle Braket 로 닫습니다. 이렇게 작성한 내용은 발표화면에 표시되지 않습니다. – 문단 단위 123456789grow(확대) &lt;!-- .element: class=&quot;fragment grow&quot; --&gt;shrink(축소) &lt;!-- .element: class=&quot;fragment shrink&quot; --&gt;fade-out(사라지기) &lt;!-- .element: class=&quot;fragment fade-out &quot; --&gt;fade-up(나타내기)&lt;!-- .element: class=&quot;fragment fade-up&quot; --&gt;current-visible(현재만 보이기) &lt;!-- .element: class=&quot;fragment current-visible&quot; --&gt; grow(확대) shrink(축소) fade-out(사라지기) fade-up(나타내기) current-visible(현재만 보이기) note: html 주석을 사용하여 확대, 축소, 사라지기, 나타내기를 지정합니다. – fade-in 1234567위&lt;!-- .element: class=&quot;fragment fade-up&quot; --&gt;아래&lt;!-- .element: class=&quot;fragment fade-down&quot; --&gt;왼쪽&lt;!-- .element: class=&quot;fragment fade-left&quot; --&gt;오른쪽&lt;!-- .element: class=&quot;fragment fade-right&quot; --&gt; 위 아래 왼쪽 오른쪽 note: 나타나기는 위,아래,좌,우 모두 선택할 수 있습니다. 클래스로 지정한 fade-up 위치에 fade-down, fade-left, fade-right 를 입력하여 작성합니다. 배경 변경 색상 변경 이미지 변경 note: 테마를 통해서 전체 슬라이드의 배경 색상을 변경할 수 있지만 각각 페이지에 배경 색상 지정을 통해서도 변경할 수 있습니다. 또는 이미지를 배경으로 넣을 수 있습니다 – 배경 색상 RGB 1&lt;!-- .slide: data-background=&quot;#006064&quot; --&gt; hsla 1&lt;!-- .slide: data-background=&quot;hsla(0,100%,50%,0.5)&quot; --&gt; note: html 주석 코드를 사용하여 색상을 지정합니다. 16 진수 RGB 값을 이용하여 색상을 지정할 수 있으며 Hue-saturation-lightness-alpha 모델인 hsla 를 사용해서도 색상을 지정할 수 있습니다. 현재 페이지는 위에 있는 RGB 코드를 사용하여 작성하였습니다. – 배경 이미지 1&lt;!-- .slide: data-background=&quot;https://goo.gl/UfMdw8&quot; --&gt; 배경 이미지가 벗어나는 경우 custom-theme 사용 123.reveal div.slide-background.present &#123; background-size: contain;&#125; note: html 주석 코드를 사용하여 이미지를 지정합니다. 이미지의 크기가 큰 경우 화면을 벗어나게 되는데 이때는 custom-theme 를 적용하여 페이지 안에 모두 들어오게 작성할 수 있습니다. 뒤에서 커스텀 테마를 작성하겠습니다. 속성 지정 12345theme : &quot;night&quot;highlightTheme: &quot;darkula&quot;customTheme : &quot;reveal-custom-theme&quot;transition: &quot;slide&quot;transitionSpeed: &#x27;slow&#x27; note: 문서 상단에 속성을 지정할 수 있습니다. 대쉬 3 개를 사용하여 속성의 시작과 종료를 지정합니다. 테마 1theme : &quot;night&quot; 테마 목록 black white league sky beige simple serif blood night moon solarized note: 문서 상단에 지정하는 속성을 이용하여 테마를 지정합니다. night 외에, black, white, league, sky, beige, simple, serif, blood, night, moon, solarized, 기본은 black 으로 지정되어 있습니다. 각각의 모습은 테마를 변경해 보면서 확인할 수 있습니다. – 테마 확인 1&lt;a href=&quot;#&quot; onclick=&quot;document.getElementById(&#x27;theme&#x27;).setAttribute(&#x27;href&#x27;,&#x27;css/theme/black.css&#x27;); return false;&quot;&gt;Black (default)&lt;/a&gt; - 아래 링크를 누르면 테마가 변경됩니다. Black (default) - White - League - Sky - Beige - Simple Serif - Blood - Night - Moon - Solarized note: 아래 링크를 누르면 테마가 변경됩니다. 하이라이트 테마 1highlightTheme: &quot;darkula&quot; https://highlightjs.org/static/demo/ note: 코드 블럭의 하이라이트 테마를 지정할 수 있습니다. https://highlightjs.org/static/demo/ 에서 79 가지 코드 테마를 확인할 수 있습니다. 사용자 정의 테마 reveal-custom-theme.css 파일 생성 greenyellow 색상 추가 123.reveal .greenyellow &#123; color: greenyellow;&#125; – 사용자 정의 적용 1그린옐로우 색상 적용&lt;!-- .element: class=&quot;fragment fade-up greenyellow&quot;--&gt; 적용한 클래스 fragment fade-up greenyello 그린옐로우 색상 적용 note: css 파일을 추가하여 사용자 정의 테마를 만들 수 있습니다. reveal-custom-theme.css 파일을 생성합니다. 파일명은 원하시는 것으로 바꿀 수 있습니다. 사용할 때 파일명만 정확하게 입력하면 됩니다. greenyellow 색상을 추가하겠습니다. 클래스명을 greenyellow 로 주었습니다. html 주석 코드를 사용하여 생성한 클래스를 적용합니다. – 테마 조합 1234theme : &quot;night&quot;highlightTheme: &quot;darkula&quot;customTheme : &quot;reveal-custom-theme&quot;transition: &quot;slide&quot; note: theme, highlighTheme, customTheme, transition 을 정의하였습니다. 발표 ESC : Overview mode 이동키 : 상하좌우로 페이지 이동 스페이스바 : 다음 페이지로 이동 S : 스피커 노트 note: 프리젠테이션 발표시 ESC, 이동키, 스페이스바, S 키를 사용할 수 있습니다. – ESC note: ESC 키를 누르면 overview mode 로 전환됩니다. 이 화면에서 페이지를 선택하면 해당 페이지로 이동하고 ESC 키를 누르면 원래 페이지로 이동합니다. 참고 https://www.markdownguide.org/basic-syntax https://revealjs.com https://raw.githubusercontent.com/evilz/vscode-reveal/master/sample.md https://dymaxionkim.github.io/beautiful-jekyll/2017-01-25-Revealjs/ https://highlightjs.org/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"ppt","slug":"ppt","permalink":"http://jacegem.github.io/blog/tags/ppt/"},{"name":"revealjs","slug":"revealjs","permalink":"http://jacegem.github.io/blog/tags/revealjs/"},{"name":"vscode","slug":"vscode","permalink":"http://jacegem.github.io/blog/tags/vscode/"},{"name":"presentation","slug":"presentation","permalink":"http://jacegem.github.io/blog/tags/presentation/"}]},{"title":"[책] 아무도 알려주지 않은 4차 산업혁명 이야기","slug":"2018/아무도-알려주지-않은-4차-산업혁명-이야기","date":"2018-07-06T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/아무도-알려주지-않은-4차-산업혁명-이야기/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%95%84%EB%AC%B4%EB%8F%84-%EC%95%8C%EB%A0%A4%EC%A3%BC%EC%A7%80-%EC%95%8A%EC%9D%80-4%EC%B0%A8-%EC%82%B0%EC%97%85%ED%98%81%EB%AA%85-%EC%9D%B4%EC%95%BC%EA%B8%B0/","excerpt":"","text":"[책] 아무도 알려주지 않은 4차 산업혁명 이야기 아무도 알려주지 않은 4차 산업혁명 이야기강명구 저 한눈에 보는 4차 산업혁명 용어 맞춤 Customization 생산자 중심이 아닌 소비자 중심으로의 변화를 뜻한다. 소품종 대량생산이 다품종 소량생산으로 바뀌며, 동일한 생산성이 유지되는 대량 맞춤 개념이 중요해진다. 분권 Decentrailization 소수에게 권력이 집중되는 현상에 대한 반발이다. 중앙 관리자 없이 당사자가 직접 권력을 갖고 참여하는 시스템을 지향한다. 개방 Openness 정보가 모인 플랫폼 간 연결과 상호 연동을 의미한다. 개방의 대표적 응용 사례는 스마트 홈이다. 집 안의 가전기기가 제조업체에 따라 각자 따로 운영되는 현재와 달리 미래는 업체와 상관없이 연동될 것이다. 지금은 같은 회사 제품 간에 일부 가능한 폐쇄적 서비스다. 미래 스마트 홈은 업체 간 벽이 제거되어 주인을 중심으로 연동하는 진정한 개방의 모습을 보일 것이다. 대량 맞춤 Mass customization 다품종 소량 생산을 통해 소비자 개개인에 맞춘 제품을 생산하되 생산 효율은 기존 소품종 대량 생산 수준으로 낮추는 개념을 의미한다. 최초는 주로 소프트웨어에 사용되었는데, 4차 산업혁명에서는 하드웨어까지 다품종 소량 생산하는 일반적 개념으로 확대되고 있다. 이를 위한 다양한 기반 기술이 마련되고 있기 때문이다. 블록체인 Blockchain 디지털 공간의 자산 거래를 위한 전세계적 소프트웨어 플랫폼이다. 중앙 관리자 없이 참여자가 모든 정보를 공유하고 관리하여 디지털 자산위변조를 방지한다. 조건이 맞으면 자동으로 거래가 성사되는 스마트 계약 기능까지 포함하여 중개자 없이 거래 당사자 간 직접 거래하는 다양한 응용과 사업 모델이 발생하며 분권의 시대를 열고 있다. 암호화페 Crypto-currency 블록체인 유지를 위해 거래를 기록하는 블록의 생성이 필수적이다. 자신의 컴퓨터 자원을 이용해 이 작업을 해주는 사람에게 인센티브가 지급되도록 구성되어 있다. 이 인센티브로 지급되는 디지털 코인을 암호화폐라고 한다. 블록체인 기반 사업 모델이 증가할수록 암호화폐 수도 증가하고 있다. 그중 최초 암호화폐인 비트코인이 주도권을 갖고 있다. 눈에 보이지 않고 컴퓨터상에 표현되는 화폐라고 해서 디지털 화폐(digital currency) 또는 가상화폐 등으로 불렀지만, 최근에는 블록체인 상 암호화 기술을 사용하는 화폐라는 의미로 암호화폐라고 부른다. 디지털 헬스케어 치료나 건강 진단에 디지털과 유전 기술을 융합한 기술을 말한다. 웨어러블 등 다양한 디지털 기기를 활용한 측정이나 개인별 맞춤 처방 및 원격 정밀 투약 등을 포괄한다. 월가를 점령하라 OWS, Occupy Wall Street 2011년 빈부격차 심화와 금융기관의 부도덕성에 반발하여 미국 뉴욕에서 일어난 시위, 미국 전역으로 확산됐으나, 뚜렷한 목표를 제시하지 못한 한계를 남기며 73일 만에 막을 내렸다. 지연 전략 Postponement strategy 제품을 완성하는 시점을 지연시킴으로써 기업이 다양한 제품에 대한 수요 변화에 유연하게 대응할 수 있도록 공급 절차를 설계하는 전략을 말한다. 빅 데이터 Big data 디지털 환경에서 생성되는 데이터로 그 규모가 방대하고, 생성 주기도 짧고, 형태도 수치 데이터뿐 아니라 문자와 영상 데이터를 포함하는 대규모 데이터이다. 그리고 이로부터 경제적으로 필요한 가치를 추출 및 분석 할 수 있는 기술을 가리킨다. 스마트 홈 Smart Home 집 안의 모든 센서와 가전 기기 및 개인의 모바일 기기가 연결되어 정보를 주고 받으며 최적의 환경을 자동으로 만들어주는 기술이다. 편안함과 함께 에너지 절감, 방범, 가족 건강 관리까지 맞춤으로 제공한다. 스마트 팜 Smart Farm 농업에 센서와 디지털로 제어되는 기기를 접목시켜 사람의 개입을 최소화하며 생산성을 높이는 기술이다. 미래에는 다양한 작물을 동시에 재배 할 수 있도록 작물별 상태를 파악하는 센서와 작물별 맞춤 처치가 가능한 농기계로 구성된 스마트 팜이 확대될 것이다. 스마트 팩토리 Smart Factory 원재료, 공정, 운송 등 각 분야를 연결하여 자동으로 효율적 운영이 되도록 구성한 공장을 의미한다. 수많은 센서를 통해 파악한 정보를 기반으로 하여 인공지능이 생산 비용을 최적화하는 방향을 목표로 한다. 다품종 소량 생산을 가능하게 하는 대량 맞춤 개념을 포함하여 4차 산업 혁명의 핵심 분야다. 스마트 시티 Smart City 언제 어디서나 인터넷에 접속할 수 있고 영상회의 등 첨단 IT 기술을 자유롭게 사용할 수 있는 첨단 도시를 일컫는다. 실시간으로 교통정보를 얻을 수 있어 이동 거리가 줄고, 원격 근무가 가능해지는 등 거주자들의 생활이 편리해질 뿐만 아니라 이산화탄소 배출량도 줄일 수 있다. 도시가 시민을 인식하여 각종 서비스를 자동으로 제공하도록 다양한 업종간 개방 및 연결 플랫폼 구축을 시도하는 중이다. 사물인터넷 IoT, Internet of Things 인터넷을 기반으로 모든 사물을 연결하여 사람과 사물, 사물과 사물 간의 정보를 상호 소통하는 지능형 기술 및 서비스를 말한다. 사물인터넷은 기존의 유선통신을 기반으로 한 인터넷이나 모바일 인터넷보다 진화된 단계로, 인터넷에 연결된 기기가 사람의 개입 없이 서로 정보를 주고받아 처리한다. 클라우딩 컴퓨팅 Cloud Computing 인터넷 환경에서 정보의 저장, 변환, 분석 등을 제공하는 컴퓨팅 환경이다. 4차 산업혁명 시대 늘어나는 정보의 양으로 중요성이 커지고 있어, 주요 IT 기업이 관련 서비스를 속속 시작하고 있다. 공용 결제화폐 The utility settlement coin 스위스에 본사가 있는 글로벌 금융 기업 UBS가 금융시장 결제를 효율화하려는 목적으로 만든, 블록체인 기술을 기반으로 한 디지털 화폐, 도이체방크, 산탄데르, BNF 멜론 등이 회원사다. 글로벌 은행들은 사기 우려 때문에 블록체인 기술에 회의적이었지만, 최근 금융시장 거래 결제를 신속히 처리하고 비용을 줄이기 위해 활용 가능성을 탐색하고 있다. 에너지 수확 Energy havesting 버려지는 에너지를 모아 사용할 수 있도록 바꿔주는 기술이다. 빛, 온도, 진동 등 다양한 형태의 에너지를 전기로 변환시킨다. 4차 산업혁명 시대 충전이 필요 없는 센서를 만드는 데 필요하다. 랜섬웨어 Ransomware 악성 코드(malware)의 일종으로, 이에 감염된 컴퓨터는 시스템 접근이 제한되며 이를 해제하기 위해서는 악성 코드 제작자에게 대가로 금품을 제공해야 하는 악성 프로그램을 말한다. 공유경제 Sharing economy 한번 생상된 제품을 여럿이 공유해 쓰는 협업 소비를 기본으로 한 경제를 의미한다. 자동차, 빈방, 책 등 활용도가 떨어지는 물건이나 부동산을 다른 사람들과 함께 공유함으로써 자원 활용을 극대화하는 경제 활동으로, 소유자 입장에서는 효율을 높이고 구매자는 싼값에 이용할 수 있게 하는 소비 형태다. 인터스트리 4.0 Industrie 4.0 제조업 경쟁력 강화를 위해 독일 정부가 추진하고 있는 제조업 성장 전략. 사물인터넷을 통해 생산기기와 생산품 간의 정보 교환이 가능한 완전한 자동 생산 체계를 구축하고 전체 생산과정을 최적화하려는 산업 정책으로, 제4세대 산업 생산 시스템 이라고도 한다. 증기기관의 발명(1차), 대량생산과 자동화 발명(2차), ICT와 산업의 결합(3차)에 이어, 네 번째 산업혁명을 일으킬 것이라는 의미에서 붙여진 명칭이다. 제조업 혁신 네트워크 NNMI 2012년 버락 오바마 대통령이 마련한 미국 국가 제조업 부흥 정책이다. 인더스크리 4.0와 결합하여 대량 맞춤의 4차 산업혁명 패러다임에 맞게 다양한 혁신 제조 기술을 확보하여 제조업 경쟁력을 회복하고자 하는 목적이다. 이를 위해 전국에 제조업 혁신 연구소 네트워크를 만들고 3D 프린팅, 센서, 검사 장비 등 다양한 스마트 팩토리 기술에 집중하고 있다. 메이드 인 차이나 2025 4차 산업혁명 시대 제조업 경쟁력을 잃지 않기 위해 2015년 중국이 발표한 미래 혁신 전략이다. 혁신을 통해 산업의 근본 체질을 개선겠다는 목표이며 이를 위해 2025년까지 40개의 전국적 제조 혁신 센터를 구축할 계획이다. 슈타인-하르덴베르크 개혁 Stein-Hardenbergische Reformen 나폴레옹전쟁에서 패배하고 위기를 맞은 프로이센에서 이루어진 일련의 개혁을 가리킨다. 슈타인과 하르덴베르크가 주도해서 1807년과 이듬해에 걸쳐 농민 해방, 도시 자치 제도의 도입, 영업의 자유화, 중앙 행정기구의 근대화 등 광범한 개혁이 이루어졌다. 히든 챔피언 Hidden champion 대중에게 잘 알려져 있지 않지만 각 분야의 세계시장을 지배하는 우량 기업을 가리킨다. 전략·마케팅·가격결정 분야의 권위자인 독일의 경영학자 헤르만 지몬(Hermann Simon)이 펴낸 '히든 챔피온’이라는 책에서 비롯한 말이다. 마스트리흐트 조약 Maastricht Treaty 1991년 12월 네덜란드 마스트리흐트에서 체결된 조약으로, 유럽 공동체(EC)가 유럽연합(EU)으로 발전하게 된 기반이 되었다. 유럽 통화 통합에 관한 일정과 유로존 가입 요건(환율 안정성, 재정 적자, 물가 상승률 등). 유럽중앙은행(ECB) 설립, 서유럽연맹(WEU) 주축의 군사정책 수행, 유럽의회에 유럽공동체 조약 개정 승인권 부여, 유럽 시민권 도입 등의 내용을 담고 있다. 일대일로 중국 주도의 '신실크로드 전략 구상’으로, 내륙과 해상의 실크로드경제 벨트를 가리킨다. 35년간(2014~2049) 고대 동서양의 교통로인 현대판 실크로드를 다시 구축해, 중국과 주변 국가의 경제·무역 합작을 확대하는 길을 연다는 대규모 프로젝트다. 2013년 시진핑 주석의 제안으로 시작되었으며, 2017년 현재 100여 국가 및 국제기구가 참여하고 있다. 내륙 3개, 해상 2개 등 총 5개의 노선으로 추진되고 있다. O2O Online to Offline 이용자가 스마트폰 등의 온라인으로 상품이나 서비스를 주문하면 오프라인으로 이를 제공하는 서비스다. 음식 배달, 택시 승차 요청, 숙박 예약 등이 구체적인 사업 모델이다. 국내에서는 특히 다양한 배달 음식 주문 서비스가 O2O 형태로 이루어지고 있으며 ‘요기요’, ‘배달의 민족’ 등의 음식 배달 어플리케이션이 이에 해당한다. 이 외에도 '카카오택시’나 미국의 ‘우버’ 콜택시 등이 있다.","categories":[],"tags":[{"name":"4차","slug":"4차","permalink":"http://jacegem.github.io/blog/tags/4%EC%B0%A8/"},{"name":"산업혁명","slug":"산업혁명","permalink":"http://jacegem.github.io/blog/tags/%EC%82%B0%EC%97%85%ED%98%81%EB%AA%85/"},{"name":"이야기","slug":"이야기","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%B4%EC%95%BC%EA%B8%B0/"}]},{"title":"Big Data 플랫폼 구현기술의 이해","slug":"2018/Big-Data-플랫폼-구현기술의-이해","date":"2018-05-30T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Big-Data-플랫폼-구현기술의-이해/","link":"","permalink":"http://jacegem.github.io/blog/2018/Big-Data-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EA%B5%AC%ED%98%84%EA%B8%B0%EC%88%A0%EC%9D%98-%EC%9D%B4%ED%95%B4/","excerpt":"","text":"Big Data 플랫폼 구현기술의 이해 제타바이트의 시대 빅데이터란 기존의 관리 및 분석 체계로는 감당할 수 없을 정도의 거대한 데이터의 집합을 지칭 빅데이터의 정의는 데이터 규모와 기술 측면에서 출발했으나, 빅데이터의 가치와 활용효과 측면으로 의미가 확대되는 추세 ICT 주도권이 데이터로 이동 모바일, 클라우드, SNS의 등장으로 근본적인 인프라와 데이터의 변화가 일어나며 데이터를 바라보는 시각이 변화 축적과 공유를 통해 유의미하게 분석할 수 있는 데이터 자원(빅데이터)이 쌓이자 데이터의 역할은 분석과 추론(전망)의 방향으로 진화 빅데이터는 대용량 데이터, 비정형화된 데이터의 수집, 검색, 데이터 전처리 및 분석 기술, 시각화 기술 등이 중요 공간, 시간, 관계, 세상을 담는 데이터 최근 소셜 미디어에서 나타나는 행동·이용패턴을 분석하여 기업, 제품에 대한 인식 및 의견을 확인하기 위한 소셜 분석이 이슈 미래 경쟁력과 가치창출의 원천 빅데이터는 잠재적 가치와 잠재적 위험이 공존하며, 사회·경제적으로 성패를 좌우하는 핵심 원천이 될 것으로 평가 빅데이터의 3대요소 숨겨진 정보를 채굴하는 디지털 시대의 마이닝 디지털 시대에서는 쌓여 있는 데이터 속에서 유용하고, 가치 있는 정보를 찾기 위한 노력이 끊임없이 진행 중 데이터 마이닝(Data Mining) 텍스트 마이닝(Text Mining) 웹 마이닝 소셜 분석, 소셜 마이닝 현실 마이닝(Reality Mining) 사람들의 행동패턴을 예측하기 위해 사회적 행동과 관련된 정보를 기기를 토앻 얻고 분석하는 기법 휴대폰 등 모바일 기기들을 통해 현실에서 발생하는 정보를 기반으로 인간관계와 행동 양태 등을 추론 기업들은 수많은 고객·업무·거래 데이터를 활용하여 발 빠른 의사결정, 미래 수요예측, 경영 성과관리에 기여하는 BI전략 도입 데이터 마이닝에서 빅데이터 마이닝으로 맥락 이해와 추론이 기반이 되는 인공지능형 서비스, 상황인식 서비스, 개인맞춤 서비스의 발전 빅데이터의 주요 특성과 요소 스마트 시대 주요 패러다임 선도를 위해서는 빅데이터의 활용이 핵심이며, 그 수준이 경쟁력과 성패를 좌우 빅데이터의 특성은 일반적으로 3V(Volume, Variety, Velocity)를 기본으로 1V(Value)나 1C(Complexity)의 특성이 추가되어 설명 빅데이터의 3대 요소 자원 : 활용할 수 있는 빅데이터 발견하기 기술 : 빅데이터 프로세스와 신기술 이해하기 인력 : 데이터 사이언티스트 역량 키우기 자원 데이터 경제시대의 도래와 무한한 데이터 자원 활용할 수 있는 빅데이터 발견하기 최근에는 웹, 소셜 미디어, 포털 검색 데이터 등을 분석하여 여론 확인, 기업의 마케팅 서비스 등에 적용하는 사례가 증가 국내외적으로 공공 데이터의 개발을 확대하는 추세이며, 공공 오픈 데이터를 활용한 다양한 환경 분석이 가능 기술 스마트 시대의 핵심 키(Key): 빅데이터 빅데이터의 처리 프로세스 빅데이터란 기존의 관리, 분석체계로는 감당하기 어려운 막대한 데이터집합과 이를 해결하기 위한 플랫폼, 분석 기법 등을 포괄 빅데이터와 관련하여 다음과 같은 기술들이 새롭게 등장 대용량 데이터 처리 능력을 위한 분석처리 기술 : 하둡(Hadoop) 분산 파일 시스템(HDFS), 분산 데이터베있스(HBase), MapReduce 등 인메모리(In-Memory) 기술 : 인메모리 기술에서는 메모리상에 필요한 데이터와 이의 인덱스를 보관함으로써 데이터검색 시간을 크게 줄일 수 있음 의미분석 기술과 진보된 알고리즘 및 데이터마이닝 기술 : 예를 들어 통계 계산 및 그래픽을 위한 R언어 비정형 데이터를 처리하기 위한 NoSQL 기술 : 아파치 Cassandra 와 CouchDB, 구그르이 BigTable, 아마존 다이나모(Dynamo) DB, IBM Lotus Domino 등 빅데이터는 데이터 생성 → 수집 → 저장 → 분석 → 표현의 처리 과정을 거치며 각 프로세스마다 세부영역과 관련기술이 등장 분석기술은 통계, 데이터 마이닝, 기계학습, 자연어처리, 패턴인식, 소셜 네트워크 분석, 비디오·오디오·이미지 프로세싱 등이 해당 빅데이터의 활용, 분석, 처리 등을 포함하는 인프라에는 BI, DW, 클라우드 컴퓨팅, 분삭데이터베이스(NoSQL), 분산 병렬처리, 분산파일시스템 등이 해당 인력 빅데이터 시대의 연금술사, 데이터 사이언티스트 구조화되지 않은 대규모 데이터 속에서 숨겨진 정보를 찾아내는 데이터 사이언티스트는 스마트 시대에서 최고의 인재 데이터 사이언티스트의 역략과 조건 데이터 과학자의 자질 6가지 수학과 공학능력 비판적 시각 글쓰기 능력 대화 능력 호기심과 개인의 행복 데이터 사이언티스트는 대규모 데이터를 분석한 결과를 생성하고 차별화되게 시각화하여 이해하기 쉽게 전달하는 역량도 중요 국내외적으로 데이터 사이언티스트에 대한 공급부족을 인식하고 유능한 인재 육성 프로그램과 교육과정을 개설 데이터 사이언티스트는 경영 전략과 밀접한 관계가 있으므로 외부에 아웃소싱인력을 활용하는 것보다는 내재화가 바람직 오픈소스 빅데이터 플랫폼 빅데이터를 둘러싼 전쟁과 시사점 빅데이터 서비스 프레임워크를 통한 공급자 전략의 이해 빅데이터 시장을 이해하기 위해 빅데이터 에코시스템에서 출발해 빅데이터 서비스 프레임워크를 구축 빅데이터 서비스 주도권을 위한 공급자간 전쟁 빅데이터를 둘러싼 경쟁은 크게 다음 3가지로 요약할 수 있음 장치 전쟁 사용자 확보 가치 탐색 하둡이란 데이터 경제시대의 도래와 무한한 데이터 자원 대용량 데이터를 처리하는 분산 응용 프로그램을 작성하고 실행시키기 위한 오픈소스프레임워크 데이터를 금맥(유용한 정보)을 찾는데 필요한 자원(resource)으로 분다면, 리소스를 키우는 전략은 중요한 성공 전략 중 하나 다른 분산 컴퓨팅과 다른 주된 차이점 접근 견고성 확장가능성 간단성 하둡의 특징 오픈소스 데이터가 있는 곳으로 코드를 이동 스케일 아웃 단순한 데이터 모델 (MapReduce 프로그래밍) 오프라인 배치 프로세싱에 최적화 하둡 에코시스템 하둡은 빅데이터 저장과 처리의 기본적 기능만 제공하기 때문에, 이의 부족함을 보완하는 다양한 오픈소스 소프트웨어들이 필요 빅데이터 수집 Flume Sqoop 빅데이터 저장, 활용 HBase 빅데이터 처리 Hive Pig Mahout 빅데이터 관리 Oozie HCatalog Zookeeper Zookeeper 분산 환경에서 서버 간의 상호 조정이 필요한 다양한 서비스를 제공하는 시스템 하나의 서버에만 서비스가 집중되지 않게 서비스를 알맞게 분산해 동시에 처리 하나의 서버에서 처리한 결과를 다른 서버와도 동기화해서 데이터의 안정성 보장 운영 서버가 문제가 발생해서 서비스를 제공할 수 없을 경우, 다른 대기 중인 서버를 운영서버로 바꿔서 서비스가 중지 없이 제공되게 해줌 분산환경을 구성하는 서버들의 환경설정을 통합적으로 관리해줌 Ooozie 하둡 작업을 관리하는 워크플로우 및 코디네이터 시스템 자바 서블릿 컨테이너에서 실행되는 자바 웹 애플리케이션 서버이며, 맵리듀스 작업이나 프그 작업 같은 특화된 액션으로 구성된 워크플로우를 제어 HCatalog 하둡으로 생성한 데이터를 위한 테이블 및 스토리지 관리 서비스 가장 큰 장점은 하둡 에코시스템 간의 상호 운영성 향상 Hive에서 생성한 테이블이나 데이터 모델을 Pig나 맵리듀스에서 손쉽게 이용할 수 있다. Hive 하둡 기반의 데이터웨어하우징용 솔루션 페이스북에서 개발 됐으며, 오픈소스로 전환 SQL과 매우 유사한 HiveQL은 내부적으로 맵리듀스 잡으로 변환되어 실행 자바를 모르는 데이터 분석가들도 쉽게 하둡 데이터를 분석 할 수 있게 도와줌 Pig 야후에서 개발 됐으며, 오픈소스로 전환 SQL과 유사하기만 할 뿐 SQL 지식의 활용은 어려움 Pig Latin이라는 자체 언어를 제공 맵리듀스를 크게 단순화 Mahout Hbase HDFS 기반의 칼럼 기반 데이터베이스 실시간 랜덤 조회 및 업데이트 가능하며, 각 프로세스는 개인의 데이터를 비동기적으로 업데이트 할 수 있다. 단 맵리듀스는 일괄 처리 방식으로 수행 Chunkwa 분산 환경에서 생성되는 데이터를 HDFS에 안정적으로 저장하는 플랫폼 분산된 각 서버에 에이전트를 실행하고 콜렉터가 에이전트로부터 데이터를 받아 HDFS에 저장 콜렉터는 100개의 에이전트당 하나씩 구동되며, 데이터 중복 제거 등의 작업은 맵리듀스로 처리 Flume Chunkwa 와의 차이점은 전체 데이터의 흐름을 관리하는 마스터 서버가 있어서 데이터를 어디서 수집하고, 어떤 방식으로 전송하고, 어디에 저장할지를 동적으로 변경할 수 있다는 것 Sqoop 대용량 데이터 전송 솔루션이며, HDFS, RDBMS, NoSQL등 다양한 저장소는 대용량 데이터를 신속하게 전송할 수 있는 방법을 제공 Hiho Sqoop과 같은 대용량 데이터 전송 솔루션, 현재 깃허브(Github)에 공개 하둡에서 데이터를 가져오기 위한 SQL을 지정할 수 있으며, JDBC 인터페이스를 지원 Avro RPC(Remote Procedure Call)과 데이터 직렬화를 지원하는 프레임워크 JSON을 이용해 데이터 형식과 프로토콜을 정의하며, 작고 빠른 바이너리 포멧으로 데이터를 직렬화한다. Scribe 페이스북에서 개발한 데이터 수집 플랫폼, Chunkwa와는 다르게 데이터를 중앙 집중 서버로 전송하는 방식 최종 데이터는 HDFS외에 다양한 저장소를 활용할 수 있으며, 다양한 프로그래밍 언어를 지원, HDFS에 저장하려면 JNI(Java Native Interface)를 이용 HDFS 설계 HDFS는 범용 하드웨어로 구성된 클러스터에서 실행되고 데이터 엑세스 패턴을 스트리밍 방식으로 지원하며 매우 커다란 파일들을 저장할 수 있도록 설계된 파일시스템 매우 커다란 파일 데이터 엑세스를 스트리밍 방식으로 지원 범용 하드웨어 HDFS가 잘 맞지 않는 응용분야 빠른 응답시간의 데이터 엑세스 많은 수의 작은 파일 다중 라이터, 임의의 파일 수정 HDFS의 파일들은 단일 라이터에 의해 쓰인다. 쓰기 작업은 항상 파일의 끝에서 이루어진다. HDFS 개념 블록 디스크는 블록 크기를 가지며, 블록은 한 번에 쓸 수 있는 데이터의 최대량 단일 디스크를 위한 파일시스템은 블록들 안에 있는 데이터를 관리함으로써 구축 디스크 블록의 배수 크기에 대한 전체 집합이 바로 파일시스템 그 자체 파일시스템 블록은 전형적으로 수 킬로바이트 크기이오, 반면에 디스크 블록은 기본적으로 512바이트 HDFS의 블록 크기 64MB와 같이 훨씬 더 커다란 단위, 단일 디스크를 위한 파일시스템처럼 HDFS 파일들은 블록 크기의 청크로 쪼개 지고, 독립적인 단위로 저장된다. 블록은 내고장성과 가용성을 제공하기 위한 복제를 효율적으로 수행 할 수 있게 해준다. 손상된 블록과 디스크/서버 장애에 대응하기 위해서 각 블록은 물리적으로 분리된 몇 개의 서버(일반적으로 3개)로 복제 만일 하나의 블록을 이용할 수 없게 되면, 클라이언트에는 투명한 방식으로 하나의 복사본이 또 다른 위치에서 읽혀질 수 있다. 복제 계수가 정상 수준으로 다시금 되돌아오게 하기 위하여 손상 또는 서버장애로 더 이상 이용할 수 없는 블록은 또 다른 복사본의 위치로 부터 다른 살아있는 서버드롤 복제될 수 있다. 네임노드와 데이터노드 추가적으로 클러스터에서 노드 당 하나며 노드에 붙은 스토리지를 관리하는 수 많은 데이터노드가 있다. HDFS 는 파일 시스템 네임스페이스를 노출하고 사용자의 데이터를 파일로 저장 되도록 허용 내부적으로 파일은 하나 또는 그 이상의 블록으로 쪼개지며 이러한 블록들은 데이터노트의 집합 안에 저장 빅데이터 병렬 처리 맵리듀스 맵리듀스는 데이터 처리를 위한 프로그래밍 모델이다. 하둡은 다양한 언어로 쓰인 맵리듀스 프로그램을 구동시킬 수 있다. 맵리듀스 프로그램은 타고난 병행성을 내포하고 있고, 누구든지 임의로 활용할 수 있는 충분한 서버를 이용하여 대규모 데이터 분석을 할 수 있다. 맵과 리듀스 하둡이 제공하는 병렬 처리를 이용하기 위해 쿼리를 맵리튜스 잡으로 표현해야 할 필요가 있다. 맵리듀스는 맵 단계와 리튜스 단계로 처리 과정을 나누어 작업한다. 각 단계는 입력과 출력으로써 키-값 쌍을 가지고 있고 그 타입은 프로그래머가 선택한다. 맵과 리듀스 함수는 프로그래머가 직접 작성한다. 맵 단계에서 입력은 NCDC 원본 데이터이다. 맵 함수는 분석 대상인 연도와 기온을 추출하며 잘못된 레코드를 제거하는 역할 수행 행은 키-값 쌍으로 맵 함수에 보내진다. 키는 파일 내에서 몇 번째 행인지 나타내는 오프셋이고 맵 함수에서는 무시된다. 맵 함수는 단순히 연도와 기온을 추출하고 그것을 출력으로 방출한다. 분산형으로 확장하기 맵리튜스 잡은 클라이언트가 수행하려는 작업 단위다. 하둡은 잡을 맵 태스크와 리듀스 태스크로 나누어 실행한다. 분할 크기를 너무 작게 하면 분할 관리와 맵 태스크 생성을 위한 오버헤드가 전체 잡 실행 시간을 압도하기 시작한다. 최적의 스플릿 크기가 HDFS 블록 크기와 같아야 하는 이유는 블록 크기가 단일 노드에 저장된다고 확신할 수 있는 가장 큰 입력 크기이기 때문이다. 잡 실행 얀(맵리듀스 2) 고전적인 맵리듀스 시스템은 4000 노드 이상의 매우 큰 클러스터를 확장하는 과정에서 병목현상을 일으키기 시작하여 이 문제를 해결하기 위해 야후의 한 조직이 2010년에 차세대 맵리듀스를 설계하기 시작하였는데 그 결과가 바로 얀(YARN)이다. 얀은 고전적인 맵리듀스의 확장성 문제를 해결하기 위해 잡트래커의 책임을 여러 개의 책임자에게 분리해서 나눠준다. 잡트래커는 잡 스케줄링과 태스크 진행 상황 모니터링을 모두 관리한다. 리소스 매니저는 클러스터 전반에 걸쳐 리소스 이용을 관리한다. 애플리케이션 마스터는 클러스터에서 실행 중인 애플리케이션의 생명주기를 관리한다. 잡트래커와는 다르게, 응용프로그램의 각 인스턴스는 애플리케이션 마스터를 고정적으로 할당시켜 응용프로그램의 지속성을 유지시킨다. 얀 설계의 아름다움은 동일 클러스터에서 여러 다른 얀 애플리케이션이 함께 실행될 수 있다는 것이다. 심지어 다른 버전의 맵리듀스를 같은 얀 클러스터에서 실행할 수 있다. 출처 SK 동반성장아카데미","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"}],"tags":[{"name":"big data","slug":"big-data","permalink":"http://jacegem.github.io/blog/tags/big-data/"},{"name":"platform","slug":"platform","permalink":"http://jacegem.github.io/blog/tags/platform/"}]},{"title":"[책] 인간다운 Git","slug":"2018/인간다운-Git","date":"2018-05-21T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/인간다운-Git/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%9D%B8%EA%B0%84%EB%8B%A4%EC%9A%B4-Git/","excerpt":"","text":"[책] 인간다운 Git 인간다운 Git 데이비드 디마리 저/이태상 역 버전 관리의 요소 버전 관리 시스템(Version Control System) VCS 어떤 작업물의 최종본만 갖고 있는 것이 아니라 그 이전 각 수정본을 모두 보유함으로써, 필요할 때 이전 버전을 참고하거나 그 버전으로 되돌릴 수 있게 하자 병합 충돌 (merge conflict) 포함하고자 하는 변경 사항을 먼저 스테이징하고 그 다음에 커밋을 하는 것은 마찬가지다 Git 은 충돌이 있는 각 파일에 충돌마커(conflict marker)라고 하는 불가사의하고 난해한 표식을 넣는다. 1$ git merge master 꺾쇠괄호가 연속으로 있는 라인이 충돌 마커이며, 두 충돌 마커 사이가 충돌 영역이다. 12$ git add about.html$ git commit -m &quot;merge branch&quot; 리모트 리모트 저장소(remote repository)는 내 컴퓨터가 아닌 원격에 있는 git 프로젝트의 사본을 말한다. GitHub 실전에서 대부분의 팀은 GitHub로 호스팅하는 하나의 공유 사본을 주된 저장소로 URL며, 이를 git의 관용어로 오리진origin이라고 한다. 마스터 브랜치를 주된브랜치로 할 것인지가 사용자에게 달렸듯, 오리진 리모트 역시 마찬가지다. 1$ git push &lt;remote-name&gt; &lt;branch-name&gt; 리모트 추가 123$ git remote add origin &lt;remote-repository&gt;$ git remoteorigin SSH(Secure Shell) 오늘날의 오픈소스 생태계에 있어서 SSH 프로토콜의 유용성이 제한을 받는 한 가지 단점이 있다. SSH는 프라이빗 저장소에만 사용할 수 있다는 점이다. Git 프로토콜 git 프로토콜은 git에만 있는 유일무이한 프로토콜이지만, 주로 읽기 전용이라는 이유로 오늘날에는 잘 사용되진 않는다. HTTPS가 더 나은 선택이다. 리모트 브랜치로 작업하기 12$ git push origin new-homepage$ git pull origin new-homepage 리모트의 병합 충돌 123$ git pull origin master$ git add -A$ git commit -m &quot;Merge origin&quot; 푸시 거부 git의 어떤 장난에도 놀아나고 싶지 않다면, 항상 푸시하기 전 먼저 풀pull을 해서 로컬 사본을 최신으로 만들기 바란다. 변경 사항을 pull하는 것이 문제가 되는 경우는 거의 없으며 오히려 많은 이득을 얻는다. 브랜치 추적 1$ git push -u origin new-homepage 추적 관계를 설정하는 가장 간단한 방법은 git push를 할 때 --set-upstream(또는 -u) 옵션을 추가하는 것이다. 기존 브랜치 체크아웃 1$ git fetch origin 기본적인 git branch 명령은 로컬 사본에 존재하는 브랜치 목록을 보여주지만 --remote(-r) 옵션을 추가하면 git이 알고 있는 모든 리모트 브랜치를 보여준다. 1$ git branch --remote 히스토리 로그보기 1$ git log --pretty 옵션을 사용하면 미리 정이된 다양한 형식 중 하나를 선택하거나, 사용자가 원하는 형식을 지정할 수 있게 한다. 1$ git log --pretty=oneline new-homepage 브랜치의 히스토리를 보여달라는 명령이다. 1$ git log new-homepage master 와의 병합 전까지 new-homepage에 추가됐던 모든 커밋을 훑어보기 쉽게 확인하는 명령 1$ git log --oneline master..new-homepage 'heroku’라는 단어가 포함됐으며 Gemfile이라는 파일을 변경시킨 커밋만 필터링 1$ git log --author=AUTHOR --grep=heroku --oneline Gemfile 커밋 메시지 연계 기능을 이용하려면 먼저 원하는 에디터를 git에 설정해야 한다. 1$ git config --global core.editor &quot;atom --wait&quot; 커밋 메시지의 목적은 변경 사항을 요약하는 것이다. 이 커밋에서 변경된 내용을 간결하고 명쾌하게 설명하는 메시지를 작성해야 한다. 내가 어떤 일을 했고 이게 내가 한 일이다 라는 식의 훨씬 쉬운 얘기로 설명할 수 있다. 12$ git commit -m &quot;Update homepage for lunch&quot;$ git commit -m &quot;Fix typo in screen.css&quot; 커밋 비교 1$ git diff 저장소의 현재 헤드 커밋(HEAD)과 그 전 커밋(HEAD~1)의 차이를 보기 위한 명령어 1$ git diff --stat HEAD~1 통계를 보는 일이 의미 있다고 생각되면 git log 명령에 --stat 옵션을 붙여 사용할 수 있다. 1$ git log --stat --pretty=format:&quot;%h (%an) %s&quot; HEAD~1.. 태그 경량(lightweight): 마치 브랜치와 비슷하게 단지 커밋을 가리키는 이름으로만 저장 1$ git tag &lt;tag-name&gt; &lt;commit-id&gt; 주석(annotated): 커밋 메시지와 같이 메시지를 추가로 포함 1$ git tag &lt;tag-name&gt; -a -m &quot;branch release&quot; 브랜치와 마찬가지로 태그도 git push를 사용해 리모트로 공유할 수 있다. 1$ git push &lt;tag-name&gt; 방향성 비순환 그래프 DAG(directed acyclic graph)는 데이터 구조의 한 종류다. 각 개별 노드가 다른 노드를 가리키고 그런 참조들이 정보의 사슬을 구축하며, 작업이 진행되면서 커밋이 추가됨에 따라 나무 뿌리처럼 퍼져 나가는 모양으로 계속 자라는 구조다. 명령어 목록 git config [–global] : git 을 설정하는 명령 git init : 현재 작업 사본 안에서 새 git 프로젝트를 만든다. git clone [directory] : 해당 URL에 있는 git 프로젝트를 로컬 컴퓨터의 새 디렉터리로 복제 git status [-s] [path/to/thing] git add [–all] filename.txt git rm folder/filename.txt git mv oldpath.txt newpath.txt git reset filename.txt : 스테이징된 filename.txt를 git reset을 사용해 스테이징이 되지 않은 상태로 되돌린다. git commit [-a] [-m “Your message”] git branch [-r|-a] git branch [] git checkout [-b] git merge git remote add git remote rm git push git pull git fetch : 리모트의 모든 사항을 로컬 사본으로 복사한다. git pull 명령을 실행하면 git fetch 작업은 자동으로 포함된다. git log [–oneline] [–pretty] [] git diff [–stat] [] git tag [-a] [-m] [] git tag [-d] git tag [-l] git push --tags 추천 Git 앱 GitHub 데스크톱 타워(Tower) 소스트리(SourceTree) Git 호스팅 서비스 GitHub Bitbucket Beanstalk 추가정보 https://try.github.io/levels/1/challenges/1","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"}],"tags":[{"name":"book","slug":"book","permalink":"http://jacegem.github.io/blog/tags/book/"},{"name":"git","slug":"git","permalink":"http://jacegem.github.io/blog/tags/git/"}]},{"title":"[책] 리액트 네이티브 앱 제작 원론","slug":"2018/리액트-네이티브-앱-제작-원론","date":"2018-05-20T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/리액트-네이티브-앱-제작-원론/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%84%A4%EC%9D%B4%ED%8B%B0%EB%B8%8C-%EC%95%B1-%EC%A0%9C%EC%9E%91-%EC%9B%90%EB%A1%A0/","excerpt":"","text":"[책] 리액트 네이티브 앱 제작 원론 리액트 네이티브 앱 제작 원론에릭 마시엘로,제이콥 프리드만 공저/이태상 역 컴포넌트 업데이트 123456shouldComponentUpdate(nextProps, nextState)&#123; if (this.props.uid !== nextProps.uid)&#123; return true; &#125; return false;&#125; 리액트 네이티브 바벨이 낯설다면 https://babeljs.io/repl 에서 바벨 리플(Babel REPL)이라는 온라인 트랜스파일러를 사용해 볼 수 있다. 엑스코드 설치 홈브루 설치 https://brew.sh 터미널에 붙여 넣어 실행한다. 1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 노드, npm, 왓치맨, 플로 설치 123brew install nodebrew install watchmanbrew install flow 리액트 네이티브 CLI 설치 1npm install -g react-native-cli Error: ACCESS:permission denied… npm config get prefix 를 실행한다. /usr/local 이 보인다면 sudo chown -R $(whoami) $(npm config get prefix)/{lib/node_modules,bin,share}를 실행한다. 패스워드를 물어보면 패스워드를 입력하고 리턴을 누른다. 이로써 권한 설정이 완료된다. 만약 npm config get prefix 를 실행했을 때 다른 결과가 보였다면, npm 권한 문제를 해결하기 위한 자세한 사항을 설명하는 https://docs.npmjs.com/getting-started/fixing-npm-permissions 페이지를 확인해 본다. 루트 컴포넌트 등록 1AppRegistry.registerComponent(&quot;HelloWrold&quot;, () =&gt; HelloWorld); 플렉스박스 justifyContent 속성을 사용하면 메인 축을 따라 아이템을 배치할 수 있다. 메인 축이 아닌 축을 크로스 축이라고 하며, alignItems 속성을 통해 크로스 축을 따라 아이템을 배치할 수 있다. 플렉스박스 개구리(http://flexboxfroggy.com) 리액트 네이티브 컴포넌트 플럭스와 리덕스 플럭스 구현하기 높은 수준에서 보면 플럭스는 하나의 순환적인 패턴이라고 생각할 수 있다. 대개 그 순환은 뷰레이어에서 시작한다. 뷰레이어는 리액트 컴포넌트다. 사용자가 뷰와 상호작용을 하면 플럭스는 액션 생성자를 사용해 액션을 만든다. 이 액션은 디스패처에 전달되는데, 디스패처는 한 번에 하나의 액션만을 처리하는 싱글턴 컴포넌트다. 디스패처는 액션을 다시 해당 애플리케이션 스토어에 전달(디스패치)한다. 각 스토어는 액션을 처리하고 그에 따라 자신의 내부 상태를 변경한다. 그 다음엔 스토어는 변경사항을 등록된 뷰들에게 전파하고, 이는 다시 렌더링을 일으키며, 이로써 하나의 순환이 완성된다. 리덕스 설치 1$ npm install redux --save 리액트-리덕스 설치 1$ npm install react-redux --save 애니메이션과 제스처 Animated LayoutAnimation PanResponder 1$ react-native install react-native-vector-icons https://www.decoide.org react-native-web 1$ npm install --save react react-native-web https://github.com/Microsoft/react-native-windows 123$ npm install --save-dev rnpm-plugin-windows$ react-native windows$ react-native run-windows https://github.com/ptmt/react-native-macos 1$ npm install react-native-macos-cli -g 참조 링크 https://github.com/jondot/awesome-react-native http://reactnative.cc https://devchat.tv/react-native-radio http://www.reactnative.com https://github.com/react-native-training/react-natvie-training https://expo.io https://js.coach/?search=react-native https://github.com/donglowder/react-native-appletv","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jacegem.github.io/blog/tags/react/"},{"name":"react-native","slug":"react-native","permalink":"http://jacegem.github.io/blog/tags/react-native/"},{"name":"native","slug":"native","permalink":"http://jacegem.github.io/blog/tags/native/"},{"name":"app","slug":"app","permalink":"http://jacegem.github.io/blog/tags/app/"}]},{"title":"스마트폰 앱 UI 디자인 패턴의 이해","slug":"2018/스마트폰-앱-UI-디자인-패턴의-이해","date":"2018-05-20T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/스마트폰-앱-UI-디자인-패턴의-이해/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%8F%B0-%EC%95%B1-UI-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%9D%B4%ED%95%B4/","excerpt":"","text":"스마트폰 앱 UI 디자인 패턴의 이해 디자인 패턴이란 프로그래밍 시 자주 반복되어 나타나는 문제점을 해결하고자, 과거의 다른 사람이 해결한 결과물을 재사용하기 좋은 형태로 활용한다는 의미로 쓰여졌으며, 특정한 상황에서 구조적인 문제를 해결할 수 있는 방식을 설명 어떠한 목적/기능을 위한 레이아웃을 디자인 함에 있어 콘텐츠, 버튼, 컴포넌트 등의 배치에 대한 디자인 패턴을 의미 스마트폰 앱 UI 디자인 패턴 목적/기능을 위한 레이아웃 요소의 배치 = UI 디자인 패턴 목적/기능에 부합한 용어를 정의하고, 해당 UI 디자인 패턴을 참조 동일 목적의 '타임라인’이더라도, 의도/목적에 따라 달라진다. UI 디자인 패턴 참조 사이트 구글에서 UI DESIGN PATTERN으로 검색 http://inspired-ui.com http://mobilepatterns.com http://mobile-patterns.com http://www.pttrns.com http://androidpttrns.com 공식 개발자 웹사이트 developer.android.com developer.apple.com 모바일 앱 UI 디자인 패턴 실습 설명 바로 PPT 문서로 정리하는 것보다는, 스케치로 구체화하는 것을 권장한다. 정밀하게 표현하는 것보다는, 와이어프레임 방시으로 스케치하면 쉽고 빠르다. 스케치 템플릿을 활용하여 UI 플로우(flow)라 불리우는 화면 간의 연결(네비게이션) 표현을 할 수 있다. 필요할 경우, 동일한 목적의 페이지를 여러 개 디자인하고 비교/평가 할 수 있다. 스마트폰 앱 UI 스토리보드를 활용한 레이아웃 디자인 스마트폰 앱 UI 스토리보드의 이해 모든 앱의 공통 구성 페이지: 앱 아이콘 &gt; 런치 이미지 &gt; 메인 페이지의 전개 UI 스토리보드 핵심 구성 페이지 먼저 기획/디자인 한다. App ICON, Launch Image, Main Menu, Main Content, Settings… 앱의 전개 방식도 카테고리별 공통적인 디자인 패턴이 존재한다. UI 스토리보드 작업 방법 어느 페이지가 사용자에게 더 중요한 정보를 담고 있는가? 연필을 사용하여 작업하고, 컬러 펜으로 네비게이션 등을 표시한다. 표현은 와이어프레임으로, 간결하게 하는 것이 좋다. 필요한 경우, 팝업이나 키보드가 올라오는 페이지의 경우 포스트잇을 활용한다. UI 스토리보드를 활용한 리서치 UI 스토리보드를 활용하여 스케치로 다른 앱의 구조를 그린다면, 굉장히 짧은 시간안에 앱의 전체적인 구조, 네비게이션, 목적 지향적 UI 구조를 파악할 수 있다. 기본 구성 페이지 외에도 인 앱 결제의 프로세스, 로그인 페이지의 구성 등 다양한 부분에 대한 전체 구조적 관점에서 분석이 가능하다. 페이지 구성시 로그인, 회원 가입, 결제 프로세스 등과 같이 트렌드 및 기술에 따라 사용자가 민감하게 반응하는 디자인 패턴 부분은, 해당 문제 부분이 무엇인지를 먼저 정의한 다음, 동일 카테고리의 앱이 아니더라도 해당 문제에 대한 답을 가지고 있는 앱의 특정 부분만 분석 비교함으로써 쉽게 문제에 대한 해답을 찾아낼 수 있다. 예시 질문: 커피 주문 앱의 경우, 결제 단계 및 프로세스가 잘 기획이 안될 때는? 해답: 결제 프로세스를 전무능로 하고 있는 피자 주문, 배달 주문 앱 등의 해당 프로세스 부분만 UI 스토리보드로 스케치하여 분석/비교 한다. UI 스토리보드, 스마트폰 템플릿을 활용한 실습 설명 1. UI 스토리보드를 먼저 작업한다. 전체 구조를 파악할 수 있고, 작은 사이즈로 작업하게 되므로 디테일 보다는 주요 콘텐츠/기능에만 관심을 둘 수 있어서 작업 속도를 빠르게 할 수 있는 장점이 있다. 2. 반드시 관련 정보를 기입한다. 앱의 이름, 작성 날짜, 작성자, 해당 버전, 대상 디바이스의 종류 등 앱과 관련된 필수 사항들을 기록해 두어야 추구 관리가 쉽다. 3. 네비게이션, 그룹핑, 제스처-모션 등의 요소도 반드시 기입하라. 컬러 펜을 사용하여 네비게이션을 통한 페이지 이동, 제스처에 따른 모션의 방향 등의 요소는 반드시 기입한다. 4. 그룹핑, 페이지 네이밍도 기록하라. 각 페이지별로 어떠한 역할 혹은 디자인 패턴 명칭으로 불리울 지를 감안하고 네이밍하고, 여러 페이지로 구성될 경우에는 그룹핑+네이밍을 표시한다. 5. 스케치에 문제가 생길 경우, 다시 그리지 말고 포스트잇을 활용하라. 실수로 잘못 그리거나, 해당 페이지의 내용이 바뀌어 진다면 포스트있을 붙이면 된다. 메인 플로우 UI 디자인 스케치 UI 스토리보드를 통해 러프하게 그려진 레이아웃을, 큰 사이즈로 그리면서 보다 구체화 큰 사이즈 작업 시에는 실제 터치 영역 사이즈, 폰트의 크기, 아이콘의 구체적 형태 등에 대해서도 확정 네비게이션-인터랙션 디자인 부분을 커럴 펜으로 표시 구체적인 사용자 유즈 케이스 혹은 시나리오를 작성하는 것도 큰 도움 키보드, 팝업 같은 요소는 1개의 폐이지로 별도 구성하지 않는다. 포스트 있을 활용하여 작업 UI 스케치를 활용한 디지털 프로토타이핑 테스트 디지털 프로토타이핑의 이해 실제 스마트폰에서 앱을 사용하는 것처럼, 스마트폰 앱 혹은 관련 서비스를 통해 스크린에서 터치 제스처, 화면의 이동, 터치에 따른 반응 등의 UI 조작 및 인터랙션을 테스트 디지털 프로토타이핑을 하는 경우, inVision, FluidUI, Axure, Balsamiq, FarmerJS 등 수 많은 서비스가 존재한다. UI 사용자 테스트 진행 방법 UI 사용자 테스트는 사용자 테스트를 통해 실제 기획/디자인 의도와 사용자의 실제 사용 방식을 확인하고 평가하는 과정 씽크어라우드 (Think Aloud) 사용자가 구체적인 행동을 하는 이유를 말로 표현하게 하여 행동의 이유/근거에 대해 알 수 있는 방법 관찰 실제 사용자의 행동을 관찰하여 인사이트, 아이디어를 얻는 방법이다. 이를 통해 사용자 중심의 구성이 가능하다. 출처 SK 동반성장아카데미 Origami Studio — Design Prototyping STUDIO | The next generation design tool","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"}],"tags":[{"name":"app","slug":"app","permalink":"http://jacegem.github.io/blog/tags/app/"},{"name":"ui","slug":"ui","permalink":"http://jacegem.github.io/blog/tags/ui/"},{"name":"ux","slug":"ux","permalink":"http://jacegem.github.io/blog/tags/ux/"},{"name":"design","slug":"design","permalink":"http://jacegem.github.io/blog/tags/design/"},{"name":"pattern","slug":"pattern","permalink":"http://jacegem.github.io/blog/tags/pattern/"}]},{"title":"스마트폰 앱 UX/UI 디자인","slug":"2018/스마트폰-앱-UXUI-디자인","date":"2018-05-20T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/스마트폰-앱-UXUI-디자인/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%8A%A4%EB%A7%88%ED%8A%B8%ED%8F%B0-%EC%95%B1-UXUI-%EB%94%94%EC%9E%90%EC%9D%B8/","excerpt":"","text":"스마트폰 앱 UX/UI 디자인 UI, UX의 정의 최종 사용자를 대상으로 제품/서비스가 디자인 되어야 한다. 컨텍스트는 제품 혹은 서비스를 이용하게 되는 사용자의 상황에서 육하원칙을 대입해서 생각해보는 방식이다. 인간 속성, 디바이스 특성, 비즈니스 목적이 조화롭게 개발/디자인 되어야 한다. UX 디자인의 정의 실제 그 제품을 사용하는 사용자를 대상으로 하여, 제품/서비스와 접하고 사용하는 모든 과정에 대해 사용자가 만족할 수 있는 가치를 제공하도록 디자인하는 것 스마트폰 앱의 UX 중요성 사용자의 특성 실내/실외 등 다양한 상황에서 스마트폰 앱을 사용하는 경우가 많다. 단순히 날씨 하나만을 위한 앱, 사진만 찍는 앱 등 사용자의 니즈는 데스크톱 앱에 비해 훨씬 적고 명확한 기능을 원한다. 스마트폰 앱 개발의 특성 개발자의 관점과 사용자 관점의 차이 UI의 의미 제품의 물리적인 형태인 PUI, 소리로 정보를 전해 주는 AUI, 시각의 측면으로 조작 정보, 콘텐츠를 표혀하는 GUI로 구성 인터렉션 디자인과 GUI의 이해 인터랙션 디자인이란 무엇인가 사용자는 제품과 소통하고, 그 소통 방식과 피드백을 인터랙션이라 한다. 인터랙션은 사용자의 행동에 반응하는 동작을 의미하며 통합적으로 진행된다. 어포던스의 이해 형태에 따라서 자연스러운 행동이 유도되고 그 행동은 학습(과거 혹은 현재)을 통해서 원하는 기능을 제공해주고, 사용자는 의도한 방식으로 사용을 마칠 수 있다. UX/UI 디자인 프로세스의 이해 GUI의 기본 구성 요소로는 컬러, 타이포그래피, 레이아웃이 있다. 단순히 디자이너가 원하는 스타일로 디자인하는 것이 아니라, GUI 디자인 또한 사용자와 비즈니스 목표를 염두해 두고 디자인 되어야 한다. UX 디자인의 적용 개발자는 사용자에게 필요한 기능, 콘텐츠 등에 중점을 두는 것 보다는 구현 가능한 기술, 내가 볼 수 있는 문제점에만 중점을 두어서 개발하는게 일반적이다. 시장 초기(구현 중심) → 시장 후기(차별화 중점) UX 디자인 관점을 도입하는 경우는, 사용자부터 시작하여 디자인/기획을 하기 때문에 보다 근본적인 개념에서의 제품/서비스 개발이 이루어질 수 있다. 오포던스(Affordance) 사용자가 해당 제품의 동작 연계를 쉽게 인지할 수 있는 형태로 디자인을 하게 되면, 사용자는 자연스럽게 행동을 하게 됨. 인터랙션 디자인에 있어 굉장히 중요한 요소로써, 이를 통해 사용자는 의도한 방식대로 쉽게 사용을 마칠 수 있게 됨 스마트폰 앱 UI 디자인 패턴의 이해 UX 디자인 방법론이란 사용자 조사 리서치 분석, 모델링 페르소나 스토리보드 프로토타이핑 UX는 사용자를 구체화하는 과정 화면에 콘텐츠/기능적 요소들을 배치하는 UI는 다른 개념 사용자 조사/리서치 인터뷰, 문헌연구, PEST 분석, 사례 연구를 통해 사용자의 니즈와 불편 사항을 도출하고 외부적 상황을 파악. 아울러 사례 연구를 통해 스마트폰 앱의 범주와 형태를 구체적으로 파악 어피니티 다이어그래밍 어피니티 다이어그래밍을 활용하여 페르소나와 내부 실무진들의 의견을 반영하여 분류하고 구성할 수 있도록 한다. 페르소나 사용자 중심 디자인을 위해, 실제 사용자로부터 얻은 정보를 재구성하여 대표 사용자인 페르소나를 구축한다. 시나리오/스토리보드 사용자가 스마트폰 앱을 사용하는 시나리오를 작성하고, 그에 맞는 스토리보드를 그려서 컨텍스트의 요소를 도출한다. 프로토타입 스케치 스토리보드에 적용되는 스마트폰 앱 페이지를 종이와 펜을 사용하여 스케치를 통해 구조화 UI 단계로 넘어가는 과정이며, UI 스토리보드, 메인 페이지 스케치도 이 범주에 포함 UI 사용자 테스트 최종적으로 기획한 스마트폰 앱 프로토타입을 사용자를 대상으로 테스트할 수 있는 방법을 학습 UX 디자인 프로세스의 의미 출발 지점과 도착 지점을 정하고, 해당 목적지까지 도달하기 위한 경로를 기획하는 것과 유사하다. 구체적인 행동과 역할, 방법 등이 필요한다. 초기 기획과 달라질 수도 있는 점을 미리 감안하고 어느 정도 융통성 있게 프로젝트를 진행하는 자세가 필요 IDEO '확산과 수렴’이라고 하는 (기회) 목색과 (정리) 수렴 단계를 반복하며 결과물을 만들어 가는 과정 발견 Discovery 해석 Interpretation 아이데이션 Ideation 실험 Experimentation 향상 Evolution 사용자 조사 및 리서치 PEST 방법론 (거시환경분석) Political(정치적), Economic(경제적), Social(사회적), Technological(기술적) 요소를 포함하여 분석 경우에 따라서 Lega(법적), Environmental(환경적) 요소들을 포함하여 PESTLE 혹은 PESTEL로 부르기도 한다. 환경 파악에 핵심적인 요소를 지정하여 파악하는 방법으로 제약, 기회, 진행 방향 등을 파악하는데 있어 효과적 어피니티 다이어그래밍을 활용한 모델링 리서치 결과는 기준별로 정리 이슈 기준 정리 컨텍스트 기준 정리 사용자 경험 기준 정리 리서치 결과를 정리한 후에, 프로젝트에 필요하고 사용자에게도 가치를 줄 수 있는 주요 내용을 도출하여, 최종적으로 핵심 가치를 도출할 수 있어야 함. 어피니티 다이어그래밍을 통해 데이터를 정리하고 재배열해서 상위 개념을 도출하는 모델링을 진행할 수 있음. 어피니티 다이어그래밍 여러 정보들을 재배치하여 의미있는 결론을 이끌어 내는 방식 그룹핑과 헤더가 기본적인 구조화 방식이라 할 수 있다. 포스트잇 색상별로 사용 (노란색: 낱개 정보) 어피니티 다이어그램의 진행 주의사항 간결하고 짧은 어투로 기록한다. 범주를 잡지 못하는 어피니티 노트들은 잠시 다른 곳에 둔다. 헤더는 적절한 범위를 내재해야 한다. 너무 많은 요소를 포함하고 있는 상위 개념이거나, 너무 좁은 범위는 좋지 않다. 진행시 프로젝트 팀원들이 모두 참여하는 것이 좋다. 컴퓨터에서 디자인툴이나 문서툴을 사용하는 것보다 직접 적어서 붙이고 토론하고 정리하는 것을 권장한다. 목소리 높은 사람이 주도하는 것이 아니라, 노트에 적어서 붙이고 이를 통해 의견을 정리하도록 한다. 페르소나 구성 각기 다른 관점에서 사용자를 인식하므로 공통된 사용자의 모습을 갖기 위해서 페르소나를 활용한다. 페르소나란 제품/서비스를 대표할 수 있는 가상의 사용자를 구성하여 제품/서비스/개발/기획/디자인 전반에 걸쳐 사용자의 관점을 적용하는데 사용한다. 페르소나 구성시 사용자를 이해할 수 있는 다양한 정보를 기록한다. 주요특징 사진 사용자 스토리 기타 추가 정보 페르소나의 구성시 주의 사항 각 페르소나들은 서로 구체적인 차이점을 가지고 있어야 한다. 실제 사용자와 같은 느낌을 전달해야 한다. 제품/서비스 프로젝트와 직접적인 연관성이 있어야 한다. 적절한 수의 페르소나를 구축 1회 사용하고 버리지 않는다. 일부 부서에서만 공감하면 안 된다. 주요 페르소나와 부가 페르소나로 구분 구체적인 시사점을 제공 동기, 시나리오, 콘텐츠, 기능 등을 도출 시나리오 작성과 스토리보드 구성 페르소나가 제품/서비스를 사용하는 상황을 텍스트로 구체화한 것이 시나리오 시나리오의 구성 제품과 접점이 되는 경우에 대한 내용을 중점적으로 기술 텍스트로 구성, 6하원칙(컨텍스트)에 최대한 맞춰서 기술 페르소나가 중심으로 기술 유저 스토리와도 유사한 개념, 구체적인 니즈와 동기, 감정적인 부분도 기술 과장하거나 지나치게 감정적인 내용을 쓰지 않는다. 스토리보드의 구성 실제 사용자가 제품/서비스를 사용하는 상황을 시각적으로 표현 6하원칙 및 사용자의 감정과 제품/서비스에서 전달하고자 하는 기능/가치가 표현된다. 사용자는[WHO]는 백화점[WHERE]에서 신발을 찾고자 함 [WHAT] 이 때, 백화점 앱을 사용하여 신발 파는 곳을 찾아낸 후 [HOW] 제품을 공유 기능을 통해 페이스북에 제품 정보를 공유 [HOW] 스토리보드의 구성 시 주의 사항 반드시 그림을 잘 그릴 필요는 없다. 경우에 따라 동영상으로 제작하거나 완성도를 더욱 높일 수도 있다. 하나의 페르소나라도 다양한 시나리오가 존재, 여러 개의 스토리보드를 그릴 수 있다. 기획 초기 단계의 경우에는 구체적인 기능, 항목, 인터페이스를 표현하는 것을 자제하는 게 나을 수 있다. (기능적 한계가 나올 수 있다.) 프로토타입 스케치 실제 제품을 제작하기 이전에 사전 테스트하는 목적으로 만드는 시제품의 형태를 의미 프로토타입의 제작과 프로토타이핑은 테스트를 목적으로 한다. 출처 SK 동반성장아카데미 Origami Studio — Design Prototyping STUDIO | The next generation design tool","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"}],"tags":[{"name":"app","slug":"app","permalink":"http://jacegem.github.io/blog/tags/app/"},{"name":"ui","slug":"ui","permalink":"http://jacegem.github.io/blog/tags/ui/"},{"name":"ux","slug":"ux","permalink":"http://jacegem.github.io/blog/tags/ux/"},{"name":"design","slug":"design","permalink":"http://jacegem.github.io/blog/tags/design/"}]},{"title":"[책] Learning React","slug":"2018/Learning-React","date":"2018-05-16T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Learning-React/","link":"","permalink":"http://jacegem.github.io/blog/2018/Learning-React/","excerpt":"","text":"[책] Learning React 알렉스 뱅크스,이브 포셀로 공저/오현석 역 리액트를 사용하는 전체 사이트 https://github.com/facebook/react/wiki/Sites-Using-React 예약어와 className 자바스크립트에는 개발자가 임의로 변수나 객체 이름 등에 사용할 수 없는 예약어가 있다. ES2016 기준으로 그 예약어 목록은 다음과 같다. break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield 리액트가 지원하는 전체 태그와 속성: https://facebook.github.io/react/docs/tags-and-attributes.html 대소문자 구별 대소문자의 구별은 중요한 사항이다. HTML 엘리먼트를 나타낼 때는 태그를 소문자로 써야 한다. 컴포넌트를 나타낼 때는 그 이름에 대문자가 사용돼야 한다. 대소문자 구별을 정확히 해야 한다. 이벤트 https://www.kirupa.com/html5/javascript_events.htm 합성 이벤트(synthetic evnet)라고 하는 리액트에 특정적인 이벤트 유형인 SyntheticEvent 를 다룬다. 항상 브라우저의 네이티브 이벤트를 wrapping 하는 SyntheticEvent 타입을 인자로 받는다. SyntheticEvent 문서 : https://facebook.github.io/react/docs/events.html 리액트에서 이벤트 핸들러 안의 this 는 DOM 세게에서와는 다르다. 리액트가 아닌 세계에서 이벤트 핸들러 안의 this 는 리스닝하는 대상 엘리먼트를 참조한다. 컴포넌트 생명주기 https://www.kirupa.com/react/lifecycle_example.htm 초기 렌더링 단계 getDefaultProps getInitialState componentWillMount render componentDidMount 업데이트 단계 shouldComponentUpdate componentWillUpdate render componentDidUpdate 속성 변경 시 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 언마운트 단계 componentWillUnmount 리액트 라우터 매칭되는 URL 일 경우 각자 지정된 컴포넌트를 화면에 보여준다. 원한다면 Route 를 중첩해 사용할 수 있다. 1234567891011ReactDOM.render( &lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Home&#125; /&gt; &lt;Route path=&quot;stuff&quot; component=&#123;Stuff&#125;&gt; &lt;Route path=&quot;blah&quot; component=&#123;Blah&#125;/&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;Router&gt;, destination); https://github.com/ReactTraining/react-router/blob/v3/docs/guides/RouteMatching.md React Router: Declarative Routing for React.js 액티브 링크 Link 인스턴스에 activeClassName 이라는 속성을 설정하고 링크가 액티브하게 되면 적용할 CSS 클래스의 이름을 지정한다. 12345678910111213var App = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;h1&gt;Simple SPA&lt;/h1&gt; &lt;ul className=&quot;header&quot; &gt; &lt;li&gt;&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;Home&lt;/Link&gt;&lt;/li&gt; ... &lt;/ul &lt;/div&gt; ) &#125;&#125;) React! React! React! https://www.kirupa.com/react/setting_up_react_environment.htm 바벨: https://babeljs.io/ npm 문서: https://docs.npmjs.com/ 웹팩: https://webpack.github.io/ 바우어(Bower): https://bower.io","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jacegem.github.io/blog/tags/react/"},{"name":"learning","slug":"learning","permalink":"http://jacegem.github.io/blog/tags/learning/"}]},{"title":"[책] 빠른 모바일 앱 개발을 위한 React Native","slug":"2018/빠른-모바일-앱-개발을-위한-React Native","date":"2018-05-15T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/빠른-모바일-앱-개발을-위한-React Native/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EB%B9%A0%EB%A5%B8-%EB%AA%A8%EB%B0%94%EC%9D%BC-%EC%95%B1-%EA%B0%9C%EB%B0%9C%EC%9D%84-%EC%9C%84%ED%95%9C-React%20Native/","excerpt":"","text":"[책] 빠른 모바일 앱 개발을 위한 React Native 자바스크립트로 만드는 네이티브 모바일 앱 개발 가이드 바니 아이젠먼 저/이종은 역 플랫폼 API XHR 은 XMLHttpRequest 의 줄임말이다. XHR 을 이용하여 사진을 POST 로 요청하는 기본 구조 12345var xhr = new XMLHttpRequest();xhr.open(&quot;POST&quot;, &quot;http://posttestserver.com/post.php&quot;);var formdata = new FormData();formdata.append(&quot;image&quot;, &#123; ...this.state.photo, name: &quot;image.jpg&quot; &#125;);xhr.send(formdata); Promise 는 비동기 방식을 처리할때 사용되는 객체이다. https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise SmarterWeather 프로젝트 폴더 및 파일 구조 SmarterWeather Forecast index.js LocationButton index.js style.js PhotoBackdrop camera_roll_example.js index.js local_image.js style.js android app build build.gradle gradle gradle.properties gradlew gradlew.bat settings.gradle index.android.js index.ios.js ios SmarterWeather SmarterWeather.xcodeproj SmarterWeatherTests main.jsbundle node_modules react-native package.json styles typography.js weather_project.js 모듈 lodash 와 underscore 는 유용한 함수들을 모아둔 자바스크립트 유틸리티로 거의 동일한 기능과 API 구조이다. 두 라이브러리는 합쳐질 예정이다. rnpm (React Native Package Manager) RCTBridgeModule 해더 불어오기 RCTBridgeModule 인터페이스 정의하기 RCT_EXPORT_MODULE 매크로 실행하기 RCT_EXPORT_METHOD 매크로를 이용하여 하나 이상의 함수를 익스포트(export)하기 brew update brew upgrade brew upgrade node rm -rf node_modules npm install (yarn) 안드로이드 애플리케이션 배포하기 로만 프로젝트 : https://romannurik.github.io/AndroidAssetStudio/icons-launcher.html 배포용 APK 만들기 서명 키 생성 그래들(gradle) 변수 설정 애플리케이션 그래들 설정에 서명 설정 추가 배포용 APK 생성 배포용 APK 를 디바이스에 설치 1$ keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 ~/.gradle/gradle.properties 에 변수 추가 1234MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEAES_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=******MYAPP_RELEASE_KEY_PASSWORD=****** 1$ cd android &amp;&amp; ./gradlew assembleRelease 프로젝트의 android/ 디렉토리에서 다음 명령어를 실행하여 서명된 APK 를 설치할 수 있다. 1$ ./gradlew installRelease ES6 문법 비구조화 ES5 123var myObj = &#123; a: 1, b: 2 &#125;;var a = myObj.a;var b = myObj.b; ES6 비구조화 1var &#123; a, b &#125; = myObj; 모듈 불러오기 ES5 12345var OtherComponent = require(&#x27;./other_component&#x27;);var MyComponent = React.createClass(&#123; ...&#125;);module.exports = MyComponent; ES6 모듈 불러오기 12345import OtherComponent from &#x27;./other_component&#x27;;var MyComponent = React.createClass(&#123; ...&#125;);export default MyComponent; 함수 축약 표현식 ES5 123render: function()&#123; return &lt;Text&gt;hi&lt;/Text&gt;&#125; ES6 함수 축약 표현식 123render() &#123; return &lt;Text&gt;hi&lt;/Text&gt;&#125; 화살표 함수 ES5 123var callbackFunc = function(val) &#123; console.log(&quot;Do something&quot;);&#125;.bind(this); ES6 화살표 함수 123var callbackFunc = val =&gt; &#123; console.log(&quot;Do something&quot;);&#125;; 문자열 조립 ES5 12var API_KEY = &quot;abcd&quot;;var url = &quot;http://someapi.com/request?key=&quot; + API_KEY; ES6 문자열 조립 12var API_KEY = &quot;abcd&quot;;var url = `http://someapi.com/request?key=&#123;API_KEY&#125;`; 클래스 ES5 12345var HelloMessage = React.createClass(&#123; render: function()&#123; ... &#125;&#125;); ES6 클래스 12345class HelloMessage extends Component &#123; render() &#123; ... &#125;&#125; 출처 https://github.com/yomybaby/learning-react-native/blob/master/Depends/iOS/PianoStairs.mp4?raw=true https://github.com/brentvatne/react-native-video https://facebook.github.io/react-native/docs/native-modules-android.html https://github.com/brentvatne/react-native-linear-gradient","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"react","slug":"react","permalink":"http://jacegem.github.io/blog/tags/react/"},{"name":"native","slug":"native","permalink":"http://jacegem.github.io/blog/tags/native/"}]},{"title":"Amazfit Bip Font Creator 5 - 실행 파일 생성","slug":"2018/Amazfit-Bip-Font-Creator-5-실행-파일-생성","date":"2018-05-14T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Amazfit-Bip-Font-Creator-5-실행-파일-생성/","link":"","permalink":"http://jacegem.github.io/blog/2018/Amazfit-Bip-Font-Creator-5-%EC%8B%A4%ED%96%89-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1/","excerpt":"","text":"Amazfit Bip Font Creator 5 - 실행 파일 생성 실행 파일은 pyinstaller 로 생성합니다. 먼저 pyinstaller 를 설치합니다. 1$ pip install pyinstaller 이 후 pyinstaller 파일명 을 입력하여 exe파일을 생성할 수 있습니다. 여기서 몇 가지 옵션을 사용합니다. 1$ pyinstaller --onefile --clean --windowed --icon=.\\assets\\font.ico Amazfit_Bip_Font_Creator.py –onefile : 하나의 파일로 생성합니다. 이 옵션이 없으면 여러개의 파일로 생성됩니다 –clean : 기존 파일들을 삭제합니다. –windowed : 윈도우창으로 실행되도록 합니다. 이 옵션이 없으면 cmd 창으로 실행됩니다. –icon: 아이콘을 지정합니다. 이렇게 생성하면 내부적으로 사용하는 리소스가 표현되지 않을 수 있습니다. spec 파일 수정 pyinstaller 파일명 을 실행하면 같은 경로에 파일명.spec파일이 생성됩니다. 123456789101112131415161718192021222324252627282930# -*- mode: python -*-block_cipher = Nonea = Analysis([&#x27;Amazfit_Bip_Font_Creator.py&#x27;], pathex=[&#x27;C::\\\\YOUR_PATH&#x27;], binaries=[], datas=[], hiddenimports=[], hookspath=[], runtime_hooks=[], excludes=[], win_no_prefer_redirects=False, win_private_assemblies=False, cipher=block_cipher)pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)exe = EXE(pyz, a.scripts, a.binaries, a.zipfiles, a.datas, name=&#x27;Amazfit_Bip_Font_Creator&#x27;, debug=False, strip=False, upx=True, runtime_tmpdir=None, console=False , icon=&#x27;assets\\\\font.ico&#x27;) 여기에 a.datas 로 리소스를 추가합니다. 1a.datas += [(&#x27;.\\\\assets\\\\font.png&#x27;, &#x27;.\\\\assets\\\\font.png&#x27;, &#x27;DATA&#x27;)] 추가한 spec 파일입니다. 123456789101112131415161718192021222324252627282930# -*- mode: python -*-block_cipher = Nonea = Analysis([&#x27;Amazfit_Bip_Font_Creator.py&#x27;], pathex=[&#x27;C::\\\\YOUR_PATH&#x27;], binaries=[], datas=[], hiddenimports=[], hookspath=[], runtime_hooks=[], excludes=[], win_no_prefer_redirects=False, win_private_assemblies=False, cipher=block_cipher)a.datas += [(&#x27;.\\\\assets\\\\font.png&#x27;, &#x27;.\\\\assets\\\\font.png&#x27;, &#x27;DATA&#x27;)]pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)exe = EXE(pyz, a.scripts, a.binaries, a.zipfiles, a.datas, name=&#x27;Amazfit_Bip_Font_Creator&#x27;, debug=False, strip=False, upx=True, runtime_tmpdir=None, console=False , icon=&#x27;assets\\\\font.ico&#x27;) 이 후 spec파일을 사용하여 exe를 생성합니다. 1$ pyinstaller Amazfit_Bip_Font_Creator.spec 그러면 /dist 폴더에 Amazfit_Bip_Font_Creator.exe파일이 생성됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"},{"name":"amazfit","slug":"amazfit","permalink":"http://jacegem.github.io/blog/tags/amazfit/"},{"name":"bip","slug":"bip","permalink":"http://jacegem.github.io/blog/tags/bip/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jacegem.github.io/blog/tags/pyqt5/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"http://jacegem.github.io/blog/tags/pyinstaller/"}]},{"title":"Amazfit Bip Font Creator 4 - 폰트 생성","slug":"2018/Amazfit-Bip-Font-Creator-4-폰트-생성","date":"2018-05-13T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Amazfit-Bip-Font-Creator-4-폰트-생성/","link":"","permalink":"http://jacegem.github.io/blog/2018/Amazfit-Bip-Font-Creator-4-%ED%8F%B0%ED%8A%B8-%EC%83%9D%EC%84%B1/","excerpt":"","text":"Amazfit Bip Font Creator 4 - 폰트 생성 쓰레드 초기화가 끝났으면, font_creator_thread.start()로 run을 실행합니다. 123456789101112class FontCreator(QThread): # 생략 def run(self): self.set_progress_text.emit(&quot;1/2&quot;) self.create_bmp() self.set_progress_text.emit(&quot;2/2&quot;) self.pack_bmp() if self.delete_bmp: shutil.rmtree(self.bmp_dir) self.done.emit() 먼저 bmp 파일들을 생성하고 패킹하여 폰트파일을 생성합니다. create_bmp 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# bip_font_creator.pyimport osimport binasciiimport globimport shutilfrom PyQt5.QtCore import QThread, pyqtSignalfrom fontTools.ttLib import TTFontfrom PIL import ImageFont, ImageDraw, Imageall_range = (0x0000, 0xFFFF)black_histogram = [256, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] class FontCreator(QThread): # 생략 def create_bmp(self): for i in range(all_range[0], all_range[1]): self.set_progress.emit(i, all_range[1]) result = self.char_in_font(chr(i), self.tt_font) if result is False: # print(&#x27;없음: &#123;&#125;&#x27;.format(i)) continue image = Image.new(&#x27;1&#x27;, (16, 16), &quot;black&quot;) draw = ImageDraw.Draw(image) draw.text((self.margin_left, self.margin_top), chr(i), font=self.image_font, fill=&quot;white&quot;) if i is not 32 and i is not 127 and image.histogram() == black_histogram: print(&quot;&#123;:04x&#125; is black&quot;.format(i)) continue file_name = &quot;bmp/&#123;:04x&#125;2.bmp&quot;.format(i) file_path = os.path.join(self.root_path, file_name) if self.overwrite_bmp: if os.path.isfile(file_path): continue image.save(file_path, &quot;bmp&quot;) pyqtSignal 로 전달하기 위해 emit을 호출합니다. 1self.set_progress.emit(i, all_range[1]) all_range = (0x0000, 0xFFFF) 로 전체 범위의 폰트 bmp 를 생성합니다. 폰트파일에 해당 문자 가 있는지 확인하기 위해 char_in_font 함수를 호출합니다. 12345678class FontCreator(QThread): # 생략 def char_in_font(self, unicode_char, font): for cmap in font[&#x27;cmap&#x27;].tables: if cmap.isUnicode(): if ord(unicode_char) in cmap.cmap: return True return False 해당 문자가 폰트 파일에 있으면 True를 리턴합니다. 없으면 False Image 로 text 를 생성한 다음 빈 문자인지 확인하기 이해 histogram을 비교합니다. 1234567image = Image.new(&#x27;1&#x27;, (16, 16), &quot;black&quot;)draw = ImageDraw.Draw(image)draw.text((self.margin_left, self.margin_top), chr(i), font=self.image_font, fill=&quot;white&quot;)if i is not 32 and i is not 127 and image.histogram() == black_histogram: print(&quot;&#123;:04x&#125; is black&quot;.format(i)) continue black_histogram 은 위에서 정의한 배열입니다. black_histogram = [256, 0, ... , 0] 그리고 덮여쓰기 설정 여부에 따라 이미지를 저장합니다. (save) 12345if self.overwrite_bmp: if os.path.isfile(file_path): continueimage.save(file_path, &quot;bmp&quot;) pack_bmp 123456789class FontCreator(QThread): # 생략 def pack_bmp(self): base = os.path.basename(self.font_path) file, ext = os.path.splitext(base) ft_file_name = &#x27;amazfit_bip_&#123;&#125;.ft&#x27;.format(file) print(&#x27;ft_file_name&#x27;, ft_file_name) ft_path = os.path.join(self.ft_dir, ft_file_name) self.pack_font(ft_path) pack_font 는 tools/bipfont.py at master · amazfitbip/tools · GitHub 를 사용하였습니다. 실행파일에서 사용하기 위해 경로 관련된 부분만 변경하였습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class FontCreator(QThread): # 생략 def pack_font(self, font_path): print(&#x27;Packing&#x27;, font_path) font_file = open(font_path, &#x27;wb&#x27;) header = bytearray(binascii.unhexlify(&#x27;4E455A4B08FFFFFFFFFF01000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000&#x27;)) bmps = bytearray() range_nr = 0 seq_nr = 0 startrange = -1 bmp_files = sorted(glob.glob(os.path.join(self.root_path, &#x27;bmp&#x27; + os.sep + &#x27;*&#x27;))) bmp_len = len(bmp_files) path_len = len(self.root_path) + 1 for i in range(0, bmp_len): print(&#x27;pack_font&#x27;, i, bmp_len) self.set_progress.emit(i, bmp_len) margin_top = int(bmp_files[i][path_len + 8]) if (i == 0): unicode = int(bmp_files[i][path_len + 4:-5], 16) else: unicode = next_unicode if (i + 1 &lt; len(bmp_files)): next_unicode = int(bmp_files[i + 1][path_len + 4:-5], 16) else: next_unicode = -1 if (unicode != next_unicode): if (startrange == -1): range_nr += 1 startrange = unicode img = Image.open(bmp_files[i]) img_rgb = img.convert(&#x27;RGB&#x27;) pixels = img_rgb.load() x = 0 y = 0 char_width = 0 while y &lt; 16: b = 0 for j in range(0, 8): if pixels[x, y] != (0, 0, 0): b = b | (1 &lt;&lt; (7 - j)) if (x &gt; char_width): char_width = x x += 1 if x == 16: x = 0 y += 1 bmps.extend(b.to_bytes(1, &#x27;big&#x27;)) char_width = char_width * 16 + margin_top bmps.extend(char_width.to_bytes(1, &#x27;big&#x27;)) if unicode + 1 != next_unicode: endrange = unicode sb = startrange.to_bytes(2, byteorder=&#x27;big&#x27;) header.append(sb[1]) header.append(sb[0]) eb = endrange.to_bytes(2, byteorder=&#x27;big&#x27;) header.append(eb[1]) header.append(eb[0]) seq = seq_nr.to_bytes(2, byteorder=&#x27;big&#x27;) header.append(seq[1]) header.append(seq[0]) seq_nr += endrange - startrange + 1 startrange = -1 else: print(&#x27;multiple files of &#123;:04x&#125;&#x27;.format(unicode)) rnr = range_nr.to_bytes(2, byteorder=&#x27;big&#x27;) header[0x20] = rnr[1] header[0x21] = rnr[0] font_file.write(header) font_file.write(bmps) 실행 완료 실행이 완료되면 실행파일 경로에 config.ini 파일이 생성됩니다. OK 메시지 창이 출력됩니다. 그리고 ft 폴더안에 폰트 파일이 생성됩니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"},{"name":"amazfit","slug":"amazfit","permalink":"http://jacegem.github.io/blog/tags/amazfit/"},{"name":"bip","slug":"bip","permalink":"http://jacegem.github.io/blog/tags/bip/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jacegem.github.io/blog/tags/pyqt5/"}]},{"title":"Cesium-React 적용","slug":"2018/Cesium-React-적용","date":"2018-05-13T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Cesium-React-적용/","link":"","permalink":"http://jacegem.github.io/blog/2018/Cesium-React-%EC%A0%81%EC%9A%A9/","excerpt":"","text":"Cesium-React 적용 출처: cesium-react - npm create-react-app react 프로젝트 생성 123create-react-app cesium-react-testcd cesium-react-testyarn eject yarn install 모듈 설치 cesium cesium-react html-webpack-include-assets-plugin copy-webpack-plugin 1yarn add cesium cesium-react html-webpack-include-assets-plugin copy-webpack-plugin webpack.config 수정 config/webpack.config.dev.js 1234567891011121314151617181920212223242526272829303132// config/webpack.config.dev.jsconst HtmlIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;);const CopyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;);module.exports = &#123; externals: &#123; cesium: &quot;Cesium&quot; &#125;, plugins: &#123; new CopyWebpackPlugin([ &#123; from: &quot;node_modules/cesium/Build/CesiumUnminified&quot;, to: &quot;cesium&quot; &#125; ]), new HtmlIncludeAssetsPlugin(&#123; append: false, assets: [ &quot;cesium/Widgets/widgets.css&quot;, &quot;cesium/Cesium.js&quot; ] &#125;), new webpack.DefinePlugin(&#123; &quot;process.env&quot;: &#123; CESIUM_BASE_URL: JSON.stringify(&quot;/cesium&quot;) &#125; &#125;), // ... &#125; // ...&#125; config/webpack.config.prod.js 1234567891011121314151617181920212223242526272829303132// config/webpack.config.prod.jsconst HtmlIncludeAssetsPlugin = require(&quot;html-webpack-include-assets-plugin&quot;);const CopyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;);module.exports = &#123; externals: &#123; cesium: &quot;Cesium&quot; &#125;, plugins: &#123; new CopyWebpackPlugin([ &#123; from: &quot;node_modules/cesium/Build/Cesium&quot;, to: &quot;cesium&quot; &#125; ]), new HtmlIncludeAssetsPlugin(&#123; append: false, assets: [ &quot;cesium/Widgets/widgets.css&quot;, &quot;cesium/Cesium.js&quot; ] &#125;), new webpack.DefinePlugin(&#123; &quot;process.env&quot;: &#123; CESIUM_BASE_URL: JSON.stringify(&quot;/cesium&quot;) &#125; &#125;), // ... &#125; // ...&#125; 소스 수정 App.js 수정 12345678910111213141516import React, &#123; Component &#125; from &quot;react&quot;;import logo from &quot;./logo.svg&quot;;import &quot;./App.css&quot;;import CesiumPage from &quot;./CesiumPage&quot;;class App extends Component &#123; render() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;CesiumPage /&gt; &lt;/div&gt; ); &#125;&#125;export default App; CesiumPage.js 생성 1234567891011121314151617181920import React, &#123; Component &#125; from &quot;react&quot;;import &#123; Cartesian3 &#125; from &quot;cesium&quot;;import &#123; Viewer, Entity &#125; from &quot;cesium-react&quot;;class CesiumPage extends Component &#123; render() &#123; return ( &lt;div&gt; cesium page &lt;Viewer full&gt; &lt;Entity name=&quot;Seoul&quot; position=&#123;Cartesian3.fromDegrees(126.97224, 37.40076, 100)&#125; point=&#123;&#123; pixelSize: 10 &#125;&#125;&gt; test &lt;/Entity&gt; &lt;/Viewer&gt; &lt;/div&gt; ); &#125;&#125;export default CesiumPage;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"React","slug":"React","permalink":"http://jacegem.github.io/blog/tags/React/"},{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://jacegem.github.io/blog/tags/react/"},{"name":"3D","slug":"3D","permalink":"http://jacegem.github.io/blog/tags/3D/"},{"name":"gis","slug":"gis","permalink":"http://jacegem.github.io/blog/tags/gis/"},{"name":"Cesium","slug":"Cesium","permalink":"http://jacegem.github.io/blog/tags/Cesium/"}]},{"title":"Amazfit Bip Font Creator 3 - 쓰레드 실행","slug":"2018/Amazfit-Bip-Font-Creator-3-쓰레드-실행","date":"2018-05-12T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Amazfit-Bip-Font-Creator-3-쓰레드-실행/","link":"","permalink":"http://jacegem.github.io/blog/2018/Amazfit-Bip-Font-Creator-3-%EC%93%B0%EB%A0%88%EB%93%9C-%EC%8B%A4%ED%96%89/","excerpt":"","text":"Amazfit Bip Font Creator 3 - 쓰레드 실행 쓰레드 생성 12345678910111213141516171819202122232425262728293031# bip_font_creator.pyimport osimport binasciiimport globimport shutilfrom PyQt5.QtCore import QThread, pyqtSignalfrom fontTools.ttLib import TTFontfrom PIL import ImageFont, ImageDraw, Imageclass FontCreator(QThread): set_progress_text = pyqtSignal(str) set_progress = pyqtSignal(int, int) done = pyqtSignal() def __init__(self, font_path, margin_top, margin_left, delete_bmp, overwrite_bmp, root_path, parent=None): QThread.__init__(self, parent) self.font_path = font_path self.margin_top = int(margin_top) self.margin_left = int(margin_left) self.delete_bmp = delete_bmp self.overwrite_bmp = overwrite_bmp self.tt_font = TTFont(self.font_path) self.image_font = ImageFont.truetype(self.font_path, 15) self.root_path = root_path self.bmp_dir = None self.ft_dir = None self.bmp_dir = self.create_directory(&#x27;bmp&#x27;) self.ft_dir = self.create_directory(&#x27;ft&#x27;) QThread 를 상속받아 구현합니다. font_path : 폰트 파일 경로 margin_top : 비트맵 상단 여백 margin_left : 비트맵 좌측 여백 delete_bmp : 비트맵 삭제 여부 overwrite_bmp : 비트맵 덮어쓰기 여부 root_path : 실행 경로 parent : 부모 쓰레드 parent를 꼭 __init__을 해주어야 합니다. 1QThread.__init__(self, parent) pyqtSignal 부모 쓰레드에 전달을 위한 시그널을 3개 생성합니다. 123set_progress_text = pyqtSignal(str)set_progress = pyqtSignal(int, int)done = pyqtSignal() set_progress_text : 텍스트 변경시 사용 set_progress : 진행률 변경시 사용 done : 완료시 사용 123456789class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def create_font(self): # .. 생략 .. font_creator_thread = FontCreator(font_path, margin_top, margin_left, delete_bmp, overwrite_bmp, self.root_path, self) font_creator_thread.set_progress_text.connect(self.set_progress_text) font_creator_thread.set_progress.connect(self.set_progress) font_creator_thread.done.connect(self.create_done) font_creator_thread.start() AmazfitBipFontCreator 에서 create_font 실행시에, 부모 쓰레드 전달을 위해 self를 넘겨주었습니다. 그리고 시그널 들을 함수에 연결하였습니다. set_progress_text.connect(self.set_progress_text) set_progress.connect(self.set_progress) done.connect(self.create_done) pyqtSignal Connect 123456789101112131415161718192021222324from PyQt5.QtCore import pyqtSlot# .. 생략 .. class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. @pyqtSlot(str) def set_progress_text(self, text): self.lbl_prog.setText(text) @pyqtSlot(int, int) def set_progress(self, current, end): val = current / end * 100 self.progress.setValue(int(val)) @pyqtSlot() def create_done(self): self.set_progress_text(&#x27;Finished&#x27;) self.set_progress(1, 1) self.btn_create.setEnabled(True) msg_box = QMessageBox() msg_box.setWindowTitle(&#x27;Font Creator&#x27;) msg_box.setText(&#x27;Finished&#x27;) msg_box.addButton(QPushButton(&#x27;OK&#x27;), QMessageBox.NoRole) msg_box.exec() @pyqtSlot 어노테이션을 사용하고 파라미터 타입(str)을 지정합니다. @pyqtSlot(str) @pyqtSlot(int, int) @pyqtSlot() 완료 시그널이 보내지면 OK메시지 창을 보여줍니다. 12345msg_box = QMessageBox()msg_box.setWindowTitle(&#x27;Font Creator&#x27;)msg_box.setText(&#x27;Finished&#x27;) msg_box.addButton(QPushButton(&#x27;OK&#x27;), QMessageBox.NoRole) msg_box.exec()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"},{"name":"amazfit","slug":"amazfit","permalink":"http://jacegem.github.io/blog/tags/amazfit/"},{"name":"bip","slug":"bip","permalink":"http://jacegem.github.io/blog/tags/bip/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jacegem.github.io/blog/tags/pyqt5/"},{"name":"thread","slug":"thread","permalink":"http://jacegem.github.io/blog/tags/thread/"}]},{"title":"Amazfit Bip Font Creator 2 - 이벤트 구현","slug":"2018/Amazfit-Bip-Font-Creator-2-이벤트-구현","date":"2018-05-11T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Amazfit-Bip-Font-Creator-2-이벤트-구현/","link":"","permalink":"http://jacegem.github.io/blog/2018/Amazfit-Bip-Font-Creator-2-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EA%B5%AC%ED%98%84/","excerpt":"","text":"Amazfit Bip Font Creator 2 - 이벤트 구현 Select TTF file 버튼 이벤트 Font File Create 버튼 이벤트 Select TTF file 123456class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def get_create_box(self): # .. 생략 .. btn_ttf = QPushButton(&#x27;Select TTF file&#x27;) btn_ttf.clicked.connect(lambda: self.select_file(self.lbl_ttf)) 이벤트 처리시에 파라미터 전달을 위해 lambda로 구현하였습니다. 파일선택다이얼로그에서 파일을 선택할 경우 라벨에 표시하기 위해 표시 대상(self.lbl_ttf)을 전달합니다. 123456789101112131415class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def select_file(self, target): # Select the file dialog design. dialog_style = QFileDialog.DontUseNativeDialog dialog_style |= QFileDialog.DontUseCustomDirectoryIcons # Open the file dialog to select an image file. file_chosen, _ = QFileDialog.getOpenFileName(self, &quot;QFileDialog.getOpenFileName()&quot;, &quot;&quot;, &quot;TTF (*.ttf)&quot;) # Show the path of the file chosen. if file_chosen: target.setText(file_chosen) else: target.setText(&quot;No file was selected. Please select an TTF.&quot;) 파일다이얼로그를 *.ttf 로 조건을 설정합니다. 파일선택시 넘겨진 대상 target에 텍스트를 설정합니다. 파일이 선택되지 않으면 “No file was selected. Please select an TTF.” 문자열을 설정합니다. Font File Create 123456789class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def get_create_box(self): # .. 생략 .. self.btn_create = FullButton(&#x27;&#x27;&#x27;Font File Create *.ft file will be created in the ft sub-folder&#x27;&#x27;&#x27; ) self.btn_create.clicked.connect(self.create_font) Font File Create 버튼이 눌리면 self.create_font를 실행합니다. 1234567891011121314151617181920212223242526272829class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def create_font(self): print(&#x27;run test from main&#x27;) font_path = self.lbl_ttf.text() delete_bmp = self.chk_delete_bmp.isChecked() overwrite_bmp = self.chk_overwrite_bmp.isChecked() margin_top = self.sb_margin_top.text() margin_left = self.sb_margin_left.text() if not font_path.lower().endswith(&#x27;.ttf&#x27;): msg_box = QMessageBox() msg_box.setText(&quot;Please Select TTF File&quot;) msg_box.exec() return self.config[&#x27;PATH&#x27;] = &#123;&#125; self.config[&#x27;PATH&#x27;][&#x27;ttf&#x27;] = font_path with open(self.config_file_name, &#x27;w&#x27;) as configfile: self.config.write(configfile) self.btn_create.setEnabled(False) self.set_progress_text(&#x27;Start!&#x27;) font_creator_thread = FontCreator(font_path, margin_top, margin_left, delete_bmp, overwrite_bmp, self.root_path, self) font_creator_thread.set_progress_text.connect(self.set_progress_text) font_creator_thread.set_progress.connect(self.set_progress) font_creator_thread.done.connect(self.create_done) font_creator_thread.start() 폰트 생성에 필요한 설정값들을 설정합니다. 12345font_path = self.lbl_ttf.text()delete_bmp = self.chk_delete_bmp.isChecked()overwrite_bmp = self.chk_overwrite_bmp.isChecked()margin_top = self.sb_margin_top.text()margin_left = self.sb_margin_left.text() font 파일이 설정되지 않았다면 메시지 창을 보여주고 return 합니다. 12345if not font_path.lower().endswith(&#x27;.ttf&#x27;): msg_box = QMessageBox() msg_box.setText(&quot;Please Select TTF File&quot;) msg_box.exec() return font 파일이 정확히 설정되었다면 다음 실행시에 사용하기 위해 ini 파일에 기록합니다. 1234self.config[&#x27;PATH&#x27;] = &#123;&#125;self.config[&#x27;PATH&#x27;][&#x27;ttf&#x27;] = font_pathwith open(self.config_file_name, &#x27;w&#x27;) as configfile: self.config.write(configfile) 폰트 생성을 시작할 준비가 되었다면 버튼을 비활성화 합니다. 12self.btn_create.setEnabled(False)self.set_progress_text(&#x27;Start!&#x27;) 폰트 생성을 위한 스레드를 실행합니다. 12345font_creator_thread = FontCreator(font_path, margin_top, margin_left, delete_bmp, overwrite_bmp, self.root_path, self)font_creator_thread.set_progress_text.connect(self.set_progress_text)font_creator_thread.set_progress.connect(self.set_progress)font_creator_thread.done.connect(self.create_done)font_creator_thread.start()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"},{"name":"amazfit","slug":"amazfit","permalink":"http://jacegem.github.io/blog/tags/amazfit/"},{"name":"bip","slug":"bip","permalink":"http://jacegem.github.io/blog/tags/bip/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jacegem.github.io/blog/tags/pyqt5/"}]},{"title":"Amazfit Bip Font Creator 1 - UI 구성","slug":"2018/Amazfit-Bip-Font-Creator-1-UI-구성","date":"2018-05-10T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Amazfit-Bip-Font-Creator-1-UI-구성/","link":"","permalink":"http://jacegem.github.io/blog/2018/Amazfit-Bip-Font-Creator-1-UI-%EA%B5%AC%EC%84%B1/","excerpt":"","text":"Amazfit Bip Font Creator 1 - UI 구성 Amazfit Bip 에서 사용할 폰트를 생성합니다. Qt5를 사용하여 UI를 생성합니다. Qt5 사용 QT에서 UI를 생성할 경우 QMainWindow를 사용시에는 Widget을 생성하고 setCentrlWidget을 호출해야 합니다. 123456class AmazfitBipFontCreator(QMainWindow): def __init__(self): widget = QWidget() # UI 구성 self.setCentralWidget(widget) self.show() 위와 다르게, QWidget, QDialog를 사용한다면 그냥 self.show()를 해서 보여줄 수 있습니다. 1234class AmazfitBipFontCreator(QDialog): def __init__(self): # UI 구성 self.show() 화면 구성 폰트 파일 선택 Margin 설정 옵션 설정 폰트 생성 진행률 표시 위와 같이 화면구성을 하겠습니다. QMainWindow 12345678910111213141516171819202122232425262728293031323334# Amazfit_Bip_Font_Creator.pyimport configparserimport osimport sysimport webbrowserfrom PyQt5.QtCore import pyqtSlotfrom PyQt5.QtGui import QIconfrom PyQt5.QtWidgets import (QMainWindow, QApplication, QDesktopWidget, QGroupBox, QWidget, QFileDialog, QLabel, QLineEdit, QMessageBox, QSpinBox, QPushButton, QStyleFactory, QHBoxLayout, QVBoxLayout, QCheckBox, QProgressBar)from qt.bip_font_creator import FontCreatorfrom qt.button import DonateButton, FullButtonclass AmazfitBipFontCreator(QMainWindow): def __init__(self): super().__init__() self.title = &#x27;Amazfit Bip - Font Creator (v0.1)&#x27; self.left = 10 self.top = 10 self.width = 700 self.height = 300 self.lbl_ttf = None # Font file name self.chk_delete_bmp = None # option delete bmp self.chk_overwrite_bmp = None self.lbl_prog = None self.progress = None self.sb_margin_top = None self.sb_margin_left = None self.initUI() self.center() self.initUI()에서 화면을 구성하며 self.cetner()에서 화면 중앙으로 이동합니다. 1234567891011121314151617181920212223242526class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def center(self): # geometry of the main window qr = self.frameGeometry() # center point of screen cp = QDesktopWidget().availableGeometry().center() # move rectangle&#x27;s center point to screen&#x27;s center point qr.moveCenter(cp) # top left of rectangle becomes top left of window centering it self.move(qr.topLeft()) def initUI(self): self.setWindowTitle(self.title) self.setMinimumWidth(self.width) self.setMinimumHeight(self.height) widget = QWidget() widget.setLayout(self.get_layout()) self.setCentralWidget(widget) icon = QIcon(self.resource_path(&#x27;assets/font.png&#x27;)) self.setWindowIcon(icon) self.show() self.get_layout()에서 화면을 구성하겠습니다. 12345678910111213141516171819class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def get_layout(self): layout = QVBoxLayout() vbox_create = QVBoxLayout() vbox_create.addLayout(self.get_create_box()) hbox_progress = QHBoxLayout() self.lbl_prog = QLabel(&#x27;Done&#x27;) hbox_progress.addWidget(self.lbl_prog) self.progress = QProgressBar() self.progress.setMaximum(100) self.progress.setMinimum(0) hbox_progress.addWidget(self.progress) layout.addLayout(vbox_create) layout.addLayout(hbox_progress) return layout QVBoxLayout() 으로 설정 부분과 진행률 부분을 나눕니다. QVBoxLayout() 으로 설정을 위한 항목들을 나눕니다. QHBoxLayout() 으로 진행률을 표시합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def get_create_box(self): create_box = QVBoxLayout() create_group = QGroupBox(&#x27;Create&#x27;) create_layout = QVBoxLayout() # TTF 선택 라벨, 버튼 row_ttf = QHBoxLayout() self.lbl_ttf = QLineEdit(&#x27;No file selected&#x27;) self.lbl_ttf.setDisabled(True) self.lbl_ttf.setMinimumWidth(300) row_ttf.addWidget(self.lbl_ttf) btn_ttf = QPushButton(&#x27;Select TTF file&#x27;) btn_ttf.clicked.connect(lambda: self.select_file(self.lbl_ttf)) row_ttf.addWidget(btn_ttf) # margin-top, margin-left row_margin = QHBoxLayout() row_margin.addWidget(QLabel(&#x27;Margin-Top:&#x27;)) self.sb_margin_top = QSpinBox() self.sb_margin_top.setMinimum(-99) row_margin.addWidget(self.sb_margin_top) row_margin.addWidget(QLabel(&#x27;Margin-Left:&#x27;)) self.sb_margin_left = QSpinBox() self.sb_margin_left.setMinimum(-99) row_margin.addWidget(self.sb_margin_left) # 옵션들 row_option = QHBoxLayout() self.chk_delete_bmp = QCheckBox(&#x27;Delete BMP files&#x27;) self.chk_delete_bmp.setChecked(True) row_option.addWidget(self.chk_delete_bmp) self.chk_overwrite_bmp = QCheckBox(&#x27;Overwrite BMP files&#x27;) row_option.addWidget(self.chk_overwrite_bmp) # create 버튼 row_create = QHBoxLayout() self.btn_create = FullButton(&#x27;&#x27;&#x27;Font File Create *.ft file will be created in the ft sub-folder&#x27;&#x27;&#x27; ) self.btn_create.clicked.connect(self.create_font) row_create.addWidget(self.btn_create) # 전체 순서 결정 create_layout.addLayout(row_ttf) create_layout.addLayout(row_margin) create_layout.addLayout(row_option) create_layout.addLayout(row_create) # set layer create_group.setLayout(create_layout) create_box.addWidget(create_group) return create_box QSspinBox에서 음수를 사용하기 위해서는 setMinimum을 설정해야 합니다. 1self.sb_margin_top.setMinimum(-99) FullButton Button을 자주사용하게 되어 FullButton 클래스를 생성하였습니다. 최대크기로 버튼을 생성합니다. 12345678# button.pyfrom PyQt5.QtWidgets import QPushButton, QSizePolicyclass FullButton(QPushButton): def __init__(self, title): super().__init__(title) super().setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding) resource_path assets/font.png 파일을 아이콘으로 사용합니다. pyinstaller로 실행파일을 생성했을 때에는 경로가 달라지므로, resource_path함수를 사용하였습니다. 123456class AmazfitBipFontCreator(QMainWindow): # .. 생략 .. def resource_path(self, relative_path): if hasattr(sys, &#x27;_MEIPASS&#x27;): return os.path.join(sys._MEIPASS, relative_path) return os.path.join(os.path.abspath(&quot;.&quot;), relative_path)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"},{"name":"amazfit","slug":"amazfit","permalink":"http://jacegem.github.io/blog/tags/amazfit/"},{"name":"bip","slug":"bip","permalink":"http://jacegem.github.io/blog/tags/bip/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jacegem.github.io/blog/tags/pyqt5/"}]},{"title":"Cesium Viewer 화면 설정 확인 ","slug":"2018/Cesium-Viewer-화면-설정-확인","date":"2018-05-08T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Cesium-Viewer-화면-설정-확인/","link":"","permalink":"http://jacegem.github.io/blog/2018/Cesium-Viewer-%ED%99%94%EB%A9%B4-%EC%84%A4%EC%A0%95-%ED%99%95%EC%9D%B8/","excerpt":"","text":"Cesium Viewer 화면 설정 확인 Viewer - Cesium Documentation 에서 자세한 내용을 확인 할 수 있습니다. animation: false 123456789101112131415161718192021import React, &#123; Component &#125; from &quot;react&quot;import &#123; Viewer &#125; from &quot;cesium&quot;class CesiumPage3 extends Component &#123; componentDidMount() &#123; this.viewer = new Viewer(this.cesiumContainer, &#123; animation: false, &#125;) &#125; render() &#123; return ( &lt;div className=&quot;cesiumWidget&quot; ref=&#123;element =&gt; (this.cesiumContainer = element)&#125; /&gt; ) &#125;&#125;export default CesiumPage3 좌측 하단의 애니메이션 위젯이 사라졌습니다. timeline: false 1234this.viewer = new Viewer(this.cesiumContainer, &#123; animation: false, timeline: false,&#125;) 하단의 타임라인 위젯이 사라졌습니다. navigationHelpButton: false 12345this.viewer = new Viewer(this.cesiumContainer, &#123; animation: false, timeline: false, navigationHelpButton: false,&#125;) 우측 상단의 네비게이션 도움말 버튼이 사라졌습니다. fullscreenButton: false 123456this.viewer = new Viewer(this.cesiumContainer, &#123; animation: false, timeline: false, navigationHelpButton: false, fullscreenButton: false,&#125;) 우측 하단의 전체화면 버튼이 사라졌습니다. AccessToken 설정 https://cesium.com/ion/tokens 에서 가입하면 발급되는 Access Token을 사용합니다. Default 토큰를 사용하였습니다. 오른쪽의 복사 버튼을 클릭하면 토큰이 복사됩니다. 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &quot;react&quot;import &#123; Viewer, Ion &#125; from &quot;cesium&quot;class CesiumPage3 extends Component &#123; componentDidMount() &#123; Ion.defaultAccessToken = &quot;eyJclkjciOiJIUzI1NiIsInR5acvf6IkpXVCJ9.eyJqdGkiOiIFHGzNjFkZC0zMmRmLTRkN2EtOWJiasdcWQ0MzYyOGUzMDkiLCJpZCI6Nzc4LCJpYXQiOjE1MjU4MjkzMTF9_YOUR_ACCESS_TOKEN&quot; this.viewer = new Viewer(this.cesiumContainer, &#123; animation: false, timeline: false, navigationHelpButton: false, fullscreenButton: false, &#125;) &#125; render() &#123; return ( &lt;div className=&quot;cesiumWidget&quot; ref=&#123;element =&gt; (this.cesiumContainer = element)&#125; /&gt; ) &#125;&#125;export default CesiumPage3 하단의 AccessToken관련 메시지가 사라졌습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"react","slug":"react","permalink":"http://jacegem.github.io/blog/tags/react/"},{"name":"cesium","slug":"cesium","permalink":"http://jacegem.github.io/blog/tags/cesium/"},{"name":"viewer","slug":"viewer","permalink":"http://jacegem.github.io/blog/tags/viewer/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 8 - heroku 배포","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-8-Heroku-배포","date":"2018-05-07T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-8-Heroku-배포/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-8-Heroku-%EB%B0%B0%ED%8F%AC/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 8 - heroku 배포 파일 추가 heroku 에서 운영하기 위해 필요한 파일들을 추가합니다. Procfile requirements.txt runtime.txt uwsgi.ini Procfile 1web: uwsgi uwsgi.ini requirements.txt 로컬에서 실행할 때와는 다른게 uwsgi 를 추가해야 합니다. 1234FlaskFlask_RESTfulfirebase-adminuwsgi runtime.txt 실행 환경을 지정합니다. 1python-3.6.4 uwsgi.ini 실행 모듈을 지정합니다. kakotalk_lunch_bot.py 에 있는 app을 실행합니다. 123456[uwsgi]http-socket = :$(PORT)master = truedie-on-term = truemodule = kakaotalk_lunch_bot:appmemory-report = true Github 가입 및 배포 4 개의 파일을 추가한 후 Github 에 배포합니다. Heroku 에서 github 에 연결한 후에 Deploy 를 할 것입니다. Heroku 가입 및 앱 추가 Cloud Application Platform | Heroku에 배포해서 플러스친구를 운영하겠습니다. 가입을 하고 로그인을 합니다. 앱을 생성합니다. 이름은 kakao-lunch-bot 으로 지정하였습니다. 동일한 이름은 사용이 불가능하므로 다른 이름을 지정하여야 합니다. Deployment method 대시보드 - Deploy 에서 GitHub 를 연결합니다. 물론 소스는 GitHub 에 배포되어 있어야 합니다. App connected to GitHub heroku 에 배포할 Github 저장소를 검색해서 선택합니다. Manual deploy Manual deploy 에서 Deploy Branch 버튼을 눌러 배포를 시작합니다. 정상적으로 배포가 되면 녹색 체크박스로 나타나게 되고 아래에 View버튼이 생성됩니다. 누르면 해당 주소로 이동해서 웹브라우저에서 확인할 수 있습니다. 플러스친구 스마트채팅 설정 카카오톡 플러스친구 관리자 센터에 로그인을 합니다. 생성한 플러스친구를 선택합니다. 좌측 사이드 메뉴 중에서 스마트채팅을 선택합니다. 우측에 있는 API형에서 Edit 를 선택합니다. 앱 URL에 heroku 에 배포한 URL 을 등록합니다. 서버가 정상적으로 동작하면 API 테스트 시에 결과를 확인할 수 있습니다. Heroku Pricing 무료는 30 분간 활성화가 되지 않으면 잠자기 모드로 진입합니다. 잠자기 모드일 경우에 웹 접속이 발생하면 그 때 시동이 되기 때문에 결과값을 받는데 오래 걸립니다. Heroku CLI Heroku CLI | Heroku Dev Center에서 CLI 를 설치합니다. 로그인 123$ heroku login- 계정 입력- 비밀번호 입력 로그 확인 로그인 상태에서 진행합니다. -a 파라미터로 앱 이름을 지정합니다. 1$ heroku logs -a [HEROKU 앱 이름] 로그 tail 지속적으로 로그를 확인합니다. 1$ heroku logs --tail -a [HEROKU 앱 이름]","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 7 - 설정 & 그룹 설정","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-7-설정-&-그룹-설정","date":"2018-05-06T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-7-설정-&-그룹-설정/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-7-%EC%84%A4%EC%A0%95-&-%EA%B7%B8%EB%A3%B9-%EC%84%A4%EC%A0%95/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 7 - 설정 &amp; 그룹 설정 설정 #설정 버튼을 누를 경우를 처리합니다. 12345678910class Message(Resource): def post(self): select = Select(self.args) setting = Setting(self.args) if self.content == Const.BTN_SELECT_LUNCH: return select.show_restaurant_list() elif self.content == Const.BTN_SETTING: return setting.show_setting_list() setting.show_setting_list() 함수를 호출합니다. 1234567891011121314151617181920212223242526from firebase_admin import firestorefrom conf.const import Constfrom conf.firebaseInit import fsfrom conf.util import Utilfrom events.args import Argsclass Setting(Args): def show_setting_list(self): try: user = fs.collection(Const.COL_USER).document(self.user_key).get() group = user.get(Const.FIELD_GROUP) except: return Select.show_group_list() rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;현재 [&#123;&#125;] 그룹으로 설정되어 있습니다.&#x27;.format(group) &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [Const.BTN_ADD_RESTAURANT, Const.BTN_DELETE_RESTAURANT, Const.BTN_SETTING_GROUP, Const.BTN_DOANTE, Const.BTN_GOTO_START] &#125; &#125; return Util.send_response(rst) 식당 추가 식당 삭제 그룹 설정 후원하기 시작으로 버튼 목록을 반환합니다. 그룹 설정 #그룹 선택 버튼이 눌러진 경우를 처리합니다. content를 비교하고 그룹목록을 버튼으로 반환합니다. 1234567891011class Message(Resource): def post(self): select = Select(self.args) setting = Setting(self.args) result = Result(self.args) if self.content == Const.BTN_SELECT_LUNCH: return select.show_restaurant_list() elif self.content == Const.BTN_SETTING_GROUP: return select.show_group_list() 1234567891011121314151617181920212223242526class Select(Args): def show_group_list(self): # 상태 설정 fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_SELECT_GROUP &#125;, firestore.CreateIfMissingOption(True)) # 그룹 목록 가져오기 groups = fs.collection(Const.COL_GROUP).get() group_list = [] for doc in groups: group_list.append(doc.id) group_list.append(Const.BTN_GOTO_START) rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;그룹을 선택해 주세요&#x27; &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: group_list &#125; &#125; return Util.send_response(rst)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 6 - 식당 추가 & 식당 삭제","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-6-식당-추가-&-식당-삭제","date":"2018-05-05T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-6-식당-추가-&-식당-삭제/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-6-%EC%8B%9D%EB%8B%B9-%EC%B6%94%EA%B0%80-&-%EC%8B%9D%EB%8B%B9-%EC%82%AD%EC%A0%9C/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 6 - 식당 추가 &amp; 식당 삭제 식당 추가 식당 추가의 경우 세 단계로 진행됩니다. 이름 입력 사진 입력 최종 확인 이름 정보와 사진 정보를 데이터베이스에 입력하고, 최종 확인시에 해당 데이터를 저장합니다. 123456789101112131415161718192021222324class Message(Resource): def post(self): select = Select(self.args) setting = Setting(self.args) result = Result(self.args) if self.content == Const.BTN_SELECT_LUNCH: return select.show_restaurant_list() elif self.content == Const.BTN_ADD_RESTAURANT: return setting.show_add_restaurant() elif self.content == Const.BTN_ADD_RESTAURANT_CONFIRM: return setting.add_restaurant() # 사용자 입력처리 user = fs.collection(Const.COL_USER).document(self.user_key).get() user_state = user.get(Const.FIELD_STATE) if user_state == Const.STATE_SELECT_GROUP: return select.group_selected() elif user_state == Const.STATE_ADD_RESTAURANT_TITLE: return setting.show_add_restaurant_desc() elif user_state == Const.STATE_ADD_RESTAURANT_DESC: return setting.show_add_restaurant_confirm() 버튼은 두번 처리가 되며 BTN_ADD_RESTAURANT BTN_ADD_RESTAURANT_CONFIRM 상태 역시 두번 처리 됩니다. STATE_ADD_RESTAURANT_TITLE STATE_ADD_RESTAURANT_DESC 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116class Setting(Args): def show_add_restaurant(self): # state : add_restaurant # 1. 이름을 입력해 주세요 # 2. 설명을 작성해 주세요. # 상태 설정 fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_ADD_RESTAURANT &#125;, firestore.CreateIfMissingOption(True)) rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;음식점 이름을 입력해 주세요&#x27; &#125; &#125; return Util.send_response(rst) def show_add_restaurant_desc(self): # content = 음식점 이름 # 상태 설정 fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_ADD_RESTAURANT_DESC &#125;, firestore.CreateIfMissingOption(True)) fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_ADD_RESTAURANT_TITLE: self.content &#125;) rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;음식점 사진을 추가해 주세요&#x27; &#125; &#125; return Util.send_response(rst) def show_add_restaurant_confirm(self): fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_ADD_RESTAURANT_CONFIRM &#125;, firestore.CreateIfMissingOption(True)) fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_ADD_RESTAURANT_DESC: self.content &#125;, firestore.CreateIfMissingOption(True)) user = fs.collection(Const.COL_USER).document(self.user_key).get() title = user.get(Const.FIELD_ADD_RESTAURANT_TITLE) desc = self.content if Util.is_img(desc): rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;입력하신 음식점은 다음과 같습니다.\\n\\n이름:&#123;&#125;\\n\\n등록하시겠습니까?&#x27;.format(title), &quot;photo&quot;: &#123; &quot;url&quot;: desc, &quot;width&quot;: 640, &quot;height&quot;: 480 &#125; &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [ Const.BTN_ADD_RESTAURANT_CONFIRM, Const.BTN_GOTO_START ] &#125; &#125; else: rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;입력하신 음식점은 다음과 같습니다.\\n\\n이름:&#123;&#125;\\n설명:&#123;&#125;\\n\\n등록하시겠습니까?&#x27;.format(title, desc) &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [ Const.BTN_ADD_RESTAURANT_CONFIRM, Const.BTN_GOTO_START ] &#125; &#125; return Util.send_response(rst) def add_restaurant(self): user = fs.collection(Const.COL_USER).document(self.user_key).get() group = user.get(Const.FIELD_GROUP) title = user.get(Const.FIELD_ADD_RESTAURANT_TITLE) desc = user.get(Const.FIELD_ADD_RESTAURANT_DESC) try: ref = fs.collection(Const.COL_GROUP).document(group).get() restaurant = ref._data.get(Const.FIELD_RESTAURANT) except: restaurant = &#123;&#125; if restaurant is None: restaurant = &#123;&#125; restaurant[title] = &#123; &#x27;desc&#x27;: desc, &#x27;user&#x27;: self.user_key, &#x27;added&#x27;: Util.get_day_str() &#125; if Util.is_img(desc): restaurant[title][Const.FIELD_IMG_SRC] = desc fs.collection(Const.COL_GROUP).document(group).update(&#123;Const.FIELD_RESTAURANT: restaurant&#125;, firestore.CreateIfMissingOption(True)) if Util.is_img(desc): msg = &#x27;[&#123;&#125;] 이(가) 등록되었습니다&#x27;.format(title) return Util.show_start_menu(msg, desc) msg = &#x27;이름:&#123;&#125;\\n설명:&#123;&#125;\\n등록되었습니다&#x27;.format(title, desc) return Util.show_start_menu(msg) 식당 삭제 해당 그룹의 식당 목록을 보여주고, 사용자가 선택하면 해당 식당 정보를 제거합니다. /message로 부터 시작합니다. 123456789101112131415161718192021class Message(Resource): def post(self): select = Select(self.args) setting = Setting(self.args) result = Result(self.args) if self.content == Const.BTN_SELECT_LUNCH: elif self.content == Const.BTN_DELETE_RESTAURANT: return setting.show_delete_restaurant() elif self.content == Const.BTN_DELETE_RESTAURANT_CONFIRM: return setting.delete_restaurant() # 사용자 입력처리 user = fs.collection(Const.COL_USER).document(self.user_key).get() user_state = user.get(Const.FIELD_STATE) if user_state == Const.STATE_SELECT_GROUP: return select.group_selected() elif user_state == Const.STATE_DELETE_RESTAURANT: return setting.show_delete_restaurant_confirm() 식당을 선택하는 버튼과 확인하는 버튼을 처리합니다. BTN_DELETE_RESTAURANT BTN_DELETE_RESTAURANT_CONFIRM 식당 삭제 상태를 처리합니다. STATE_DELETE_RESTAURANT 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Setting(Args): def show_delete_restaurant(self): fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_DELETE_RESTAURANT &#125;, firestore.CreateIfMissingOption(True)) user = fs.collection(Const.COL_USER).document(self.user_key).get() group = user.get(Const.FIELD_GROUP) ref = fs.collection(Const.COL_GROUP).document(group).get() restaurants = ref._data.get(Const.FIELD_RESTAURANT) restaurant_list = [] for key, val in restaurants.items(): restaurant_list.append(key) restaurant_list.append(Const.BTN_GOTO_START) rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;삭제할 대상을 선택해 주세요&#x27; &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: restaurant_list &#125; &#125; return Util.send_response(rst) def show_delete_restaurant_confirm(self): fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_DELETE_RESTAURANT &#125;, firestore.CreateIfMissingOption(True)) fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_DELETE_RESTAURANT_TITLE: self.content &#125;, firestore.CreateIfMissingOption(True)) title = self.content rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;[&#123;&#125;] 을(를) 삭제하겠습니까?&#x27;.format(title) &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [ Const.BTN_DELETE_RESTAURANT_CONFIRM, Const.BTN_GOTO_START ] &#125; &#125; return Util.send_response(rst) def delete_restaurant(self): user = fs.collection(Const.COL_USER).document(self.user_key).get() group = user.get(Const.FIELD_GROUP) title = user.get(Const.FIELD_DELETE_RESTAURANT_TITLE) try: ref = fs.collection(Const.COL_GROUP).document(group).get() restaurant = ref._data.get(Const.FIELD_RESTAURANT) del restaurant[title] except: restaurant = &#123;&#125; fs.collection(Const.COL_GROUP).document(group).update(&#123;Const.FIELD_RESTAURANT: restaurant&#125;, firestore.CreateIfMissingOption(True)) msg = &#x27;[&#123;&#125;] 을(를) 삭제하였습니다.&#x27;.format(title) return Util.show_start_menu(msg)","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 5 - 식당 선택 & 결과 보기","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-5-식당-선택-&-결과-보기","date":"2018-05-04T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-5-식당-선택-&-결과-보기/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-5-%EC%8B%9D%EB%8B%B9-%EC%84%A0%ED%83%9D-&-%EA%B2%B0%EA%B3%BC-%EB%B3%B4%EA%B8%B0/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 5 - 식당 선택 &amp; 결과 보기 사용자가 식당 목록 버튼을 선택하면 /message로 전달됩니다. 이를 처리하여 결과를 보여줍니다. 식당 선택 123456789101112131415161718class Message(Resource): #...생략... def post(self): select = Select(self.args) if self.content == Const.BTN_SELECT_LUNCH: return select.show_restaurant_list() # 사용자 입력처리 user = fs.collection(Const.COL_USER).document(self.user_key).get() user_state = user.get(Const.FIELD_STATE) if user_state == Const.STATE_SELECT_RESTAURANT: return select.restaurant_selected() # default return Util.show_start_menu() 먼저 정의한 버튼인지 확인합니다. 목록에 없으면 사용자계정에서 상태정보를 읽습니다. 123# 사용자 입력처리user = fs.collection(Const.COL_USER).document(self.user_key).get()user_state = user.get(Const.FIELD_STATE) 해당 상태에 맞도록 처리합니다. 식당 선택 상태 였으므로, select.restaurant_selected() 함수를 호출하여 처리합니다. 123456789101112131415161718192021class Select(Args): def restaurant_selected(self): user = fs.collection(Const.COL_USER).document(self.user_key).get() user_group = user.get(Const.FIELD_GROUP) today = Util.get_day_str() fs.collection(Const.COL_SELECT).document(user_group).collection(Const.COL_TODAY).document(today).update(&#123; self.user_key: self.content &#125;, firestore.CreateIfMissingOption(True)) msg = &#x27;[&#123;&#125;] 을(를) 선택하였습니다&#x27;.format(self.content) try: ref = fs.collection(Const.COL_GROUP).document(user_group).get() restaurants = ref._data.get(Const.FIELD_RESTAURANT) target = restaurants.get(self.content) img_src = target.get(Const.FIELD_IMG_SRC) except: img_src = None return Util.show_start_menu(msg, img_src) 사용자의 그룹정보를 얻습니다. 오늘 날짜 정보를 얻습니다. 타임존을 Asia/Seoul로 설정합니다. 12345678910from datetime import datetime, timedeltaimport pytzclass Util: @classmethod def get_day_str(cls, days=0): tz = pytz.timezone(&#x27;Asia/Seoul&#x27;) now = datetime.now(tz) + timedelta(days=days) day_str = now.strftime(&#x27;%Y.%m.%d&#x27;) return day_str 먼저 선택한 정보를 데이터를 입력합니다. 123fs.collection(Const.COL_SELECT).document(user_group).collection(Const.COL_TODAY).document(today).update(&#123; self.user_key: self.content&#125;, firestore.CreateIfMissingOption(True)) 다음과 같은 형태로 저장합니다. select - 그룹 - today - 날짜 - &#123; 사용자키 : 선택식당 &#125; 실데이터를 적용하면 다음과 같습니다. select - 연구소 - today - 2018.05.01 - &#123; JOcneAEi_23 : '북촌손만두' &#125; 선택한 식당에 이미지 정보가 있는지 확인합니다. 있으면 사용자 선택 결과에 이미지를 같이 보내줍니다. 123456ref = fs.collection(Const.COL_GROUP).document(user_group).get()restaurants = ref._data.get(Const.FIELD_RESTAURANT)target = restaurants.get(self.content)img_src = target.get(Const.FIELD_IMG_SRC)return Util.show_start_menu(msg, img_src) 결과 보기 #결과 보기 버튼을 누른 경우를 처리합니다. 코드는 추가된 부분만 작성하도록 하겠습니다. 12345678910class Message(Resource): def post(self): select = Select(self.args) result = Result(self.args) if self.content == Const.BTN_SELECT_LUNCH: return select.show_restaurant_list() elif self.content == Const.BTN_SEE_RESULT: return result.show_result() result.show_result() 를 구현합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# events/result.pyimport operatorfrom conf.const import Constfrom conf.firebaseInit import fsfrom conf.util import Utilfrom events.args import Argsfrom events.select import Selectclass Result(Args): def show_result(self): try: # 해당 그룹에서 가장 많이 나온 순서대로 보여준다. user = fs.collection(Const.COL_USER).document(self.user_key).get() user_group = user.get(Const.FIELD_GROUP) except: print(&#x27;Not Found User Group&#x27;) return Select(self.args).show_group_list() today = Util.get_day_str() today_format = &#x27;[&#123;&#125;]&#x27;.format(today) msg_list = [today_format] result_dict = &#123;&#125; try: result = fs.collection(Const.COL_SELECT).document(user_group).collection(Const.COL_TODAY).document(today).get() for user_key, restaurant in result._data.items(): if restaurant in result_dict: result_dict[restaurant] += 1 else: result_dict[restaurant] = 1 sorted_list = sorted(result_dict.items(), key=operator.itemgetter(1)) sorted_list.reverse() for item in sorted_list: title = item[0] count = item[1] msg_list.append(&#x27;&#123;&#125;명 : &#123;&#125;&#x27;.format(count, title)) except: print(&#x27;Error&#x27;) msg_list.append(&#x27;아직 아무도 선택하지 않았습니다.&#x27;) rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;\\n&#x27;.join(msg_list) &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: Const.DEFAULT_KEYBOARD &#125; &#125; return Util.send_response(rst) 먼저 그룹을 확인합니다. 해당 그룹의 그룹원들이 오늘 선택한 내용을 확인해서 많이 나온 순서대로 정렬하여 결과를 보여줍니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 4 - 식당 목록 전달","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-4-식당-목록-전달","date":"2018-05-03T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-4-식당-목록-전달/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-4-%EC%8B%9D%EB%8B%B9-%EB%AA%A9%EB%A1%9D-%EC%A0%84%EB%8B%AC/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 4 - 식당 목록 전달 파라미터 파라미터 전달을 위해서 Args 클래스를 추가하였습니다. Select, Result, Setting 클래스는 Args 클래스를 상속받도록 합니다. 1234567891011121314# events/args.pyfrom conf.const import Constimport reclass Args: def __init__(self, args): self.args = args self.user_key = args.get(Const.ARG_USER_KEY) self.req_typ = args.get(Const.ARG_TYPE) content = args.get(Const.ARG_CONTENT) content = content.strip() self.content = re.sub(&#x27;^#&#x27;, &#x27;&#x27;, content) 식당 목록 반환 Select 클래스에서 식당 목록을 보여줍니다. 사용자의 상태 정보 select_restaurant으로 변경합니다. 사용자의 그룹정보를 확인합니다. 그룹정보가 없으면 그룹 선택 화면으로 이동합니다. 식당 목록을 확인합니다. 등록된 식당이 없으면 시작 화면으로 이동합니다. 식당 목록을 배열로 생성합니다. 임의의 순서로 변경합니다. 정해진 수 만큼만 반환합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# events/selectimport operatorfrom random import shufflefrom firebase_admin import firestorefrom conf.const import Constfrom conf.firebaseInit import fsfrom conf.util import Utilfrom events.args import Argsclass Select(Args): def show_restaurant_list(self): # 상태 설정 fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_SELECT_RESTAURANT &#125;, firestore.CreateIfMissingOption(True)) # 그룹이 없으면 그룹 선택으로 보낸다. try: user = fs.collection(Const.COL_USER).document(self.user_key).get() user_group = user.get(Const.FIELD_GROUP) except: print(&quot;NotFound user&quot;) return self.show_group_list() try: # 해당 그룹의 식당목록을 가져온다. restaurant_list = [] group = fs.collection(Const.COL_GROUP).document(user_group).get() restaurants = group.get(Const.FIELD_RESTAURANT) for key, val in restaurants.items(): restaurant_list.append(key) except: print(&#x27;No RESTAURANTS&#x27;) return Util.show_start_menu(&#x27;등록된 식당이 없습니다&#x27;) shuffle(restaurant_list) if len(restaurant_list) &gt; Const.SHOW_COUNT: restaurant_list = restaurant_list[:Const.SHOW_COUNT] restaurant_list.append(Const.BTN_GOTO_START) rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;식당을 선택해 주세요&#x27; &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: restaurant_list &#125; &#125; return Util.send_response(rst) 123fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_SELECT_RESTAURANT&#125;, firestore.CreateIfMissingOption(True)) firestore는 컬렉션, 도큐먼트, 컬렉션, 도큐먼트, … 로 구성되어 있습니다. 문서에 정보를 입력하는데, 기존의 정보가 있을 수도 있으므로 update를 사용하였습니다. 없는 경우 문서를 생성하기 위해 firestore.CreateIfMissingOption(True)를 추가하였습니다. 그룹 목록 화면 사용자의 상태를 그룹 선택으로 변경합니다. 그룹 목록을 가져와서 버튼 배열로 반환합니다. 123456789101112131415161718192021222324252627282930# events/selectclass Select(Args): # ...생략... def show_group_list(self): # 상태 설정 fs.collection(Const.COL_USER).document(self.user_key).update(&#123; Const.FIELD_STATE: Const.STATE_SELECT_GROUP &#125;, firestore.CreateIfMissingOption(True)) # 그룹 목록 가져오기 groups = fs.collection(Const.COL_GROUP).get() group_list = [] for doc in groups: group_list.append(doc.id) group_list.append(Const.BTN_GOTO_START) rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: &#x27;그룹을 선택해 주세요&#x27; &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: group_list &#125; &#125; return Util.send_response(rst) 시작 화면 시작 화면 및 사용자의 입력과 상관이 없는 부분들을 처리하기 위해 Util 클래스를 생성하였습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445# conf/util.pyfrom datetime import datetime, timedeltaimport reimport pytzfrom flask import json, Responsefrom conf.const import Constclass Util: @classmethod def send_response(cls, rst): json_string = json.dumps(rst) response = Response(json_string, content_type=&quot;application/json; charset=utf-8&quot;) return response @classmethod def show_start_menu(cls, msg=&#x27;원하는 메뉴를 선택해 주세요&#x27;, img_src=None): if img_src: rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: msg, &quot;photo&quot;: &#123; &quot;url&quot;: img_src, &#x27;width&#x27;: 640, &quot;height&quot;: 480 &#125; &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: Const.DEFAULT_KEYBOARD &#125; &#125; else: rst = &#123; &quot;message&quot;: &#123; &quot;text&quot;: msg &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: Const.DEFAULT_KEYBOARD &#125; &#125; return Util.send_response(rst) send_response 메소드를 통해서, object를 json으로 변경하여 반환합니다. show_start_menu 메소드가 호출되면 시작화면으로 이동합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 3 - 데이터 베이스(firestore)","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-3-데이터-베이스(firestore)","date":"2018-05-02T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-3-데이터-베이스(firestore)/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-3-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B2%A0%EC%9D%B4%EC%8A%A4(firestore)/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 3 - 데이터 베이스(firestore) 데이터 베이스로 firestore를 사용하였습니다. 크게 3개의 collection으로 구성합니다. group : 그룹을 관리합니다. select : 사용자가 선택한 데이터를 관리합니다. user : 사용자를 관리합니다. group 현재 그룹에는 연구소 그룹만 있습니다. 상황에 따라 추가하거나 삭제할 수 있습니다. 그룹 document는 식당정보를 object로 가지고 있습니다. 이 object를 수정하여 식당정보를 추가하거나 삭제할 수 있습니다. select 선택한 데이터 역시 그룹을 기반으로 관리됩니다. 그룹안에 history, today 컬렉션을 생성하여 사용자가 선택한 데이터를 날짜별로 관리합니다. user_key 부분은 모자이크 처리하였습니다. history 부분은 사용하지 않으므로 넘어가겠습니다. user user_key 부분은 모자이크 처리하였습니다. user_key를 기반으로 document 를 생성합니다. 각 사용자의 그룹 정보와 상태정보를 관리합니다. 점심 선택 사용자가 #점심 선택 버튼을 누른 경우를 처리합니다. 12345678910111213141516# resources/message.pyclass Message(Resource): def __init(self): ... def post(self): select = Select(self.args) # 버튼 입력을 처리합니다. if self.content == Const.BTN_SELECT_LUNCH: return select.show_restaurant_list() # 사용자 입력을 처리합니다. # default return Util.show_start_menu() 데이터베이스에 접근할 수 있도록 초기화를 합니다. Cloud Platform 콘솔에서 IAM 및 관리자 &gt; 서비스 계정 | Google Cloud Platform으로 이동합니다. 새 비공개 키를 생성하고 JSON 파일을 저장합니다. 그런 다음 이 파일을 사용하여 SDK를 초기화합니다. 다운받은 serviceAccount.json 파일을 같은 경로에 넣어준 상태입니다. 123456789101112131415# conf/firebaseInit.pyimport osimport firebase_adminfrom firebase_admin import credentialsfrom firebase_admin import firestoreFILE_DIR = os.path.dirname(os.path.abspath(__file__))CONFIG_PATH = os.path.join(FILE_DIR, &#x27;serviceAccount.json&#x27;)# Use a service accountcred = credentials.Certificate(CONFIG_PATH)firebase_admin.initialize_app(cred)fs = firestore.client() 추가적으로 필요한 상수들을 정의합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Const: COL_GROUP = &#x27;group&#x27; COL_USER = &#x27;user&#x27; COL_SELECT = &#x27;select&#x27; COL_TODAY = &#x27;today&#x27; FIELD_TITLE = &#x27;title&#x27; FIELD_GROUP = &#x27;group&#x27; FIELD_STATE = &#x27;state&#x27; FIELD_RESTAURANT = &#x27;restaurant&#x27; FIELD_ADD_RESTAURANT_TITLE = &#x27;add_restaurant_title&#x27; FIELD_ADD_RESTAURANT_DESC = &#x27;add_restaurant_desc&#x27; FIELD_DELETE_RESTAURANT_TITLE = &#x27;delete_restaurant_title&#x27; FIELD_MAX_HISTORY_LIST = &#x27;daily_max_list&#x27; FIELD_IMG_SRC = &#x27;img_src&#x27; STATE_SELECT_RESTAURANT = &#x27;select_restaurant&#x27; STATE_SELECT_GROUP = &#x27;select_group&#x27; STATE_ADD_RESTAURANT = &#x27;add_restaurant&#x27; STATE_ADD_RESTAURANT_DESC = &#x27;add_restaurant_desc&#x27; STATE_ADD_RESTAURANT_CONFIRM = &#x27;add_restaurant_confirm&#x27; STATE_DELETE_RESTAURANT = &#x27;delete_restaurant&#x27; STATE_DELETE_RESTAURANT_CONFIRM = &#x27;delete_restaurant_confirm&#x27; ARG_USER_KEY = &quot;user_key&quot; ARG_TYPE = &#x27;type&#x27; ARG_CONTENT = &#x27;content&#x27; ## buttons BTN_SELECT_LUNCH = &quot;#점심 선택&quot; BTN_SEE_RESULT = &quot;#결과 보기&quot; BTN_SETTING = &#x27;#설정&#x27; DEFAULT_KEYBOARD = [BTN_SELECT_LUNCH, BTN_SEE_RESULT, BTN_SETTING] BTN_GOTO_START = &quot;#처음으로&quot; BTN_SETTING_GROUP = &#x27;#그룹 설정&#x27; BTN_ADD_RESTAURANT = &quot;#식당 등록&quot; BTN_ADD_RESTAURANT_CONFIRM = &quot;#식당 등록 확인&quot; BTN_DELETE_RESTAURANT = &#x27;#식당 삭제&#x27; BTN_DELETE_RESTAURANT_CONFIRM = &#x27;#식당 삭제 확인&#x27; BTN_DOANTE = &#x27;#후원 하기&#x27; SHOW_COUNT = 7","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 2 - 구조 설계","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-2-구조-설계","date":"2018-05-01T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-2-구조-설계/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-2-%EA%B5%AC%EC%A1%B0-%EC%84%A4%EA%B3%84/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 2 - 구조 설계 Flask 를 사용하여 구현하였으며, 데이터베이스로 firestore를 사용하였습니다. 전체 구조는 아래와 같습니다. 필요한 라이브러리를 설치합니다. 1$ pip install Flask Flask_RESTful firebase-admin kakatalk_lunch_bot.py flask를 생성하고 시작합니다. Flask-RESTful을 사용하여 요청을 처리하였습니다. 사용자 입력처리만 하고 관리는 하지 않으므로 두 가지 /keyboard, /message만 구현하였습니다. 1234567891011121314151617181920212223# kakatalk_lunch_bot.pyfrom flask import Flaskfrom flask_restful import Apifrom resources.keyboard import Keyboardfrom resources.message import Messageapp = Flask(__name__)app.config[&#x27;JSON_AS_ASCII&#x27;] = Falseapi = Api(app)@app.route(&#x27;/&#x27;)def hello_world(): return &#x27;Hello World!&#x27;api.add_resource(Keyboard, &#x27;/keyboard&#x27;)api.add_resource(Message, &#x27;/message&#x27;)if __name__ == &#x27;__main__&#x27;: app.run() resources/keyboard.py /keyboard 요청을 처리합니다. GET 메소드를 사용합니다. 채팅을 시작할 때의 화면이므로 항상 같은 값을 반환하게 됩니다. 1234567891011121314151617# resources/keyboard.pyfrom flask import json, Responsefrom flask_restful import Resourceclass Keyboard(Resource): @classmethod def get(cls): rst = &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [&quot;#점심 선택&quot;, &quot;#결과 보기&quot;, &#x27;#설정&#x27;] &#125; json_string = json.dumps(rst) response = Response(json_string, content_type=&quot;application/json; charset=utf-8&quot;) return response 버튼 이름 앞에 #을 붙여서, 사용자가 텍스트로 입력한 경우와 구분하였습니다. 사용자가 버튼을 눌렀을 때 버튼 이름과 비교 하여 처리하기 위해 버튼 이름을 변수로 만들어서 사용합니다. 123456789101112131415161718# resources/keyboard.pyfrom flask import json, Responsefrom flask_restful import Resourcefrom conf.const import Constclass Keyboard(Resource): @classmethod def get(cls): rst = &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: Const.DEFAULT_KEYBOARD &#125; json_string = json.dumps(rst) response = Response(json_string, content_type=&quot;application/json; charset=utf-8&quot;) return response conf/const.py 버튼 이름, 컬럼 명, 상태 값, 파라미터 명 등을 관리합니다. 123456789# conf/const.pyclass Const: ## buttons BTN_SELECT_LUNCH = &quot;#점심 선택&quot; BTN_SEE_RESULT = &quot;#결과 보기&quot; BTN_SETTING = &#x27;#설정&#x27; DEFAULT_KEYBOARD = [BTN_SELECT_LUNCH, BTN_SEE_RESULT, BTN_SETTING] 여기까지만 구현을 해도, API테스트에서 결과를 확인할 수 있습니다. resources/message.py /message 요청을 처리합니다. 이 때는 POST 메소드를 사용합니다. 123456789101112131415161718192021222324252627282930# resources/message.pyfrom flask_restful import reqparsefrom conf.firebaseInit import fsfrom conf.util import Utilfrom events.result import Resultfrom events.select import Selectfrom events.setting import Settingfrom resources.keyboard import *parser = reqparse.RequestParser()parser.add_argument(&#x27;user_key&#x27;, type=str, required=True)parser.add_argument(&#x27;type&#x27;, type=str, required=True)parser.add_argument(&#x27;content&#x27;, type=str, required=True)class Message(Resource): def __init__(self): self.args = parser.parse_args() self.user_key = self.args[Const.ARG_USER_KEY] self.req_type = self.args[Const.ARG_TYPE] self.content = self.args[Const.ARG_CONTENT] def post(self): # 버튼 입력을 처리합니다. # 사용자 입력을 처리합니다. # 시작 메뉴로 이동합니다. 파라미터 처리를 위한 변수를 추가합니다. 12345678910111213# conf/const.pyclass Const: ## buttons BTN_SELECT_LUNCH = &quot;#점심 선택&quot; BTN_SEE_RESULT = &quot;#결과 보기&quot; BTN_SETTING = &#x27;#설정&#x27; DEFAULT_KEYBOARD = [BTN_SELECT_LUNCH, BTN_SEE_RESULT, BTN_SETTING] ARG_USER_KEY = &quot;user_key&quot; ARG_TYPE = &#x27;type&#x27; ARG_CONTENT = &#x27;content&#x27; /message로 들어온 사용자 입력 데이터를 처리합니다. 12345678910111213141516# resources/message.pyclass Message(Resource): # ... 생략... def post(self): select = Select(self.args) # 버튼 입력을 처리합니다. if self.content == Const.BTN_SELECT_LUNCH: return select.show_restaurant_list() # 사용자 입력을 처리합니다. # default return Util.show_start_menu() self.content 에는 사용자가 선택한 내용이 들어 있습니다. 이를 비교하여 처리합니다. 각각 선택, 결과, 설정을 처리하기 위한 클래스를 생성합니다. events/select events/result events/setting","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"[책] 반응형 웹 디자인","slug":"2018/반응형-웹-디자인-내용-기록","date":"2018-04-30T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/반응형-웹-디자인-내용-기록/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8-%EB%82%B4%EC%9A%A9-%EA%B8%B0%EB%A1%9D/","excerpt":"","text":"[책] 반응형 웹 디자인 다양한 반응형 웹사이트를 만날 수 있는 곳: 미디어 쿼리(http://mediaqueri.es) 검색 엔진 최적화(SEO: Search Engine Optimize) inline-block 은 diplay 속성의 값 중 inline 속성값처럼 요소들이 한 줄로 보이고, 태그에도 사용할 수 있는 속성값입니다. 함수명 파라미터 적용 요소 calc width 속성에서 사용할 수 있는 모든 값, 연산 기호 모든 대상 123#wrap div &#123; width: calc(100%-100px);&#125; 브라우저 기술 지원 현황을 확인할 수 있는 사이트 : Can I Use…(https://caniuse.com/) em, rem em 단위는 자신의 부모 박스에 글자 크기가 지정되어 있을 경우 자식 박스에게 글자 크기가 상속됩니다. rem 단위는 , 태그를 기준으로 하기 때문에 상속 문제가 발생하지 않습니다. vw, vh, vmin, vmax vw(viewport width) : vw 단위는 웹 브라우저의 너비를 100 을 기준으로 하여 크기를 결정하는 단위 vh(viewport height) : vh 단위는 웹 브라우저의 높이를 100 을 기준으로 하여 크기를 결정하는 단위 vmin(viewport minimum) : vmin 단위는 웹 브라우저의 너비와 높이 중 짧은 쪽을 기준으로 하여 크기를 결정하는 단위 vmaz(viewport maximum) : vmax 단위는 웹 브라우저의 너비와 높이 중 큰 쪽을 기준으로 하여 크기를 결정하는 단위 미디어 쿼리 1@media [only 또는 not] [미디어 유형] [and 또는 ,(comma)] (조건문) &#123;실행문&#125; 미디어 유형 기기명 설명 all 모든 장치 print 인쇄 장치 screen 컴퓨터 화면 장치 또는 스마트 기기의 화면 tv 영상과 음성이 동시에 출력되는 장치 projection 프로젝터 장치 handheld 손에 들고 다니는 소형 장치 speech 음성 출력 장치 aural 음성 합성 장치(화면을 읽어 소리로 출력해 주는 장치) embossed 점자 인쇄 장치(화면을 읽어 종이에 점자를 찍어내느 장치) tty 디스플레이 기능이 제한된 장치 braille 점자 표시 장치 hanheld 는 소형 기기라는 의미가 있지만 실제로 미디어 유형에서 스마트 기기는 screen 을 사용합니다. 조건문 12@media (min-width:320px) &#123;실행문&#125;@media (min-width:320px) and (max-width:768px) &#123;실행문&#125; min/max(접두사 구문): min 은 최소, 즉 이상이라는 의미가 있고, max 는 최대, 즉 이하라는 의미가 있습니다. 조건문 설명 조건값 min/max 사용 여부 width 웹페이지의 가로 너비값 width 속성에서 사용할 수 있는 모든 속성값 사용함 height 웹페이지의 세로 높이값 // // device-width 기기의 가로 너비값 // // device-height 기기의 세로 높이값 // // orientation 기기의 화면 방향 portrait(세로)landscape(가로) 사용 안 함 aspect-ratio 화면 비율 브라우저 화면 비율(1)브라우저 종횡비(16/9)브라우저 해상도(1280/720) 사용함 device-aspect-ratio 단말기의 화면 비율 기기 화면 비율(1)기기 종횡비(16/9)기기 해상도(640/320) // color 기기의 비트 수 8(bit 단위) // color-index 기기의 색상 수 128(색상 수 단위) // monochrome 기기가 흑백일 때 픽셀당 비트 수 1(bit 단위) // resolution 기기의 해상력 300dpi/dpcm // scan TV 의 스캔 방식 progressive/interlace 사용 안 함 grid 기기의 그리드/비트맵 0(비트맵 방식)/1(그리드 방식) 사용 안 함 뷰포트 뷰포트(Viewport)는 화면에 보이는 영역을 제어하는 기술로, 미디어 쿼리로 수많은 기기의 화면 크기를 감지해야 할 때 필요합니다. 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; 뷰포트 속성 속성명 속성값 속성 설명 width device-width, 양수 뷰포트의 너비를 지정 height device-height, 양수 뷰포트의 높이를 지정 initial-scale 양수 뷰포트의 초기 배율 지정기본값은 11 보다 작은 값을 사용하면 축소된 페이지를 표시하고, 1 보다 큰 값을 사용하면 확대된 페이지를 표시 user-scalabel yes, no 뷰포트의 확대/축소 여부를 지정기본값은 yesno 로 설정하면 사용자가 페이지를 확대/축소 할 수 없음 minimum-scale 양수 뷰포트의 최소 축소 비율을 지정기본값은 0.25 maximum-scale 양수 뷰포트의 최대 확대 비율을 지정기본값은 5.0 minimum-scale 과 maximum-scale 속성값을 각각 1.0 으로 지정할 경우 user-scalable 을 ‘yes’로 지정하더라도 사용자가 화면을 확대하거나 축소할 수 없습니다. 표준 방식의 뷰포트 기술내용 : http://goo.gl/FSTGbn 12345678910&lt;style&gt;@viewport &#123; width: device-width; /* width 속성과 동일 */ zoom: 1; /* initial-scale 속성과 동일 */ min-zoom: 1; /* minimum-scale 속성과 동일 */ max-zoom: 1; /* maximum-scale 속성과 동일 */ user-zoom: zoom; /* user-scalable 속성과 동일 */&#125;&lt;/style&gt; 플렉서블 박스 display 속성값 속성값 설명 flex 박스를 블록 수준의 플렉서블 박스로 작동 inline-flex 박스를 인라인 수준의 플렉서블 박스로 작동 flex-direction 속성값 속성값 설명 row 박스를 왼쪽에서 오른쪽으로 배치주축은 가로, 교차축은 세로 row-reverse column 박스를 위에서 아래로 배치주축은 세로, 교차축은 가로 column-reverse flex-wrap 속성값 속성값 설명 npwrap 박스를 한 줄로 배치, 기본값 wrap 박스를 여러 줄로 배치 wrap-reverse flex-flow 속성값 속성값 설명 [flex-direction][flex-wrap] 기본값은 row nowrap 첫 번째 속성값은 박스의 배치 방향을 설정두 번째 속성값은 박스를 여러 줄로 배치하는 속성을 설정 justify-content 속성값 속성값 설명 flex-start 박스를 주축의 시작점으로 배치기본값입니다. flex-end 박스를 주축의 끝점으로 배치 center 박스를 중앙으로 배치 space-between 플렉서블 박스에 빈 공간이 있을 때 사용첫 번째 박스와 마지막 박스를 양쪽 끝으로 붙이고, 나머지 박스는 동일한 간격으로 정렬 space-around 플렉서블 박스에 빈 공간이 있을 때 사용양쪽 끝에 있는 박스의 양 옆에도 공간을 둔 채 자동 정렬 align-items 속성값 속성값 설명 stretch 박스를 확장해서 배치하며, 기본값입니다. flex-start 박스를 교차축의 시작점에 배치 flex-end 박스를 교차축의 끝점에 배치 center 박스를 교차축의 중앙에 배치 baseline 박스를 시작점에 배치되는 박스의 글자 배이스라인에 맞춰 배치시작점에 배치되는 박스는 교차축의 시작점과 글자 베이스라인의 거리가 가장 먼 박스가 교차축의 시작점에 배치 align-self 속성값 align-items 속성값 설명과 동일 auto : 플렉서블 박스(플렉스 아이템의 부모 박스)의 align-items 속성값을 상속. 부모 박스에 적용된 속성값이 없는 경우 stretch 속성값이 적용됨. order, flex 속성 속성값 order 0(기본값)정수 flex [flex-grow][flex-shrink] [flex-basis]0 1 auto (기본값)0 auto (0 1 auto 와 같음)initail(0 1 auto)auto(1 1 auto)none(0 0 auto) flex-grow 플렉서블 박스에 여백이 있을 때 플렉스 아이템의 크기를 늘릴 수 있는 속성 flex-shrink 플렉서블 박스 안의 플렉스 아이템의 크기가 넘칠 경우 크기를 줄일 수 있는 속성 flex-basis 플렉스 아이템의 기본 크기를 설정하기 위한 속성. width 속성에서 사용할 수 있는 모든 값을 사용할 수 있습니다. 단, 정수속성값을 0 으로 설정한 경우 플렉스 아이템에 flex-grow, flex-shrink 속성값에서 설정한 비율이 그대로 적용됩니다.속성값을 auto 로 설정할 경우 플렉스 아이템이 기본적으로 가지고 있는 크기를 기준으로 flex-grow, flex-shrink 속성값에서 설정한 비율이 적용됩니다. filter blur, brightness, saturate, grayscale, contrast, sepia, invert, opacity, hue-rotate","categories":[],"tags":[{"name":"반응형","slug":"반응형","permalink":"http://jacegem.github.io/blog/tags/%EB%B0%98%EC%9D%91%ED%98%95/"},{"name":"웹","slug":"웹","permalink":"http://jacegem.github.io/blog/tags/%EC%9B%B9/"},{"name":"디자인","slug":"디자인","permalink":"http://jacegem.github.io/blog/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"}]},{"title":"[책] 반응형 웹 디자인","slug":"2018/반응형-웹-디자인","date":"2018-04-30T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/반응형-웹-디자인/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9-%EB%94%94%EC%9E%90%EC%9D%B8/","excerpt":"","text":"[책] 반응형 웹 디자인 Do it! 반응형 웹 디자인김운아 저 다양한 반응형 웹사이트를 만날 수 있는 곳: 미디어 쿼리(http://mediaqueri.es) 검색 엔진 최적화(SEO: Search Engine Optimize) inline-block 은 diplay 속성의 값 중 inline 속성값처럼 요소들이 한 줄로 보이고, 태그에도 사용할 수 있는 속성값입니다. 함수명 파라미터 적용 요소 calc width 속성에서 사용할 수 있는 모든 값, 연산 기호 모든 대상 123#wrap div &#123; width: calc(100%-100px);&#125; 브라우저 기술 지원 현황을 확인할 수 있는 사이트 : Can I Use…(https://caniuse.com/) em, rem em 단위는 자신의 부모 박스에 글자 크기가 지정되어 있을 경우 자식 박스에게 글자 크기가 상속됩니다. rem 단위는 , 태그를 기준으로 하기 때문에 상속 문제가 발생하지 않습니다. vw, vh, vmin, vmax vw(viewport width) : vw 단위는 웹 브라우저의 너비를 100 을 기준으로 하여 크기를 결정하는 단위 vh(viewport height) : vh 단위는 웹 브라우저의 높이를 100 을 기준으로 하여 크기를 결정하는 단위 vmin(viewport minimum) : vmin 단위는 웹 브라우저의 너비와 높이 중 짧은 쪽을 기준으로 하여 크기를 결정하는 단위 vmaz(viewport maximum) : vmax 단위는 웹 브라우저의 너비와 높이 중 큰 쪽을 기준으로 하여 크기를 결정하는 단위 미디어 쿼리 1@media [only 또는 not] [미디어 유형] [and 또는 ,(comma)] (조건문) &#123;실행문&#125; 미디어 유형 기기명 설명 all 모든 장치 print 인쇄 장치 screen 컴퓨터 화면 장치 또는 스마트 기기의 화면 tv 영상과 음성이 동시에 출력되는 장치 projection 프로젝터 장치 handheld 손에 들고 다니는 소형 장치 speech 음성 출력 장치 aural 음성 합성 장치(화면을 읽어 소리로 출력해 주는 장치) embossed 점자 인쇄 장치(화면을 읽어 종이에 점자를 찍어내느 장치) tty 디스플레이 기능이 제한된 장치 braille 점자 표시 장치 hanheld 는 소형 기기라는 의미가 있지만 실제로 미디어 유형에서 스마트 기기는 screen 을 사용합니다. 조건문 12@media (min-width:320px) &#123;실행문&#125;@media (min-width:320px) and (max-width:768px) &#123;실행문&#125; min/max(접두사 구문): min 은 최소, 즉 이상이라는 의미가 있고, max 는 최대, 즉 이하라는 의미가 있습니다. 조건문 설명 조건값 min/max 사용 여부 width 웹페이지의 가로 너비값 width 속성에서 사용할 수 있는 모든 속성값 사용함 height 웹페이지의 세로 높이값 // // device-width 기기의 가로 너비값 // // device-height 기기의 세로 높이값 // // orientation 기기의 화면 방향 portrait(세로)landscape(가로) 사용 안 함 aspect-ratio 화면 비율 브라우저 화면 비율(1)브라우저 종횡비(16/9)브라우저 해상도(1280/720) 사용함 device-aspect-ratio 단말기의 화면 비율 기기 화면 비율(1)기기 종횡비(16/9)기기 해상도(640/320) // color 기기의 비트 수 8(bit 단위) // color-index 기기의 색상 수 128(색상 수 단위) // monochrome 기기가 흑백일 때 픽셀당 비트 수 1(bit 단위) // resolution 기기의 해상력 300dpi/dpcm // scan TV 의 스캔 방식 progressive/interlace 사용 안 함 grid 기기의 그리드/비트맵 0(비트맵 방식)/1(그리드 방식) 사용 안 함 뷰포트 뷰포트(Viewport)는 화면에 보이는 영역을 제어하는 기술로, 미디어 쿼리로 수많은 기기의 화면 크기를 감지해야 할 때 필요합니다. 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; 뷰포트 속성 속성명 속성값 속성 설명 width device-width, 양수 뷰포트의 너비를 지정 height device-height, 양수 뷰포트의 높이를 지정 initial-scale 양수 뷰포트의 초기 배율 지정기본값은 11 보다 작은 값을 사용하면 축소된 페이지를 표시하고, 1 보다 큰 값을 사용하면 확대된 페이지를 표시 user-scalabel yes, no 뷰포트의 확대/축소 여부를 지정기본값은 yesno 로 설정하면 사용자가 페이지를 확대/축소 할 수 없음 minimum-scale 양수 뷰포트의 최소 축소 비율을 지정기본값은 0.25 maximum-scale 양수 뷰포트의 최대 확대 비율을 지정기본값은 5.0 minimum-scale 과 maximum-scale 속성값을 각각 1.0 으로 지정할 경우 user-scalable 을 ‘yes’로 지정하더라도 사용자가 화면을 확대하거나 축소할 수 없습니다. 표준 방식의 뷰포트 기술내용 : http://goo.gl/FSTGbn 12345678910&lt;style&gt;@viewport &#123; width: device-width; /* width 속성과 동일 */ zoom: 1; /* initial-scale 속성과 동일 */ min-zoom: 1; /* minimum-scale 속성과 동일 */ max-zoom: 1; /* maximum-scale 속성과 동일 */ user-zoom: zoom; /* user-scalable 속성과 동일 */&#125;&lt;/style&gt; 플렉서블 박스 display 속성값 속성값 설명 flex 박스를 블록 수준의 플렉서블 박스로 작동 inline-flex 박스를 인라인 수준의 플렉서블 박스로 작동 flex-direction 속성값 속성값 설명 row 박스를 왼쪽에서 오른쪽으로 배치주축은 가로, 교차축은 세로 row-reverse column 박스를 위에서 아래로 배치주축은 세로, 교차축은 가로 column-reverse flex-wrap 속성값 속성값 설명 npwrap 박스를 한 줄로 배치, 기본값 wrap 박스를 여러 줄로 배치 wrap-reverse flex-flow 속성값 속성값 설명 [flex-direction][flex-wrap] 기본값은 row nowrap 첫 번째 속성값은 박스의 배치 방향을 설정두 번째 속성값은 박스를 여러 줄로 배치하는 속성을 설정 justify-content 속성값 속성값 설명 flex-start 박스를 주축의 시작점으로 배치기본값입니다. flex-end 박스를 주축의 끝점으로 배치 center 박스를 중앙으로 배치 space-between 플렉서블 박스에 빈 공간이 있을 때 사용첫 번째 박스와 마지막 박스를 양쪽 끝으로 붙이고, 나머지 박스는 동일한 간격으로 정렬 space-around 플렉서블 박스에 빈 공간이 있을 때 사용양쪽 끝에 있는 박스의 양 옆에도 공간을 둔 채 자동 정렬 align-items 속성값 속성값 설명 stretch 박스를 확장해서 배치하며, 기본값입니다. flex-start 박스를 교차축의 시작점에 배치 flex-end 박스를 교차축의 끝점에 배치 center 박스를 교차축의 중앙에 배치 baseline 박스를 시작점에 배치되는 박스의 글자 배이스라인에 맞춰 배치시작점에 배치되는 박스는 교차축의 시작점과 글자 베이스라인의 거리가 가장 먼 박스가 교차축의 시작점에 배치 align-self 속성값 align-items 속성값 설명과 동일 auto : 플렉서블 박스(플렉스 아이템의 부모 박스)의 align-items 속성값을 상속. 부모 박스에 적용된 속성값이 없는 경우 stretch 속성값이 적용됨. order, flex 속성 속성값 order 0(기본값)정수 flex [flex-grow][flex-shrink] [flex-basis]0 1 auto (기본값)0 auto (0 1 auto 와 같음)initail(0 1 auto)auto(1 1 auto)none(0 0 auto) flex-grow 플렉서블 박스에 여백이 있을 때 플렉스 아이템의 크기를 늘릴 수 있는 속성 flex-shrink 플렉서블 박스 안의 플렉스 아이템의 크기가 넘칠 경우 크기를 줄일 수 있는 속성 flex-basis 플렉스 아이템의 기본 크기를 설정하기 위한 속성. width 속성에서 사용할 수 있는 모든 값을 사용할 수 있습니다. 단, 정수속성값을 0 으로 설정한 경우 플렉스 아이템에 flex-grow, flex-shrink 속성값에서 설정한 비율이 그대로 적용됩니다.속성값을 auto 로 설정할 경우 플렉스 아이템이 기본적으로 가지고 있는 크기를 기준으로 flex-grow, flex-shrink 속성값에서 설정한 비율이 적용됩니다. filter blur, brightness, saturate, grayscale, contrast, sepia, invert, opacity, hue-rotate","categories":[],"tags":[{"name":"반응형","slug":"반응형","permalink":"http://jacegem.github.io/blog/tags/%EB%B0%98%EC%9D%91%ED%98%95/"},{"name":"웹","slug":"웹","permalink":"http://jacegem.github.io/blog/tags/%EC%9B%B9/"},{"name":"디자인","slug":"디자인","permalink":"http://jacegem.github.io/blog/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"}]},{"title":"카카오톡 플러스친구 스마트채팅 만들기 1 - API 확인","slug":"2018/카카오톡-플러스친구-스마트채팅-만들기-1-API-확인","date":"2018-04-30T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/카카오톡-플러스친구-스마트채팅-만들기-1-API-확인/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1-%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC-%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85-%EB%A7%8C%EB%93%A4%EA%B8%B0-1-API-%ED%99%95%EC%9D%B8/","excerpt":"","text":"카카오톡 플러스친구 스마트채팅 만들기 1 - API 확인 같은 그룹에 있는 사람들이 식당을 선택하고, 가장 많이 선택된 식당을 보여주는 봇을 만들어 보겠습니다. 플러스친구 생성 카카오톡 플러스친구 관리자 센터를 통해서 봇을 만들 수 있습니다. 플러스친구 관리자센터에 로그인을 합니다. +새 플러스친구 만들기를 누르고 기본적인 정보를 입력합니다. 좌측 사이드 메뉴 중에서 스마트채팅을 선택합니다. 우측에 있는 API형을 선택합니다. 앱 URL을 등록합니다. 서버가 정상적으로 동작하면 API테스트 시에 결과를 확인할 수 있습니다. API Document API형 페이지에서 우측상단에 있는 API Document 버튼을 눌러 API를 확인할 수 있습니다. API 는 두가지를 구현해 주어야 합니다. /keyboard /message 서버/keyboard 123Method : GETURL : http(s)://:your_server_url/keyboardContent - Type : application/json; charset=utf-8 keyboard는 사용자가 처음 플러스친구와 채팅을 시작할 때 보여줄 화면을 json으로 반환하면 됩니다. 다음과 같은 json으로 반환합니다. 1234&#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [&quot;#점심 선택&quot;, &quot;#결과 보기&quot;, &#x27;#설정&#x27;]&#125; 위에서 API테스트에서 나온 결과가 바로 /keyboard 결과입니다. 화면으로 보면 아래와 같이 나오게 됩니다. type 을 buttons 로 지정하였기 때문에 상담원과의 대화가 불가능한 프로필입니다.라고 나오게 됩니다. 서버/message 123Method : POSTURL : http(s)://:your_server_url/messageContent - Type : application/json; charset=utf-8 플러스친구와 채팅을 시작하고 사용자의 입력이 들어오는 순간부터는 /message로 전송됩니다. 이 때 3가지 파라미터를 같이 받을 수 있습니다. 필드명 타입 필수여부 설명 user_key String Required 메시지를 발송한 유저 식별 키 type String Required text, photo content String Required 자동응답 명령어의 메시지 텍스트 혹은 미디어 파일 uri /message 에서는 messages와 keyboard를 반환할 수 있습니다. 12345678910111213141516171819202122&#123; &quot;message&quot;: &#123; &quot;text&quot;: &quot;귀하의 차량이 성공적으로 등록되었습니다. 축하합니다!&quot;, &quot;photo&quot;: &#123; &quot;url&quot;: &quot;https://photo.src&quot;, &quot;width&quot;: 640, &quot;height&quot;: 480 &#125;, &quot;message_button&quot;: &#123; &quot;label&quot;: &quot;주유 쿠폰받기&quot;, &quot;url&quot;: &quot;https://coupon/url&quot; &#125; &#125;, &quot;keyboard&quot;: &#123; &quot;type&quot;: &quot;buttons&quot;, &quot;buttons&quot;: [ &quot;처음으로&quot;, &quot;다시 등록하기&quot;, &quot;취소하기&quot; ] &#125;&#125; 내용을 확인하면 아래 같습니다. message - text : 대화에 입력할 내용 meesage - photo - url : 사진 주소 meesage - photo - width : 사진 넓이 meesage - photo - height : 사진 높이 message - message_button - label : 버튼 라벨 message - message_button - url : 버튼 링크 keyboard - type : 키보드 타입 (버튼 또는 텍스트) keyboard - buttons : 키보드에 보여줄 버튼들 사용자 관리 사용자 관리를 위한 API가 2개 더 있습니다. /friend /chat_room/:user_key 서버/friend 123Method : POST/DELETEURL : http(s)://:your_server_url/friendContent - Type : application/json; charset=utf-8 사용자가 채팅을 시작하면 전달되는 API 입니다. 서버/chat_room/:user_key 123Method : DELETEURL : http(s)://:your_server_url/chat_room/:user_keyContent - Type : application/json; charset=utf-8 사용자가 채팅을 종료하면 전달되는 API 입니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"}]},{"title":"Amazfit bip 한글화","slug":"2018/Amazfit-bip-한글화","date":"2018-04-23T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Amazfit-bip-한글화/","link":"","permalink":"http://jacegem.github.io/blog/2018/Amazfit-bip-%ED%95%9C%EA%B8%80%ED%99%94/","excerpt":"","text":"Amazfit bip 한글화 한글화 미핏을 사용하는데, 3.3.1 버전부터는 자동 펌웨어 업데이트가 되므로, 3.3.0 버전을 사용해야 합니다. (이 부분을 몰라, 한글화 작업을 2번해야 했습니다…) 다운로드 Mi Fit 3.3.0 APK Download by Anhui Huami Information Technology Co.,Ltd. - APKMirror 에서 3.3.0 버전을 다운로드 합니다. 3237 버전으로 설치했습니다 Gadgetbridge | F-Droid - Free and Open Source Android App Repository 에서 가젯브릿지를 다운로드합니다. Releases · sukso96100/amazfit-bip-kr · GitHub 에서 fw, res, ft를 다운로드 합니다. Mili_chaohu_kr_20180305.fw Mili_chaohu_kr_20180305.res Mili_chaohu_kr_20180222.ft 굴림체 폰트는 http://cafe.naver.com/xst/219048 에서 다운로드 할 수 있습니다. 설치 순서 구글 플레이스토어에서 자동업데이트를 해제합니다. 미핏 3.3.0 버전을 설치합니다. bip과 미핏을 연동합니다. bip에서 검색 가능 옵션을 활성화 합니다. 가젯 브릿지를 설치합니다. bip과 가젯 브릿지를 연동합니다. fw, res, ft 파일을 순서대로 설치합니다. 가젯 브릿지와 연동을 끊고 가젯 브릿지를 종료합니다. 미핏에서 검색 가능 옵션을 비활성화 합니다. Watchface &amp; Tools AMAZFIT WATCH FACES : https://amazfitwatchfaces.com/ 에디터: Watchface Editor 툴: valeronm / AmazfitBipTools / Downloads — Bitbucket 추가 구매 스트랩 22 미리메터 삼성 기어 S3 클래식 프론티어 시계 밴드 S2 스포츠 팔찌 스트랩 샤오 huami amazfit bip 걸음 라이트 20 미리메터 (알리 / $7.4) 22 미리메터 20 미리메터 스테인레스 스틸 시계 밴드 huami amazfit 걸음 라이트 bip 삼성 기어 S3 클래식 프론티어 시계 스트랩 기어 스포츠 s2 (알리 / $7.13, 모바일에서 $7.05 ) TEAROKE 나일론 시계 밴드 손목 가죽 스트랩 18 미리메터 20 미리메터 22 미리메터 24 미리메터 시계 액세서리 스테인레스 스틸 남성 여성 높은 품질 참고 어메이즈핏 빕, 공식 펌웨어 업데이트 후 한글 패치 문제 해결방법 Amazfit Bip : 네이버 블로그 어메이즈핏 빕 amazfit bip 한글 적용법 : 네이버 블로그 샤오미스토리 《 세계 최대 IoT 허브 _ 샤오미 공식카페 》 : 네이버 카페 Releases · sukso96100/amazfit-bip-kr · GitHub Watchface Editor valeronm / AmazfitBipTools / Downloads — Bitbucket","categories":[{"name":"Product","slug":"Product","permalink":"http://jacegem.github.io/blog/categories/Product/"},{"name":"Wearable","slug":"Product/Wearable","permalink":"http://jacegem.github.io/blog/categories/Product/Wearable/"}],"tags":[{"name":"amazfit","slug":"amazfit","permalink":"http://jacegem.github.io/blog/tags/amazfit/"},{"name":"bip","slug":"bip","permalink":"http://jacegem.github.io/blog/tags/bip/"},{"name":"한글화","slug":"한글화","permalink":"http://jacegem.github.io/blog/tags/%ED%95%9C%EA%B8%80%ED%99%94/"}]},{"title":"프로처럼 트렐로 사용하기","slug":"2018/프로처럼-트렐로-사용하기","date":"2018-04-06T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2018/프로처럼-트렐로-사용하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/%ED%94%84%EB%A1%9C%EC%B2%98%EB%9F%BC-%ED%8A%B8%EB%A0%90%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","excerpt":"","text":"프로처럼 트렐로 사용하기 How to use Trello like a pro 의 내용을 보면서 프로처럼 사용해 보겠습니다. 트렐로의 기본 정보는 Getting Started Guide 에서 확인할 수 있습니다. 여기에서는 가장 많이 찾은 유용한 정보와 팁을 모았습니다. 더블클릭으로 리스트 추가하기 (Double click to add list) from Adding lists to a board 빈 화면을 더블클릭하면 리스트를 추가할 수 있는 팝업이 열립니다. Position도 정할 수 있습니다. 1로 변경하면 가장 왼쪽에 리스트가 생성됩니다. 키보드 단축키 (Keyboard shortcuts) from Using keyboard shortcuts in Trello ? 키를 눌러서 단축키를 확인 할 수 있습니다. 물론, https://trello.com/shortcuts 에서도 확인 할 수 있습니다. 참고: http://surpassing.tistory.com/858 드래그 드랍으로 첨부파일 추가 (Drag and drop attachments) from Adding attachments to cards 여러 파일들을 드래그 드랍으로 카드에 추가할 수 있습니다. 웹 사이트의 이미지도 드래그하여 카드에 추가할 수 있습니다. 여러개의 카드나 체크리스트 추가 (Submit multiple cards and checklist items) from Importing data into Trello 스프레드시트에서 컬럼들이나, 워드프로세서에서 줄로 구분된 내용을 복사 - 붙여넣기 하여 카드나 체크리스트를 추가할 수 있습니다. @ mentions from Commenting on cards @ 뒤에 이름을 입력해서 멘션을 할 수 있습니다. 보드 스크롤 (Drag board to scroll) from Adding your first board 배경을 마우스 클릭한 다음 이동하여 수평 스크롤 할 수 있습니다. 또는 SHIFT 버튼을 누르고 스크롤 하여 수평 스크롤 할 수 있습니다. 스타 보드 재배열 (Re-order starred boards) from Starring a Board 별표시를 한 보드는 마우스로 재배열 할 수 있습니다. 체크리스트와 체크리스트 아이템 재배열 (Reorder checklists and checklist items) from Adding checklists to cards 마우스 드래그로 체크리스트와 체크리스트 아이템을 재배열 할 수 있습니다. 이메일로 카드 생성 (Create cards via email) from Creating cards by email 이메일로 카드를 만들 수 있습니다. Email-to-board Settings 에서 이메일 주소를 확인 할 수 있습니다. 리스트에 카드 수 표출 (Show total cards per list) from Filtering cards on a board F키를 눌러서 필터를 설정합니다. * 또는 / 를 필터로 설정하면 리스트에서 카드 수를 확인 할 수 있습니다.","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Web","slug":"Application/Web","permalink":"http://jacegem.github.io/blog/categories/Application/Web/"}],"tags":[{"name":"pro","slug":"pro","permalink":"http://jacegem.github.io/blog/tags/pro/"},{"name":"trello","slug":"trello","permalink":"http://jacegem.github.io/blog/tags/trello/"},{"name":"like","slug":"like","permalink":"http://jacegem.github.io/blog/tags/like/"}]},{"title":"트렐로 단축키 키보드 단축키 (Keyboard shortcuts)","slug":"2018/트렐로-단축키","date":"2018-04-05T15:00:00.000Z","updated":"2023-10-24T11:29:13.001Z","comments":true,"path":"2018/트렐로-단축키/","link":"","permalink":"http://jacegem.github.io/blog/2018/%ED%8A%B8%EB%A0%90%EB%A1%9C-%EB%8B%A8%EC%B6%95%ED%82%A4/","excerpt":"","text":"키보드 단축키 (Keyboard shortcuts) from Using keyboard shortcuts in Trello ? 키를 눌러서 단축키를 확인 할 수 있습니다. 물론, https://trello.com/shortcuts 에서도 확인 할 수 있습니다. 카드 이동하기 트렐로는 리스트와 카드로 이루어져 있습니다. 카드의 이동은 화살표와 j, k로 이동할 수 있습니다. 보드 메뉴 열기 b 키를 눌러서 보드 메뉴를 열수 있습니다. 검색 하기 / 키를 눌러서 검색창으로 포커스를 이동할 수 있습니다. 카드 보관 c를 눌러서 카드를 보관할 수 있습니다. 보관한 카드는 more → Archived Items 에서 확인 할 수 있습니다. 완료일 설정 d키를 눌러서 완료일을 설정할 수 있습니다. 빠른 편집 모드 E 키를 눌러서 빠른 편집 모드로 변경할 수 있습니다. 마우스를 카드 위로 올린 다음에 E키를 누릅니다. 텍스트 저장 윈도우에서는 Control + Enter, 맥에서는 Command + Enter를 눌러서 텍스트를 저장합니다. 카드 열기 **Enter**키를 눌러서 카드를 열 수 있습니다. 카드 필터 메뉴 F키를 눌러서 카드 필터 메뉴를 열 수 있습니다. 라벨 설정 L키를 눌러서 라벨을 설정할 수 있습니다. 카드위로 마우스를 올리고 L 키를 누릅니다. 숫자키를 눌러서 라벨을 선택할 수 있습니다. Key Label Color 1 Green 2 Yellow 3 Orange 4 Red 5 Purple 6 Blue 7 Sky 8 Lime 9 Pink 0 Black 라벨 보이기 ;키를 눌러서 라벨명을 보이게 할 수 있습니다. 토글키이므로 보이는 상태에서 다시 눌러서 안보이게 설정 할 수 있습니다. 멤버 변경하기 M키를 눌러서 멤버를 변경합니다. 새로운 카드 만들기 N키를 눌러서 새로운 카드를 생성합니다. 마우스가 위해 있는 리스트에 새로운 카드가 생성됩니다. 마우스를 이동하면서 확인해 보세요. 옆 리스트로 카드 이동하기 , , . 는 왼쪽, 오른쪽 리스트의 맨 마지막으로 카드를 이동합니다. &lt; , &gt; 는 왼쪽, 오른쪽 리스트의 맨 위로 카드를 이동합니다. 나에게 할당된 카드 보기 Q키를 눌러서 나에게 할당된 카드만 확인합니다. 구독 설정 S키를 눌러서 구독 설정을 변경할 수 있습니다. 나에게 할당하기 Space 키를 눌러서 나에게 할당할 수 있습니다. 제목 변경 T키를 눌러서 제목을 변경합니다. 마우스를 위로 올린 상태에서 T키를 눌러보세요. 메뉴 보이기 W키를 눌러서 사이드의 메뉴를 보이게 할 수 있습니다. 필터 초기화 X키를 눌러서 모든 필터를 초기화합니다. 단축키 보기 ?키를 눌러서 단축키를 확인 할 수 있습니다. 멤버 할당하기 카드를 작성할 때, @ 뒤에 이름을 입력하여 할당 할 수 있습니다. 라벨 설정 카드를 작성할 때, # 뒤에 숫자를 입력하여 라벨을 설정 할 수 있습니다. 위치 설정 카드를 작성할 때, ^ 뒤에 숫자를 입력하여 위치를 설정할 수 있습니다.","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Web","slug":"Application/Web","permalink":"http://jacegem.github.io/blog/categories/Application/Web/"}],"tags":[{"name":"trello","slug":"trello","permalink":"http://jacegem.github.io/blog/tags/trello/"},{"name":"keyboard","slug":"keyboard","permalink":"http://jacegem.github.io/blog/tags/keyboard/"},{"name":"shortcuts","slug":"shortcuts","permalink":"http://jacegem.github.io/blog/tags/shortcuts/"}]},{"title":"STS 실행시 에러 [Java was started but returned exit codes 13]","slug":"2018/STS-실행시-에러-Java-was-started-but-returned-exit-codes-13","date":"2018-01-28T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/STS-실행시-에러-Java-was-started-but-returned-exit-codes-13/","link":"","permalink":"http://jacegem.github.io/blog/2018/STS-%EC%8B%A4%ED%96%89%EC%8B%9C-%EC%97%90%EB%9F%AC-Java-was-started-but-returned-exit-codes-13/","excerpt":"","text":"STS 실행시 에러 [Java was started but returned exit codes 13] Java was started but returned exit codes 13 에러 발생 다른 버전의 STS를 다운받아서 실행합니다. 다운로드 여기에서 DOWNLOAD STS 를 하면 32bit를 다운 받게 됩니다. 64비트를 사용하시면, See all version로 이동하여 64비트를 선택해야 합니다. 버전이 맞지 않으면 실행시에 에러가 발생합니다. 실행 압축을 푼 폴더에서 sts-3.9.2.RELEAS/STS.exe를 실행합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Web","slug":"Programming/Web","permalink":"http://jacegem.github.io/blog/categories/Programming/Web/"}],"tags":[{"name":"sts","slug":"sts","permalink":"http://jacegem.github.io/blog/tags/sts/"},{"name":"spring","slug":"spring","permalink":"http://jacegem.github.io/blog/tags/spring/"},{"name":"java","slug":"java","permalink":"http://jacegem.github.io/blog/tags/java/"}]},{"title":"맥에서 비주얼스튜디오 코드 실행하기 Run vscode in Mac Shell","slug":"2018/맥-쉘에서-VSCODE-실행","date":"2018-01-26T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/맥-쉘에서-VSCODE-실행/","link":"","permalink":"http://jacegem.github.io/blog/2018/%EB%A7%A5-%EC%89%98%EC%97%90%EC%84%9C-VSCODE-%EC%8B%A4%ED%96%89/","excerpt":"","text":"맥에서 비주얼스튜디오 코드 실행하기 Run vscode in Mac Shell 비주얼스튜디오 코드를 실행하기 위해서 code .를 입력하였으나 실행이 되지 않는다. 12➜ code .zsh: command not found: code 위와 같이 찾을 수 없다는 에러가 나오면 환경변수 path 비주얼스튜디오 코드를 추가해야 합니다. 먼저 비주얼스튜디오 코드를 실행합니다. Command + Shift + P를 눌러 팔레트를 실행합니다. Shell Command : Install code in PATH를 검색하여 실행합니다. 이후에는 쉘에서, code .를 입력하여 vscode 를 실행할 수 있습니다. Refs https://stackoverflow.com/questions/30065227/run-open-vscode-from-mac-terminal","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"IDE","slug":"Application/IDE","permalink":"http://jacegem.github.io/blog/categories/Application/IDE/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://jacegem.github.io/blog/tags/mac/"},{"name":"vscode","slug":"vscode","permalink":"http://jacegem.github.io/blog/tags/vscode/"},{"name":"shell","slug":"shell","permalink":"http://jacegem.github.io/blog/tags/shell/"}]},{"title":"[Leaflet] 플러그인 heatmap.js 사용하기","slug":"2018/Leaflet-플러그인-heatmap-js-사용하기","date":"2018-01-24T06:52:29.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Leaflet-플러그인-heatmap-js-사용하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/Leaflet-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-heatmap-js-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","excerpt":"","text":"[Leaflet] 플러그인 heatmap.js 사용하기 heatmap.js를 사용하여 heatmap을 표현해 보겠습니다. https://www.patrick-wied.at/static/heatmapjs/example-heatmap-leaflet.html 에서 예제를 확인할 수 있습니다. Leaflet CSS, JS 추가 12345678910111213&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.css&quot;/&gt; &lt;script src=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/heatmap.js/2.0.2/heatmap.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/leaflet-heatmap@1.0.0/leaflet-heatmap.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; leaflet 사용을 위해서 css, js를 포함하는 기본 코드를 작성합니다. leaflet-heatmap.html(또는 원하는 파일명)로 파일을 저장합니다. leaflet에서 heatmap.js를 사용하여 표현하기 위해서는 heatmap.js 와 leaflet-heatmap.js를 추가합니다. 지도 영역 추가 123456&lt;body&gt; &lt;div id=&quot;mapid&quot; style=&quot;height:100%;&quot;&gt;&lt;/div&gt; &lt;script&gt; // sciprt 작성 &lt;/script&gt;&lt;/body&gt; 지도 생성 스크립트 12345678910111213&lt;body&gt; &lt;div id=&quot;mapid&quot; style=&quot;height:100%;&quot;&gt;&lt;/div&gt; &lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom &#125;); L.tileLayer(&#x27;http://tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); &lt;/script&gt;&lt;/body&gt; 오픈스트리트맵(‘http://tile.openstreetmap.org/{z}/{x}/{y}.png’)을 사용하여 지도를 생성합니다. 좌표 정보 생성 1234567891011121314151617181920212223242526272829303132&lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom, &#125;); L.tileLayer(&#x27;http://tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); var pointList = []; var pointCnt = 10; var scale = 1000; for (var i = 0; i &lt; pointCnt; i++) &#123; pointList.push(&#123; lat: lat + i / scale, lng: lng + i / scale, count: i &#125;, ); &#125; for (var i = 0; i &lt; pointCnt; i++) &#123; var point = pointList[i]; L.marker(&#123; lat: point.lat, lng: point.lng &#125;).addTo(mymap); &#125;&lt;/script&gt; heatmap 표현을 위해서는 데이터가 필요하기 때문에 좌표정보와 데이터를 포함하는 오브젝트를 생성하여 처리합니다. 12345&#123; lat: lat, lng: lng, count: i&#125; heatmap 데이터 설정 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt; // 이전 코드 var pointList = []; var pointCnt = 10; var scale = 1000; for (var i = 0; i &lt; pointCnt; i++) &#123; pointList.push(&#123; lat: lat + i / scale, lng: lng + i / scale, count: i &#125;, ); &#125; for (var i = 0; i &lt; pointCnt; i++) &#123; var point = pointList[i]; L.marker(&#123; lat: point.lat, lng: point.lng &#125;).addTo(mymap); &#125; var cfg = &#123; //&quot;radius&quot;: 2, &quot;radius&quot;: 200, &quot;maxOpacity&quot;: .5, //&quot;scaleRadius&quot;: true, &quot;scaleRadius&quot;: false, &quot;useLocalExtrema&quot;: true, latField: &#x27;lat&#x27;, lngField: &#x27;lng&#x27;, valueField: &#x27;count&#x27; &#125;; var heatmapLayer = new HeatmapOverlay(cfg).addTo(mymap); var testData = &#123; max: 10, data: pointList &#125; heatmapLayer.setData(testData); &lt;/script&gt; 해당 줌 영역에서 heatmap이 보이도록 설정값을 수정하였습니다. “radius”: 200, “scaleRadius”: false, 123456789101112131415161718&lt;script&gt; // 이전 코드 var heatmapLayer = new HeatmapOverlay(cfg).addTo(mymap); var max = 10; var animationTimer = window.setInterval(function()&#123; for(var i =0; i &lt; pointCnt; i++)&#123; var point = pointList[i]; point.count = ( point.count + 1 ) % max &#125; var testData = &#123; max: max, data: pointList &#125; heatmapLayer.setData(testData); &#125;, 100) &lt;/script&gt; setInterval을 사용하여 애니메이션 효과를 추가할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"leaflet","slug":"leaflet","permalink":"http://jacegem.github.io/blog/tags/leaflet/"},{"name":"heatmap","slug":"heatmap","permalink":"http://jacegem.github.io/blog/tags/heatmap/"}]},{"title":"[Leaflet] 플러그인 PolylineDecorator 사용하기","slug":"2018/Leaflet-플러그인-PolylineDecorator-사용하기","date":"2018-01-23T06:52:12.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Leaflet-플러그인-PolylineDecorator-사용하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/Leaflet-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-PolylineDecorator-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","excerpt":"","text":"[Leaflet] 플러그인 PolylineDecorator 사용하기 Leaflet 플러그인 중에서, Markers &amp; renders에 있는 Leaflet.PolylineDecorator를 사용하여 폴리라인을 꾸며보겠습니다. https://github.com/bbecquet/Leaflet.PolylineDecorator 깃헙 페이지에서 사용법을 확인할 수 있습니다. 간단하게 사용하기 위해 CDN(https://cdnjs.com/libraries/leaflet-polylinedecorator)에 있는 leaflet-polylinedecorator.js를 사용하겠습니다. Leaflet CSS, JS 추가 123456789101112&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.css&quot;/&gt; &lt;script src=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/leaflet-polylinedecorator/1.1.0/leaflet.polylineDecorator.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; leaflet 사용을 위해서 css, js를 포함하는 기본 코드를 작성합니다. leaflet-polylinedecorator.html(또는 원하는 파일명)로 파일을 저장합니다. 지도 영역 추가 123&lt;body&gt; &lt;div id=&quot;mapid&quot; style=&quot;height:100%;&quot;&gt;&lt;/div&gt;&lt;/body&gt; 지도 생성 스크립트 12345678910111213&lt;body&gt; &lt;div id=&quot;mapid&quot; style=&quot;height:100%;&quot;&gt;&lt;/div&gt; &lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom &#125;); L.tileLayer(&#x27;http://xdworld.vworld.kr:8080/2d/Base/201710/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); &lt;/script&gt;&lt;/body&gt; vworld 에서 제공하는 타일맵 서비스를 이용합니다. (http://xdworld.vworld.kr:8080/2d/Base/201710/{z}/{x}/{y}.png) 지도를 생성하고, center, zoom을 설정하여 최초 보이는 영역을 설정하였습니다. 지금까지 작성한 파일을 저장하고, 크롬 브라우저로 실행하면 브라우저에 지도가 나오는 모습을 확인할 수 있습니다. 위치 데이터 생성 123456789101112131415161718192021&lt;script&gt; var x = 37.481; var y = 126.893; var z = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [x, y], zoom: z &#125;); L.tileLayer(&#x27;http://xdworld.vworld.kr:8080/2d/Base/201710/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); var points = []; var scale = 1000; for (var i = 0; i &lt; 10; i++) &#123; points.push([x + i / scale, y + i / scale]); &#125; for (var i = 0; i &lt; points.length; i++) &#123; var point = points[i]; L.marker(point).addTo(mymap); &#125;&lt;/script&gt; 지도상에 생성한 위치에 마커가 표시됩니다. polylineDecorator 생성 12345678910111213141516171819&lt;script&gt; // 이전 코드 var points = []; var scale = 1000; for (var i = 0; i &lt; 10; i++) &#123; points.push([x + i / scale, y + i / scale]); &#125; for (var i = 0; i &lt; points.length; i++) &#123; var point = points[i]; L.marker(point).addTo(mymap); &#125; var highlightPolyline = L.polylineDecorator(pointList, &#123; patterns: [ pattern, pattern ] &#125;).addTo(mymap); &lt;/script&gt; pattern 들을 입력하여 polylineDecorator를 생성합니다. 123456789101112131415161718&lt;script&gt; // 이전 코드 var highlightPolyline = L.polylineDecorator(pointList, &#123; patterns: [&#123; offset: 0, repeat: 20, symbol: L.Symbol.dash(&#123; pixelSize: 10, pathOptions: &#123; color: &#x27;#f00&#x27;, weight: 2 &#125; &#125;) &#125;] &#125;).addTo(mymap); &lt;/script&gt; dash 심볼을 추가하여 생성하였습니다. 12345678910111213141516171819202122232425262728&lt;script&gt; // 이전 코드 var highlightPolyline = L.polylineDecorator(pointList, &#123; patterns: [&#123; offset: 0, repeat: 20, symbol: L.Symbol.dash(&#123; pixelSize: 10, pathOptions: &#123; color: &#x27;#f00&#x27;, weight: 2 &#125; &#125;) &#125;, &#123; offset: 0, repeat: 50, symbol: L.Symbol.arrowHead(&#123; pixelSize: 15, polygon: false, pathOptions: &#123; stroke: true &#125; &#125;) &#125;] &#125;).addTo(mymap); &lt;/script&gt; patterns 속성에는 여러개의 pattern을 넣을 수 있습니다. 화살표를 하나 더 추가하여 생성하였습니다. fitBounds 1234567891011121314151617181920212223242526272829&lt;script&gt; // 이전 코드 var highlightPolyline = L.polylineDecorator(pointList, &#123; patterns: [&#123; offset: 0, repeat: 20, symbol: L.Symbol.dash(&#123; pixelSize: 10, pathOptions: &#123; color: &#x27;#f00&#x27;, weight: 2 &#125; &#125;) &#125;, &#123; offset: 0, repeat: 50, symbol: L.Symbol.arrowHead(&#123; pixelSize: 15, polygon: false, pathOptions: &#123; stroke: true &#125; &#125;) &#125;] &#125;).addTo(mymap); mymap.fitBounds(highlightPolyline.getBounds()); &lt;/script&gt; fitBounds 함수를 호출하여 지도상에서 생성한 polylineDecorator가 모두 보이게 됩니다. 애니메이션 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt; // 이전 코드 var highlightPolyline = L.polylineDecorator(pointList, &#123; patterns: [&#123; offset: 0, repeat: 20, symbol: L.Symbol.dash(&#123; pixelSize: 10, pathOptions: &#123; color: &#x27;#f00&#x27;, weight: 2 &#125; &#125;) &#125;, &#123; offset: 0, repeat: 50, symbol: L.Symbol.arrowHead(&#123; pixelSize: 15, polygon: false, pathOptions: &#123; stroke: true &#125; &#125;) &#125;] &#125;).addTo(mymap); mymap.fitBounds(highlightPolyline.getBounds()); var arrowRepeat = 50; var arrowOffset = 0; var animationTimer = window.setInterval(function () &#123; highlightPolyline.setPatterns([&#123; offset: 0, repeat: 20, symbol: L.Symbol.dash(&#123; pixelSize: 10, pathOptions: &#123; color: &#x27;#f00&#x27;, weight: 2 &#125; &#125;) &#125;, &#123; offset: arrowOffset, repeat: arrowRepeat, symbol: L.Symbol.arrowHead(&#123; pixelSize: 15, polygon: false, pathOptions: &#123; stroke: true &#125; &#125;) &#125;]) arrowOffset += 5; if (arrowOffset &gt; arrowRepeat) arrowOffset = 0; &#125;, 100);&lt;/script&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"leaflet","slug":"leaflet","permalink":"http://jacegem.github.io/blog/tags/leaflet/"},{"name":"PolylineDecorator","slug":"PolylineDecorator","permalink":"http://jacegem.github.io/blog/tags/PolylineDecorator/"}]},{"title":"[Leaflet] 시작하기 Quick Start Guide","slug":"2018/Leaflet-시작하기-Quick-Start-Guide","date":"2018-01-22T06:51:20.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/Leaflet-시작하기-Quick-Start-Guide/","link":"","permalink":"http://jacegem.github.io/blog/2018/Leaflet-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Quick-Start-Guide/","excerpt":"","text":"[Leaflet] 시작하기 Quick Start Guide http://leafletjs.com/examples/quick-start/ 에 있는 가이드 문서를 보면서 실습을 진행하겠습니다. Leaflet CSS, JS 추가 1234567891011&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.css&quot;/&gt; &lt;script src=&quot;https://unpkg.com/leaflet@1.2.0/dist/leaflet.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; leaflet 사용을 위해서 css, js를 포함하는 기본 코드를 작성합니다. leaflet.html(또는 원하는 파일명)로 파일을 저장합니다. 지도 영역 추가 123&lt;body&gt; &lt;div id=&quot;mapid&quot; style=&quot;height:100%;&quot;&gt;&lt;/div&gt;&lt;/body&gt; body 태그안에 맵을 표출할 영역을 div 태그로 생성합니다. 브라우저 전체에 표출되도록 높이를 100%로 하는 스타일을 추가하였습니다. 지도 생성 스크립트 12345678910111213&lt;body&gt; &lt;div id=&quot;mapid&quot; style=&quot;height:100%;&quot;&gt;&lt;/div&gt; &lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom &#125;); L.tileLayer(&#x27;http://xdworld.vworld.kr:8080/2d/Base/201710/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); &lt;/script&gt;&lt;/body&gt; vworld 에서 제공하는 타일맵 서비스를 이용합니다. (http://xdworld.vworld.kr:8080/2d/Base/201710/{z}/{x}/{y}.png) 지도를 생성하고, center, zoom을 설정하여 최초 보이는 영역을 설정하였습니다. 지금까지 작성한 파일을 저장하고, 크롬 브라우저로 실행하면 브라우저에 지도가 나오는 모습을 확인할 수 있습니다. 마커 추가 지정한 lat, lng 좌표에 마커를 추가합니다. 123456789101112&lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom &#125;); L.tileLayer(&#x27;http://xdworld.vworld.kr:8080/2d/Base/201710/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); var marker = L.marker([lat, lng]).addTo(mymap);&lt;/script&gt; var marker = L.marker([lat, lng]).addTo(mymap); 코드를 추가한 후 브라우저로 파일을 열면 마커가 추가된 모습을 확인할 수 있습니다. 원 추가 지정한 lat, lng 좌표에 원를 추가합니다. 색상, 투명도, 반경등을 설정할 수 있습니다. 123456789101112131415161718192021&lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom &#125;); L.tileLayer(&#x27;http://xdworld.vworld.kr:8080/2d/Base/201710/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); var marker = L.marker([lat, lng]).addTo(mymap); var distance = 0.001; var circle = L.circle([lat - distance, lng - distance], &#123; color: &#x27;red&#x27;, fillColor: &#x27;#f03&#x27;, fillOpacity: 0.5, radius: 50 &#125;).addTo(mymap);&lt;/script&gt; 폴리곤 추가 좌표 정보들을 입력하여 폴리곤을 생성합니다. 12345678910111213141516171819202122232425262728&lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom &#125;); L.tileLayer(&#x27;http://xdworld.vworld.kr:8080/2d/Base/201710/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); var marker = L.marker([lat, lng]).addTo(mymap); var distance = 0.001; var circle = L.circle([lat - distance, lng - distance], &#123; color: &#x27;red&#x27;, fillColor: &#x27;#f03&#x27;, fillOpacity: 0.5, radius: 50 &#125;).addTo(mymap); var polygon = L.polygon([ [lat + distance, lng + distance], [lat + distance, lng - distance], [lat - distance, lng - distance], [lat - distance, lng + distance] ]).addTo(mymap);&lt;/script&gt; 팝업 추가 위에서 생성한 마커, 원, 폴리콘에 팝업을 추가합니다. 1234567891011121314151617181920212223242526272829303132&lt;script&gt; var lat = 37.481; var lng = 126.893; var zoom = 20; var mymap = L.map(&#x27;mapid&#x27;, &#123; center: [lat, lng], zoom: zoom &#125;); L.tileLayer(&#x27;http://xdworld.vworld.kr:8080/2d/Base/201710/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;).addTo(mymap); var marker = L.marker([lat, lng]).addTo(mymap); var distance = 0.001; var circle = L.circle([lat - distance, lng - distance], &#123; color: &#x27;red&#x27;, fillColor: &#x27;#f03&#x27;, fillOpacity: 0.5, radius: 50 &#125;).addTo(mymap); var polygon = L.polygon([ [lat + distance, lng + distance], [lat + distance, lng - distance], [lat - distance, lng - distance], [lat - distance, lng + distance] ]).addTo(mymap); marker.bindPopup(&quot;&lt;b&gt;Hello world!&lt;/b&gt;&lt;br&gt;I am a popup.&quot;).openPopup(); circle.bindPopup(&quot;I am a circle.&quot;); polygon.bindPopup(&quot;I am a polygon.&quot;);&lt;/script&gt; 마커, 원, 폴리곤을 클릭하면 각각 지정한 팝업에 표출됩니다. 12345678&lt;script&gt; // 이전 코드 var popup = L.popup() .setLatLng([lat + distance, lng + distance]) .setContent(&quot;I am a standalone popup.&quot;) .openOn(mymap);&lt;/script&gt; 객체에 연결하지 않고 팝업만 지도위에 추가할 수 도 있습니다. 이벤트 추가 이벤트를 등록합니다. 123456789&lt;script&gt; // 이전 코드 function onMapClick(e) &#123; alert(&quot;You clicked the map at &quot; + e.latlng); &#125; mymap.on(&#x27;click&#x27;, onMapClick);&lt;/script&gt; 클릭이벤트를 등록하고, 이벤트가 발생하면, 좌표정보를 보여줍니다. 1234567891011121314151617181920&lt;script&gt; // 이전 코드 // function onMapClick(e) &#123; // alert(&quot;You clicked the map at &quot; + e.latlng); // &#125; // mymap.on(&#x27;click&#x27;, onMapClick); var popup = L.popup(); function onMapClick(e) &#123; popup .setLatLng(e.latlng) .setContent(&quot;You clicked the map at &quot; + e.latlng.toString()) .openOn(mymap); &#125; mymap.on(&#x27;click&#x27;, onMapClick);&lt;/script&gt; alert창 대신에, 팝업에 좌표정보가 표출되도록 변경하였습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"leaflet","slug":"leaflet","permalink":"http://jacegem.github.io/blog/tags/leaflet/"}]},{"title":"[OpenCV-Python Tutorials] 21. Contours(윤곽선) 추가 기능","slug":"2018/OpenCV-Python-Tutorials-21-Contours-윤곽선-추가-기능","date":"2018-01-21T10:18:37.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-21-Contours-윤곽선-추가-기능/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-21-Contours-%EC%9C%A4%EA%B3%BD%EC%84%A0-%EC%B6%94%EA%B0%80-%EA%B8%B0%EB%8A%A5/","excerpt":"","text":"[OpenCV-Python Tutorials] 21. Contours(윤곽선) 추가 기능 목표 볼록성 결함 및 그 결함을 찾는 방법. 점에서 다각형까지 최단 거리 찾기 다른 모양 맞추기 이론 및 코드 1. 볼록성 결함 윤곽선에 대한 두 번째 장에서 볼록한 선체가 무엇인지 보았습니다. 이 선체에서 물체가 이탈하면 볼록 결함으로 간주 될 수 있습니다. OpenCV에는 이것을 찾을 수있는 기성 함수가 제공됩니다 cv2.convexityDefects(). 기본 함수 호출은 다음과 같습니다. 12hull = cv2.convexHull(cnt,returnPoints = False)defects = cv2.convexityDefects(cnt,hull) convexity 결함을 찾기 위해 convex hull을 찾는 동안 returnPoints = False를 전달해야한다는 것을 기억하십시오. 각 행에 [시작점, 끝점, 가장 먼 지점, 가장 가까운 지점까지의 대략적인 거리] 값이 들어있는 배열을 반환합니다. 이미지를 사용하여 시각화 할 수 있습니다. 우리는 시작점과 끝점을 연결하는 선을 그린 다음 먼 지점에 원을 그립니다. 처음 세 개의 값은 cnt의 인덱스임을 기억하십시오. 그래서 우리는 그 값들을 cnt에서 가져와야 합니다. 1234567891011121314151617181920212223import cv2import numpy as npimg = cv2.imread(&#x27;star.jpg&#x27;)img_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(img_gray, 127, 255,0)contours,hierarchy = cv2.findContours(thresh,2,1)cnt = contours[0]hull = cv2.convexHull(cnt,returnPoints = False)defects = cv2.convexityDefects(cnt,hull)for i in range(defects.shape[0]): s,e,f,d = defects[i,0] start = tuple(cnt[s][0]) end = tuple(cnt[e][0]) far = tuple(cnt[f][0]) cv2.line(img,start,end,[0,255,0],2) cv2.circle(img,far,5,[0,0,255],-1)cv2.imshow(&#x27;img&#x27;,img)cv2.waitKey(0)cv2.destroyAllWindows() 결과 2. 점 다각형 테스트 이 함수는 이미지의 점과 윤곽 사이의 최단 거리를 찾습니다. 거리가 윤곽선 외부에 있을 때 음수이고, 점이 내부에 있을 때 양수이고, 점이 윤곽선 위에 있으면 0입니다. 예를 들어 다음과 같이 점 (50,50)을 확인할 수 있습니다. 1dist = cv2.pointPolygonTest(cnt,(50,50),True) 함수에서 세 번째 인수는 measureDist입니다. Ture이면 부호가 있는 거리를 찾습니다. False이면 점이 내부 또는 외부인지 윤곽선위에 있는지 찾습니다 (각각 +1, -1, 0을 반환). 거리를 찾고 싶지 않다면 세 번째 인수가 False임을 확인하십시오. 왜냐하면 시간이 많이 소요되는 프로세스이기 때문입니다. 따라서 False로 설정하면 약 2-3 배의 속도 향상을 얻을 수 있습니다. 3. 도형 맞추기 OpenCV에는 두 개의 도형 또는 두 개의 윤곽선을 비교하고 유사성을 나타내는 메트릭을 반환하는 cv2.matchShapes() 함수가 있습니다. 결과가 낮을수록 더 일치합니다. hu-moment 값을 기반으로 계산됩니다. 다른 측정 방법은 문서에 설명되어 있습니다. 123456789101112131415import cv2import numpy as npimg1 = cv2.imread(&#x27;star.jpg&#x27;,0)img2 = cv2.imread(&#x27;star2.jpg&#x27;,0)ret, thresh = cv2.threshold(img1, 127, 255,0)ret, thresh2 = cv2.threshold(img2, 127, 255,0)contours,hierarchy = cv2.findContours(thresh,2,1)cnt1 = contours[0]contours,hierarchy = cv2.findContours(thresh2,2,1)cnt2 = contours[0]ret = cv2.matchShapes(cnt1,cnt2,1,0.0)print ret 아래에 주어진 다른 모양으로 일치하는 모양을 시도하였습니다. 결과는 다음과 같습니다. 이미지 A와 이미지 A(일치) = 0.0 이미지 A와 이미지 B = 0.001946 이미지 A와 이미지 C = 0.326911 이미지의 회전이 비교에 많은 영향을 미치지 않습니다. Hu-Moments은 translation, 회전 및 크기에 영향을 받지 않는 seven moments입니다. 일곱 번째 것은 왜곡 불변입니다. 이러한 값은 cv2.HuMoments() 함수를 사용하여 찾을 수 있습니다. 연습 문제 cv2.pointPolygonTest()에 대한 설명서를 확인하십시오. 빨간색과 파란색으로 멋진 이미지를 찾을 수 있습니다. 모든 픽셀에서 흰색 곡선까지의 거리를 나타냅니다. 곡선 안에있는 모든 픽셀은 거리에 따라 파란색입니다. 마찬가지로 외부 포인트는 빨간색입니다. 윤곽선 모서리는 흰색으로 표시됩니다. 문제는 간단합니다. 그런 거리 표현을 만드는 코드를 작성하십시오. cv2.matchShapes()를 사용하여 숫자 나 문자의 이미지를 비교하십시오. (OCR을 향한 간단한 단계 일 것입니다) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_more_functions/py_contours_more_functions.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 20. Contours(윤곽선) 속성","slug":"2018/OpenCV-Python-Tutorials-20-Contours-윤곽선-속성","date":"2018-01-20T10:18:19.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-20-Contours-윤곽선-속성/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-20-Contours-%EC%9C%A4%EA%B3%BD%EC%84%A0-%EC%86%8D%EC%84%B1/","excerpt":"","text":"[OpenCV-Python Tutorials] 20. Contours(윤곽선) 속성 여기서는 Solidity, Equivalent Diameter, Mask image, Mean Intensity 등과 같은 객체에서 자주 사용되는 속성을 추출하는 방법을 배웁니다. 더 많은 기능은 Matlab regionprops 문서에서 찾을 수 있습니다. (주의 : Centroid, Area, Perimeter 등은 이전 장에서 보았습니다) 1. 종횡비 (Aspect Ratio) 이것은 객체의 경계 사각형의 너비와 높이의 비율입니다. Aspect Ratio=WidthHeightAspect \\; Ratio = \\frac{Width}{Height} AspectRatio=HeightWidth​ 12x,y,w,h = cv2.boundingRect(cnt)aspect_ratio = float(w)/h 2. 범위 (Extent) Extent는 윤곽선 영역과 경계 사각형 영역의 비율입니다. Extent=Object AreaBounding Rectangle AreaExtent = \\frac{Object \\; Area}{Bounding \\; Rectangle \\; Area} Extent=BoundingRectangleAreaObjectArea​ 3. 견고성 (Solidity) Solidity는 Contour 영역과 볼록한 선체 영역의 비율입니다. Solidity=Contour AreaConvex Hull AreaSolidity = \\frac{Contour \\; Area}{Convex \\; Hull \\; Area} Solidity=ConvexHullAreaContourArea​ 1234area = cv2.contourArea(cnt)hull = cv2.convexHull(cnt)hull_area = cv2.contourArea(hull)solidity = float(area)/hull_area 4. 등가 지름 (Equivalent Diameter) 등가 지름은 윤곽 영역과 동일한 영역의 원의 직경입니다. Equivalent Diameter=4×Contour AreaπEquivalent \\; Diameter = \\sqrt{\\frac{4 \\times Contour \\; Area}{\\pi}} EquivalentDiameter=π4×ContourArea​​ 12area = cv2.contourArea(cnt)equi_diameter = np.sqrt(4*area/np.pi) 5. 오리엔테이션 Orientation은 객체가 향하는 각도입니다. 다음 방법은 주요 축과 보조 축 길이를 제공합니다. 1(x,y),(MA,ma),angle = cv2.fitEllipse(cnt) 6. 마스크와 픽셀 포인트 어떤 경우에는 그 대상을 구성하는 모든 점이 필요할 수도 있습니다. 다음과 같이 수행 할 수 있습니다. 1234mask = np.zeros(imgray.shape,np.uint8)cv2.drawContours(mask,[cnt],0,255,-1)pixelpoints = np.transpose(np.nonzero(mask))#pixelpoints = cv2.findNonZero(mask) 여기에는 Numpy 함수를 사용하는 방법과 OpenCV 함수를 사용하는 두 가지 방법 (마지막 주석 처리 된 줄)이 있습니다. 결과도 동일하지만 약간의 차이가 있습니다. Numpy는 (행, 열) 형식으로 좌표를 제공하고 OpenCV는 (x, y) 형식으로 좌표를 제공합니다. row = x 및 column = y입니다. 7. 최대 값, 최소값 및 위치 이 매개 변수는 마스크 이미지를 사용하여 찾을 수 있습니다. 1min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(imgray,mask = mask) 9. 익스트림 포인트 Extreme Points는 객체의 가장 위쪽, 가장 아래쪽, 가장 오른쪽 및 가장 왼쪽의 점을 의미합니다. 1234leftmost = tuple(cnt[cnt[:,:,0].argmin()][0])rightmost = tuple(cnt[cnt[:,:,0].argmax()][0])topmost = tuple(cnt[cnt[:,:,1].argmin()][0])bottommost = tuple(cnt[cnt[:,:,1].argmax()][0]) 예를 들어 인도지도에 적용하면 다음과 같은 결과가 나타납니다. 연습문제 아직 MATLAB 지역 프로젝트 문서에 남아있는 몇 가지 기능이 있습니다. 그것들을 구현해 보세요. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_properties/py_contour_properties.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 19. Contours(윤곽선) 특징","slug":"2018/OpenCV-Python-Tutorials-19-Contours-윤곽선-특징","date":"2018-01-19T10:17:53.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-19-Contours-윤곽선-특징/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-19-Contours-%EC%9C%A4%EA%B3%BD%EC%84%A0-%ED%8A%B9%EC%A7%95/","excerpt":"","text":"[OpenCV-Python Tutorials] 19. Contours(윤곽선) 특징 목표 면적, 둘레, 중심, 경계 상자 등 윤곽선의 다른 특징 윤곽선과 관련된 다양한 기능 1. Moments Image moments은 물체의 중심, 물체의 면적 등과 같은 일부 기능을 계산하는 데 도움이 됩니다. 함수 cv2.moments()는 모든 moment 값의 사전을 계산합니다. 아래를 참조하십시오 : 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;star.jpg&#x27;,0)ret,thresh = cv2.threshold(img,127,255,0)contours,hierarchy = cv2.findContours(thresh, 1, 2)cnt = contours[0]M = cv2.moments(cnt)print M 이 moments부터 면적, 중심 등 유용한 데이터를 추출 할 수 있습니다. Centroid는 $$C_x = \\frac{M_{10}}{M_{00}}$$ 및 $$C_y = \\frac{M_{01}}{M_{00}}$$ 로 부터 얻을 수 있습니다. 이 작업은 다음과 같이 수행 할 수 있습니다. 12cx = int(M[&#x27;m10&#x27;]/M[&#x27;m00&#x27;])cy = int(M[&#x27;m01&#x27;]/M[&#x27;m00&#x27;]) 2. Contour Area(영역) Contour 영역은 함수 cv2.contourArea() 또는 moments M['m00']에 의해 주어집니다. 1area = cv2.contourArea(cnt) 3. Contour Perimeter(경계선) arc length 라고도 합니다. cv2.arcLength() 함수를 사용하여 찾을 수 있습니다. 두 번째 인수는 True로 전달 된 경우 닫힌 contour가 되며 아닌 경우에는 곡선이 됩니다. 1perimeter = cv2.arcLength(cnt,True) 4. Contour Approximation(근사) 우리가 지정한 정밀도에 따라 Contour 모양을 정점 수가 적은 다른 모양으로 근사합니다. Douglas-Peucker 알고리즘의 구현입니다. 아래에 표시된 첫 이미지처럼 나쁜 모양인 경우 이미지의 사각형을 찾으려고 노력하지만, 이미지의 몇 가지 문제에 대한 완전한 사각형을 얻을 수 없습니다. 이때 이 함수를 사용하여 형상을 근사 할 수 있습니다. 이 두 번째 인수는 epsilon이라 불리며, 엡실론은 윤곽에서 근사 된 윤곽까지의 최대 거리입니다. 정밀도 매개 변수입니다. 올바른 출력을 얻기 위해서는 현명한 epsilon의 선택이 필요합니다. 12epsilon = 0.1*cv2.arcLength(cnt,True)approx = cv2.approxPolyDP(cnt,epsilon,True) 아래의 두 번째 이미지는 녹색 선은 epsilon = 10% of arc length의 추세선을 보여줍니다. 제 3의 이미지는 epsilon = 1% of the arc length에서 같은 것을 나타낸 것입니다. 세번째 인수는 곡선이 닫혀 있는지 여부를 지정합니다. 5. Convex Hull Convex Hull은 contour approximation와 비슷해 보이지만 그렇지 않습니다. (같은 결과를 얻을지도 모릅니다.) 여기에서는 cv2.convexHull() 함수 곡선에 볼록 결함을 확인하고 수정합니다. 일반적으로 볼록한 곡선은 항상 불룩 또는 적어도 평탄한 곡선입니다. 그리고 안쪽으로 부풀어 오른 경우는 볼록 결함이라고 합니다. 예를 들어, 다음 단계의 이미지를 확인하십시오. 빨간색 선은 손의 볼록 선체를 보여줍니다. 양면 화살표 표시는 등고선에서 선체의 국부적인 최대 편차인 볼록 결함을 나타냅니다. 구문에 대해 약간 논의 할 사항이 있습니다. 1hull = cv2.convexHull(points[, hull[, clockwise[, returnPoints]] 인수 상세 정보 : point: 포인트는 우리가 전달하는 윤곽입니다. hull: 선체는 출력이지만, 일반적으로 피합니다. clockwise: 시계 방향 : 방향 플래그. True이면 출력 볼록 선체는 시계 방향입니다. 그렇지 않으면 시계 반대 방향입니다. returnPoints : 기본적으로 True입니다. 다음 선체 점의 좌표를 반환합니다. False이면 선체 점에 대응하는 윤곽 점의 인덱스를 돌려줍니다. 따라서 위의 이미지처럼 볼록 선체를 얻으려면 다음과 같이하면 됩니다. 1hull = cv2.convexHull(cnt) 그러나 convexity 결함을 찾으려면 eturnPoints = False를 전달해야 합니다. 이를 이해하기 위해 위의 사각형 이미지를 사용합니다. 처음에는 그 윤곽선을 cnt로 찾았습니다. 이제 returnPoints = True로 볼록한 선체를 발견했습니다. 다음 값을 얻었습니다 : [[234 202]], [[51 202]], [[514 79]], [499] 직사각형의 점. 이제 returnPoints = False로 동일하게 수행하면 [[129], [67], [0], [142]] 결과를 얻습니다. 이것들은 등고선의 대응점의 색인입니다. 예를 들어, 첫 번째 값을 확인하십시오 : cnt [129] = [[234, 202]] 이는 첫 번째 결과와 같습니다 (다른 것들도 마찬가지입니다). 그러나 convexity 결함을 찾으려면 eturnPoints = False를 전달해야 합니다. 그것을 이해하기 위해서는 위의 사각형 이미지를 다룹니다. 처음에는 그 윤곽선을 cnt로 찾았습니다. returnPoints = True로 볼록 선체를 찾아내어 사각형의 점 값을 얻었습니다. [[[234 202], [51 202], [51 79], [234 79]]] . 이번에는 returnPoints = False 처럼하면 결과는 [[[129] [67] [0] [142]]]입니다. 이들은 등고선의 대응점의 인덱스입니다. 예를 들어, 첫 번째 결과와 같은 cnt[129] = [[234,202]]의 첫 번째 값을 확인합니다 (다른 경우도 마찬가지). 볼록 결함에 대해 논의 할 때 다시 그것을 볼 것입니다. 6. Convexity 확인 cv2.isContourConvex()는 커브가 볼록인지 여부를 확인하는 기능이 있습니다. True 또는 False를 반환합니다. Not a big deal. 1k = cv2.isContourConvex(cnt) 7. 경계 사각형 경계 사각형은 2 가지가 있습니다. 7.a. 직선 경계 사각형 그것은 직사각형이며 객체의 회전을 고려하지 않습니다. 따라서 경계 사각형의 영역은 최소가 되지 않습니다. 이것은 cv2.boundingRect() 함수를 통해 찾을 수 있습니다. (x, y)를 직사각형의 왼쪽 위 좌표로 하고 (w, h)를 폭과 높이로 합니다. 12x,y,w,h = cv2.boundingRect(cnt)img = cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contour_features/py_contour_features.html#moments https://acidsound.github.io/transplus/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 18. Contours(윤곽선) 시작하기","slug":"2018/OpenCV-Python-Tutorials-18-Contours-윤곽선-시작하기","date":"2018-01-18T10:17:33.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-18-Contours-윤곽선-시작하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-18-Contours-%EC%9C%A4%EA%B3%BD%EC%84%A0-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","excerpt":"","text":"[OpenCV-Python Tutorials] 18. Contours(윤곽선) 시작하기 목표 Contours(윤곽선)이 무엇인지에 대한 이해 등고선 찾기, 등고선 그리기 함수: cv2.findContours(), cv2.drawContours() contours(윤곽)이란? 윤곽선은 동일한 색상 또는 강도를 갖는 모든 연속 점 (경계를 따라)을 결합하는 곡선으로 간단히 설명 할 수 있습니다. 윤곽선은 형상 분석 및 객체 감지 및 인식에 유용한 도구입니다. 정확성을 높이려면 이진 이미지를 사용하십시오. 따라서 윤곽선을 찾기 전에 임계점 또는 canny edge detection를 적용하십시오. findContours 함수는 소스 이미지를 수정합니다. 따라서 윤곽선을 찾은 후에도 소스 이미지를 원한다면 이미 다른 변수에 저장하십시오. OpenCV에서 윤곽선을 찾는 것은 검정 배경에서 흰색 물체를 찾는 것과 같습니다. 그러므로 찾을 물체는 흰색이어야하고 배경은 검은색이어야 합니다. 이진 이미지의 윤곽선을 찾는 방법을 살펴 보겠습니다. 1234567import numpy as npimport cv2im = cv2.imread(&#x27;test.jpg&#x27;)imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)ret,thresh = cv2.threshold(imgray,127,255,0)image, contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) cv2.findContours() 함수에는 세 개의 인수가 있습니다. 첫 번째는 소스 이미지이고, 두 번째는 등고선 검색 모드이고, 세 번째는 등고선 근사 방법입니다. 그리고 이미지, contours 및 계층을 출력합니다. contours은 이미지의 모든 윤곽을 파이썬으로 나타낸 목록입니다. 각각의 개별 윤곽은 객체의 경계 지점의 (x, y) 좌표의 객체 배열입니다. 나중에 두 번째 및 세 번째 인수와 계층 구조에 대해 자세히 설명합니다. 그때까지는 코드 예제에서 주어진 값이 모든 이미지에서 잘 작동합니다. contours(윤곽)을 그리는 방법? contours을 그리려면 cv2.drawContours 함수가 사용됩니다. 또한 경계 지점이 있는 경우 모든 모양을 그리는 데 사용할 수 있습니다. 첫 번째 인수는 소스 이미지이고, 두 번째 인수는 파이썬 목록으로 전달되어야하는 contours이며, 세 번째 인수는 contours 색인입니다 (개별 윤곽선을 그리는 데 유용합니다. 모든 윤곽선을 그리려면 -1을 전달합니다.) 나머지 인수는 색상, 두께 등입니다. 이미지에 모든 윤곽선을 그리려면 : 1img = cv2.drawContours(img, contours, -1, (0,255,0), 3) 개별 윤곽선을 그리려면 4 번째 윤곽선을 말하십시오. 1img = cv2.drawContours(img, contours, 3, (0,255,0), 3) 하지만 대부분의 경우 아래의 메소드가 유용합니다. 12cnt = contours[4]img = cv2.drawContours(img, [cnt], 0, (0,255,0), 3) 마지막 두 가지 방법은 동일하지만 앞으로 나아갈 때 마지막 방법이 더 유용하다는 것을 알 수 있습니다. Contour 근사 방법 이것은 cv2.findContours 함수의 세 번째 인수입니다. 그것은 실제로 무엇을 나타낼까요? 위에서 우리는 contours 이 동일한 강도를 지닌 모양의 경계라고 이야기했습니다. 도형 경계의 (x, y) 좌표를 저장합니다. 그러나 그것은 모든 좌표를 저장할까요? 윤곽 근사법으로 지정됩니다. cv2.CHAIN_APPROX_NONE를 넘겨 주면 모든 경계 지점이 저장됩니다. 그러나 실제로 모든 포인트가 필요할까요? 예를 들어, 직선의 윤곽을 발견했습니다. 그 라인을 나타 내기 위해 라인의 모든 포인트가 필요할까요? 아닙니다. 우리는 그 선의 두 종점만 있으면 됩니다. 이것이 cv2.CHAIN_APPROX_SIMPLE의 기능입니다. 모든 중복 점을 제거하고 윤곽을 압축하여 메모리를 절약합니다. 아래 사각형 이미지는 이 기법을 보여줍니다. 등고선 배열(파란색으로 그려 짐)의 모든 좌표에 원을 그립니다. 첫 번째 이미지는 cv2.CHAIN_APPROX_NONE (734개의 점)으로 얻은 점을 표시하고 두 번째 이미지는 cv2.CHAIN_APPROX_SIMPLE (4개의 점만)으로 표시합니다. 얼마나 많은 메모리가 절약되는지 확인하시기 바랍니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_contours/py_contours_begin/py_contours_begin.html#contours-getting-started","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 17. 이미지 피라미드","slug":"2018/OpenCV-Python-Tutorials-17-이미지-피라미드","date":"2018-01-17T10:17:09.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-17-이미지-피라미드/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-17-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%94%BC%EB%9D%BC%EB%AF%B8%EB%93%9C/","excerpt":"","text":"[OpenCV-Python Tutorials] 17. 이미지 피라미드 목표 이미지 피라미드에 대해 알아보겠습니다. Image 피라미드를 사용하여 새로운 이미지를 만들어볼게요 함수: cv2.pyrUp(), cv2.pyrDown() 이론 일반적으로 우리는 일정한 크기의 이미지로 작업했습니다. 그러나 어떤 경우에는 같은 이미지의 다른 해상도의 이미지로 작업해야 합니다. 예를 들어, 얼굴과 같은 이미지에서 무언가를 검색하는 동안 이미지에 어떤 크기의 물체가 나타날지 확신 할 수 없습니다. 이 경우, 우리는 해상도가 다른 일련의 이미지를 만들고 모든 이미지에서 객체를 검색해야합니다. 서로 다른 해상도의 이미지 세트를 Image Pyramids라고 부릅니다. 왜냐하면 피라미드처럼 맨 아래에 가장 큰 이미지가 가장 큰 이미지가 있는 스택에 보관되어 있기 때문입니다. 이미지 피라미드에는 두 가지 종류가 있습니다. 가우시안 피라미드 라플라시안 피라미드 Gaussian 피라미드의 높은 레벨(저해상도)은 낮은 레벨(고해상도) 이미지에서 연속적인 행과 열을 제거하여 생성합니다. 이렇게 하면, $$ M \\times N $$ 이미지는 $$M/2 \\times N/2$$ 이미지가 됩니다. 따라서 면적은 원래 면적의 1/4로 줄어 듭니다. 그것은 옥타브라고 합니다. 피라미드에서 위쪽으로 갈수록 같은 패턴이 계속됩니다 (즉, 해상도가 감소합니다). 마찬가지로 확장하면서 면적은 각 단계에서 4 배가 됩니다. cv2.pyrDown() 및 cv2.pyrUp() 함수를 사용하여 가우시안 피라미드를 찾을 수 있습니다. 1234567891011121314151617import cv2img = cv2.imread(&#x27;model.jpg&#x27;)titles = [&#x27;orginal&#x27;, &#x27;level1&#x27;, &#x27;level2&#x27;, &#x27;level3&#x27;]images = []images.append(img)for i in range(3): img = cv2.pyrDown(img) images.append(img)for i in range(4): cv2.imshow(titles[i], images[i])cv2.waitKey(0)cv2.destroyAllWindows() 아래는 이미지 피라미드의 4 단계입니다. 이제 cv2.pyrUp() 함수를 사용하여 이미지 피라미드로 이동할 수 있습니다. 1higher_reso2 = cv2.pyrUp(lower_reso) 1234567891011121314151617import cv2img = cv2.imread(&#x27;small.jpg&#x27;)titles = [&#x27;orginal&#x27;, &#x27;level1&#x27;, &#x27;level2&#x27;, &#x27;level3&#x27;]images = []images.append(img)for i in range(3): img = cv2.pyrUp(img) images.append(img)for i in range(4): cv2.imshow(titles[i], images[i])cv2.waitKey(0)cv2.destroyAllWindows() Laplacian 피라미드는 Gaussian Pyramids에서 형성됩니다. 거기에 대한 독점적인 기능은 없습니다. Laplacian 피라미드 이미지는 가장자리 이미지와 같습니다. 요소의 대부분은 0입니다. 이미지 압축에 사용됩니다. 라플라시안 피라미드의 레벨은 가우시안 피라미드의 해당 레벨과 가우시안 피라미드의 상위 레벨 확장 버전의 차이에 의해 형성됩니다. Laplacian 레벨의 세 가지 레벨은 아래와 같이 보일 것입니다 (내용을 향상시키기 위해 대비가 조정 됨). 123456789101112131415161718192021import cv2img = cv2.imread(&#x27;large.jpg&#x27;)titles = [&#x27;orginal&#x27;, &#x27;level1&#x27;, &#x27;level2&#x27;, &#x27;level3&#x27;]images = []images.append(img)for i in range(3): img = cv2.pyrDown(img) images.append(img)for i in range(3): resize = cv2.resize(images[i] , dsize=(images[i+1].shape[1], images[i+1].shape[0]) , interpolation=cv2.INTER_CUBIC) images[i] = cv2.subtract(resize, images[i+1]) cv2.imshow(titles[i], images[i])cv2.waitKey(0)cv2.destroyAllWindows() 피라미드를 사용한 이미지 블렌딩 피라미드의 한 응용 프로그램은 이미지 블렌딩입니다. 예를 들어, 이미지 바느질에서는 두 이미지를 함께 쌓아야 하지만 이미지간에 불연속성으로 인해 잘 보이지 않을 수 있습니다. 이 경우 피라미드로 이미지 블렌딩을 하면 이미지에 많은 데이터를 남기지 않고도 원활한 혼합이 가능합니다. 하나의 고전적인 예는 Orange와 Apple의 두 과일을 혼합 한 것입니다. 지금 하고 있는 것을 이해하기 위해 지금 결과를 확인해보세요 추가 리소스의 첫 번째 참조를 확인하십시오. 이미지 블렌딩, Laplacian Pyramids 등의 전체 다이어그램 세부 정보가 있습니다. 간단히 말해서 다음과 같이 수행됩니다. 사과와 오렌지의 두 이미지 로드 사과와 오렌지에 대한 가우시안 피라미드를 찾으십시오 (이 예제에서는 레벨 수가 6입니다). 가우시안 피라미드에서 라플라시안 피라미드를 찾으십시오. 이제 Laplacian Pyramids의 각 레벨에서 사과의 왼쪽 절반과 오렌지의 오른쪽 절반에 합칩니다. 마지막으로이 공동 이미지 피라미드에서 원래 이미지를 재구성하십시오. 전체 코드는 다음과 같습니다. (간단히하기 위해 각 단계가 별도로 수행되므로 더 많은 메모리가 필요할 수 있습니다. 원하는 경우 최적화 할 수 있습니다). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import cv2import numpy as npA = cv2.imread(&#x27;resize_a.jpg&#x27;)B = cv2.imread(&#x27;resize_b.jpg&#x27;)B = cv2.resize(B, dsize=(A.shape[1], A.shape[0]), interpolation=cv2.INTER_CUBIC)# generate Gaussian pyramid for AG = A.copy()gpA = [G]for i in range(6): G = cv2.pyrDown(G) gpA.append(G)# generate Gaussian pyramid for BG = B.copy()gpB = [G]for i in range(6): G = cv2.pyrDown(G) gpB.append(G)# generate Laplacian Pyramid for AlpA = [gpA[5]]for i in range(5, 0, -1): GE = cv2.pyrUp(gpA[i]) L = cv2.subtract(gpA[i - 1], GE) lpA.append(L)# generate Laplacian Pyramid for BlpB = [gpB[5]]for i in range(5, 0, -1): GE = cv2.pyrUp(gpB[i]) L = cv2.subtract(gpB[i - 1], GE) lpB.append(L)# Now add left and right halves of images in each levelLS = []for la, lb in zip(lpA, lpB): rows, cols, dpt = la.shape ls = np.hstack((la[:, 0:int(cols / 2)], lb[:, int(cols / 2):])) LS.append(ls)# now reconstructls_ = LS[0]for i in range(1, 6): ls_ = cv2.pyrUp(ls_) ls_ = cv2.add(ls_, LS[i])# image with direct connecting each halfreal = np.hstack((A[:, :int(cols / 2)], B[:, int(cols / 2):]))cv2.imwrite(&#x27;Pyramid_blending2.jpg&#x27;, ls_)cv2.imwrite(&#x27;Direct_blending.jpg&#x27;, real) 두 이미지의 크기가 동일해야 합니다. ls = np.hstack((la[:, 0:int(cols / 2)], lb[:, int(cols / 2):])) 에서 정수값이 입력되야 하므로, int() 를 사용하였습니다. Additional Resources Image Blending 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_pyramids/py_pyramids.html https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220508552078&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 16. Canny Edge Detection","slug":"2018/OpenCV-Python-Tutorials-16-Canny-Edge-Detection","date":"2018-01-16T10:16:50.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-16-Canny-Edge-Detection/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-16-Canny-Edge-Detection/","excerpt":"","text":"[OpenCV-Python Tutorials] 16. Canny Edge Detection 목표 Canny edge detection의 개념 OpenCV 함수 : cv2.Canny() 이론 Canny Edge Detection은 널리 사용 되는 가장자리 감지 알고리즘입니다. 이것은 1986 년 John F. Canny가 개발했습니다. 이것은 다중 단계 알고리즘이며 각 단계를 거치게 됩니다. Noise 제거 가장자리 감지는 이미지의 노이즈에 영향 받기 쉽기 때문에 5x5 가우스 필터를 사용하여 이미지의 노이즈를 제거해야 합니다. 이전 장에서 이미 살펴 보았습니다. 이미지의 강도 기울기 찾기 (Finding Intensity Gradient of the Image) Smoothened 이미지는 Sobel 커널로 수평 및 수직 방향으로 필터링되어 수평 방향 $$(G_x)$$ 및 수직 방향 $$(G_y)$$에서 1차 미분을 얻습니다. 이 두 이미지에서 다음과 같이 에지 기울기와 각 픽셀의 방향을 찾을 수 있습니다. Edge_Gradient (G)=Gx2+Gy2Angle (θ)=tan⁡−1(GyGx)\\begin{array}{r} Edge\\_Gradient \\; (G) = \\sqrt{G_x^2 + G_y^2} \\\\ Angle \\; (\\theta) = \\tan^{-1} \\bigg(\\frac{G_y}{G_x}\\bigg) \\end{array} Edge_Gradient(G)=Gx2​+Gy2​​Angle(θ)=tan−1(Gx​Gy​​)​ 기울기 방향은 항상 가장자리에 수직입니다. 수직, 수평 및 대각선 방향을 나타내는 4 개의 각도 중 하나로 반올림됩니다. Non-maximum 억제 그레디언트의 크기와 방향을 얻은 후 가장자리를 구성하지 않을 수 있는 원치 않는 픽셀을 제거하기 위해 이미지의 전체 스캔이 수행됩니다. 이를 위해, 모든 픽셀에서 픽셀은 그라디언트 방향에서 인접 픽셀의 로컬 최대 값인지 확인합니다. 아래 이미지를 확인하십시오. 점 A는 가장자리에 있습니다 (수직 방향). 경사 방향은 가장자리에 수직입니다. 점 B와 C는 기울기 방향입니다. 따라서 점 A와 점 B를 사용하여 점 A와 점 B를 확인하여 극대점을 찾습니다. 그렇다면 다음 단계로 간주되며, 그렇지 않으면 억제됩니다 (0으로 설정). 간단히 말해서, 결과는 &quot;얇은 가장자리&quot;가 있는 이진 이미지입니다. Hysteresis Thresholding 이 단계에서는 모든 가장자리가 실제로 가장자리인지 아닌지를 결정 합니다. 이를 위해 두 개의 임계값 인 minVal과 maxVal이 필요합니다. 강도 기울기가 maxVal보다 큰 모서리는 모서리이어야 하며 minVal보다 작은 모서리는 반드시 모서리가 아니므로 버려야 합니다. 이 두 임계 값 사이에있는 사람들은 연결 상태에 따라 가장자리 또는 비 가장자리로 분류됩니다. 픽셀이 &quot;확실한&quot;픽셀에 연결되면 가장자리의 일부로 간주됩니다. 그렇지 않으면 삭제됩니다. 아래 이미지를 참조하십시오. 가장자리 A는 maxVal보다 높으므로 &quot;확실한 가장자리&quot;로 간주됩니다. 에지 C는 maxVal보다 낮지만 에지 A에 연결되므로 유효한 에지로 간주되어 전체 곡선을 얻습니다. 그러나 가장자리 B는 minVal보다 크고 가장자리 C와 동일한 영역에 있지만 어떤 &quot;확실한 가장자리&quot;에도 연결되어 있지 않으므로 삭제됩니다. 따라서 올바른 결과를 얻으려면 minVal 및 maxVal을 선택해야한다는 것이 매우 중요합니다. 이 단계는 또한 가장자리가 긴 선이라고 가정 할 때 작은 픽셀 노이즈를 제거합니다. 그래서 우리가 마침내 얻을 수있는 것은 이미지의 강한 가장자리입니다. OpenCV에서 Canny Edge Detection OpenCV는 위의 모든 것을 단일 함수, cv2.Canny()에 넣습니다. 우리는 그것을 어떻게 사용하는지 볼 것입니다. 첫 번째 인자는 우리의 입력 이미지입니다. 두 번째 및 세 번째 인수는 각각 minVal 및 maxVal입니다. 세 번째 인수는 조리개 값입니다. 그것은 이미지 구배 찾기에 사용되는 Sobel 커널의 크기입니다. 기본적으로 3입니다. 마지막 인수는 그라디언트 크기를 찾는 방정식을 지정하는 L2gradient입니다. True이면 위에서 언급 한 방정식을 사용합니다. 기본값은 False이며, $$Edge_Gradient ; (G) = |G_x| + |G_y|$$. 를 사용합니다. 12345678910111213import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&#x27;messi5.jpg&#x27;,0)edges = cv2.Canny(img,100,200)plt.subplot(121),plt.imshow(img,cmap = &#x27;gray&#x27;)plt.title(&#x27;Original Image&#x27;), plt.xticks([]), plt.yticks([])plt.subplot(122),plt.imshow(edges,cmap = &#x27;gray&#x27;)plt.title(&#x27;Edge Image&#x27;), plt.xticks([]), plt.yticks([])plt.show() 결과: 추가 리소스 위키피디아의 Canny Edge Detector Canny Edge Detection Tutorial (Bill Green, 2002) 연습 문제 두 개의 트랙 바를 사용하여 임계 값을 변경할 수있는 Canny 가장자리 감지를 찾으려면 작은 응용 프로그램을 작성하십시오. 이렇게 하면 임계 값의 영향을 이해할 수 있습니다. 123456789101112131415161718192021222324252627import cv2img = cv2.imread(&#x27;canny.jpg&#x27;)img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)cv2.namedWindow(&#x27;image&#x27;)def nothing(x): pass# create trackbars for color changecv2.createTrackbar(&#x27;threshold1&#x27;, &#x27;image&#x27;, 0, 255, nothing)cv2.createTrackbar(&#x27;threshold2&#x27;, &#x27;image&#x27;, 0, 255, nothing)while True: threshold1 = cv2.getTrackbarPos(&#x27;threshold1&#x27;, &#x27;image&#x27;) threshold2 = cv2.getTrackbarPos(&#x27;threshold2&#x27;, &#x27;image&#x27;) edges = cv2.Canny(img, threshold1, threshold2) cv2.imshow(&#x27;image&#x27;, edges) k = cv2.waitKey(1) &amp; 0xFF if k == 27: breakcv2.destroyAllWindows() threshold1, threshold2 의 값을 변경시키면서 Canny Edge Detection의 변화를 확인 할 수 있습니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_canny/py_canny.html https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220507996391&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 15. 이미지 Gradients","slug":"2018/OpenCV-Python-Tutorials-15-이미지-Gradients","date":"2018-01-15T10:16:32.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-15-이미지-Gradients/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-15-%EC%9D%B4%EB%AF%B8%EC%A7%80-Gradients/","excerpt":"","text":"[OpenCV-Python Tutorials] 15. 이미지 Gradients 목표 Image gradients, edges 찾기 cv2.Sobel(), cv2.Scharr(), cv2.Laplacian() 이론 OpenCV는 Sobel, Scharr 및 Laplacian의 세 가지 유형의 그래디언트 필터 또는 하이 패스 필터를 제공합니다. 이것들을 각각 알아보겠습니다. 1. Sobel과 Scharr Derivatives Sobel 연산자는 Gaussian smoothing 과 미분 연산으로 노이즈에 더 강합니다. yorder 및 xorder 인수에 의해 각각 파생 될 방향을 수직 또는 수평으로 지정할 수 있습니다. ksize 인수로 커널의 크기를 지정할 수도 있습니다. ksize = -1 인 경우 3x3 Scharr 필터가 사용되어 3x3 Sobel 필터보다 우수한 결과를 제공합니다. 사용된 커널에 대한 문서를 참조하십시오. 2. 라플라시안 파생 릴랙스에 의해 주어진 이미지의 라플라시안을 계산합니다. $$\\Delta src = \\frac{\\partial ^2{src}}{\\partial x^2} + \\frac{\\partial ^2{src}}{\\partial y^2}$$ 여기서 각 파생물은 Sobel 파생을 사용하여 발견됩니다. ksize = 1이면 다음 커널이 필터링에 사용됩니다. kernel=[0101−41010]kernel = \\begin{bmatrix} 0 &amp; 1 &amp; 0 \\\\\\\\ 1 &amp; -4 &amp; 1 \\\\\\\\ 0 &amp; 1 &amp; 0 \\end{bmatrix} kernel=⎣⎢⎢⎢⎢⎢⎡​010​1−41​010​⎦⎥⎥⎥⎥⎥⎤​ 코드 아래의 코드는 모든 다이어그램의 연산자를 보여줍니다. 모든 커널은 5x5 크기입니다. 출력 이미지의 깊이는 -1을 전달하여 np.uint8 유형으로 결과를 얻습니다. 12345678910111213141516171819import cv2from matplotlib import pyplot as pltimg = cv2.imread(&#x27;kakuro.png&#x27;)laplacian = cv2.Laplacian(img, cv2.CV_64F)sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)plt.subplot(2, 2, 1), plt.imshow(img, cmap=&#x27;gray&#x27;)plt.title(&#x27;Original&#x27;), plt.xticks([]), plt.yticks([])plt.subplot(2, 2, 2), plt.imshow(laplacian, cmap=&#x27;gray&#x27;)plt.title(&#x27;Laplacian&#x27;), plt.xticks([]), plt.yticks([])plt.subplot(2, 2, 3), plt.imshow(sobelx, cmap=&#x27;gray&#x27;)plt.title(&#x27;Sobel X&#x27;), plt.xticks([]), plt.yticks([])plt.subplot(2, 2, 4), plt.imshow(sobely, cmap=&#x27;gray&#x27;)plt.title(&#x27;Sobel Y&#x27;), plt.xticks([]), plt.yticks([])plt.show() 결과: 하나의 중요한 문제! 마지막 예에서 출력 데이터 유형은 cv2.CV_8U 또는 np.uint8입니다. 하지만 약간의 문제가 있습니다. 화이트 투 블랙 (Black to White) 전환은 네거티브 (Negative) 슬로프 (Negative Slope)로 간주되는 반면, 블랙 투 화이트 전환은 포지티브 슬로프 (Positive Slope) (양의 값을 가짐)로 취해진다. 따라서 데이터를 np.uint8로 변환하면 모든 음의 기울기가 0이됩니다. 간단한 말로, 당신은 그 가장자리를 놓치게됩니다. 두 모서리를 모두 감지하려면 출력 데이터 유형을 cv2.CV_16S, cv2.CV_64F 등의 상위 형식으로 유지하고 절대 값을 취한 다음 다시 cv2.CV_8U로 변환하십시오. 아래 코드는 수평 소벨 (Sobel) 필터와 결과의 차이에 대한이 절차를 보여줍니다. 12345678910111213141516171819202122import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&#x27;box.png&#x27;, 0)# Output dtype = cv2.CV_8Usobelx8u = cv2.Sobel(img, cv2.CV_8U, 1, 0, ksize=5)# Output dtype = cv2.CV_64F. Then take its absolute and convert to cv2.CV_8Usobelx64f = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)abs_sobel64f = np.absolute(sobelx64f)sobel_8u = np.uint8(abs_sobel64f)plt.subplot(1, 3, 1), plt.imshow(img, cmap=&#x27;gray&#x27;)plt.title(&#x27;Original&#x27;), plt.xticks([]), plt.yticks([])plt.subplot(1, 3, 2), plt.imshow(sobelx8u, cmap=&#x27;gray&#x27;)plt.title(&#x27;Sobel CV_8U&#x27;), plt.xticks([]), plt.yticks([])plt.subplot(1, 3, 3), plt.imshow(sobel_8u, cmap=&#x27;gray&#x27;)plt.title(&#x27;Sobel abs(CV_64F)&#x27;), plt.xticks([]), plt.yticks([])plt.show() 아래의 결과를 확인하십시오 : 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_gradients/py_gradients.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 14. 형태론적 변환","slug":"2018/OpenCV-Python-Tutorials-14-형태론적-변환","date":"2018-01-14T10:15:58.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-14-형태론적-변환/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-14-%ED%98%95%ED%83%9C%EB%A1%A0%EC%A0%81-%EB%B3%80%ED%99%98/","excerpt":"","text":"[OpenCV-Python Tutorials] 14. 형태론적 변환 목표 이 장에서는 Erosion, Dilation, Opening, Closing과 같은 다른 형태학적인 작동을 배울 것입니다. cv2.erode(), cv2.dilate(), cv2.morphologyEx() 등과 같은 다른 함수를 보게 될 것입니다. 이론 형태학적 변형은 이미지 모양을 기반으로 한 몇 가지 간단한 작업입니다. 일반적으로 이진 이미지에서 수행됩니다. 그것은 두 개의 입력이 필요합니다. 하나는 우리의 원래 이미지이고, 두 번째는 구조 요소 또는 커널이라고 불리며 동작의 성격을 결정합니다. 두 가지 기본 형태학 연산자는 Erosion과 Dilation입니다. 그런 다음 Opening, Closing, Gradient 등과 같은 변형 된 형태도 작용합니다. 우리는 다음 이미지를 통해 하나씩 살펴볼 것입니다. 1. Erosion Erosion의 기본 아이디어는 토양 침식과 같습니다. 전경 물체의 경계를 부식시킵니다 (항상 전경을 흰색으로 유지하려고 노력합니다). 그러면 어떻게 됩니까? 커널은 2D 컨볼루션 에서 처럼 이미지를 따라 슬라이드합니다. 원래 이미지의 픽셀 (1 또는 0)은 커널 아래의 모든 픽셀이 1 인 경우에만 1로 간주되고, 그렇지 않으면 침식 (0으로 설정)됩니다. 그렇다면 경계 근처의 모든 픽셀은 커널의 크기에 따라 버려집니다. 따라서 전경 물체의 두께나 크기가 줄어들거나 단순히 이미지의 흰색 영역이 줄어 듭니다. 작은 흰색 노이즈를 없애고 (색상 공간 장에서 보았듯이) 연결된 두 객체를 분리하는 등의 작업에 유용합니다. 여기 예를 들어 5x5 커널에 1x5 커널을 사용할 것입니다. 그것이 어떻게 작동하는지 살펴보겠습니다. 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;snow.jpg&#x27;, 0)kernel = np.ones((5, 5), np.uint8)erosion = cv2.erode(img, kernel, iterations=1)cv2.imshow(&#x27;erosion&#x27;, erosion)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 2. Dilation 그것은 Erosion의 정반대입니다. 여기서, 커널 아래의 적어도 하나의 픽셀이 '1’이면 픽셀 요소는 '1’이다. 따라서 이미지의 흰색 영역이 증가하거나 전경 오브젝트의 크기가 커집니다. 일반적으로 노이즈 제거와 같은 경우에는 erosion 후에 Dilation를 사용합니다. 왜냐하면 erosion은 백색 잡음을 제거하지만 또한 우리의 대상 객체 또한 축소시킵니다. 그런 다음에 dilate 합니다. 노이즈는 사라지므로 되살아 나지는 않습니다. 또한 객체의 깨진 부분을 결합하는 데 유용합니다. 1dilation = cv2.dilate(img,kernel,iterations = 1) 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;snow.jpg&#x27;, 0)kernel = np.ones((5, 5), np.uint8)dilation = cv2.dilate(img,kernel,iterations = 1)cv2.imshow(&#x27;dilation&#x27;, dilation)cv2.waitKey(0)cv2.destroyAllWindows() 결과 3. Opening 오프닝은 erosion과 dilation의 또 다른 이름입니다. 위에서 설명했듯이 노이즈를 제거하는데 유용합니다. 여기서는 cv2.morphologyEx() 함수를 사용합니다. 1opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel) 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;snow.jpg&#x27;, 0)kernel = np.ones((5, 5), np.uint8)opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)cv2.imshow(&#x27;opening&#x27;, opening)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 4. Closing Closing은 Opening과 반대입니다. 전경 오브젝트 내부의 작은 구멍이나 오브젝트의 작은 검은 점을 닫을 때 유용합니다. 1closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel) 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;snow.jpg&#x27;, 0)kernel = np.ones((5, 5), np.uint8)closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)cv2.imshow(&#x27;closing&#x27;, closing)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 5. Morphological Gradient (형태학 기울기) 그것은 이미지의 dilation과 erosion의 차이입니다. 결과는 객체의 윤곽선처럼 보입니다. 1gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel) 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;snow.jpg&#x27;, 0)kernel = np.ones((5, 5), np.uint8)gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)cv2.imshow(&#x27;gradient&#x27;, gradient)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 6. Top Hat 그것은 입력 이미지와 Opening 이미지의 차이입니다. 아래 예제는 9x9 커널에 대해 수행됩니다. 1tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel) 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;snow.jpg&#x27;, 0)kernel = np.ones((5, 5), np.uint8)tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)cv2.imshow(&#x27;tophat&#x27;, tophat)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 7. Black Hat 입력 이미지와 closing 이미지의 차이입니다. 1blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel) 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;snow.jpg&#x27;, 0)kernel = np.ones((5, 5), np.uint8)blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)cv2.imshow(&#x27;blackhat&#x27;, blackhat)cv2.waitKey(0)cv2.destroyAllWindows() 결과: 구조 요소 Numpy의 도움을 받아 앞의 예제에서 수동으로 구조 요소를 만들었습니다. 사각형 모양입니다. 그러나 어떤 경우에는 타원형 / 원형 커널이 필요할 수 있습니다. 그래서 이 목적을 위해 OpenCV는 cv2.getStructuringElement() 함수를 가지고 있습니다. 커널의 모양과 크기 만 전달하면 원하는 커널을 얻을 수 있습니다. 1234567891011121314151617181920212223# Rectangular Kernel&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_RECT,(5,5))array([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1]], dtype=uint8)# Elliptical Kernel&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5))array([[0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0]], dtype=uint8)# Cross-shaped Kernel&gt;&gt;&gt; cv2.getStructuringElement(cv2.MORPH_CROSS,(5,5))array([[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], dtype=uint8) 추가 리소스 HIPR2에서의 형태론적 조작 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_morphological_ops/py_morphological_ops.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 13. 이미지 Smoothing","slug":"2018/OpenCV-Python-Tutorials-13-이미지-Smoothing","date":"2018-01-13T10:15:42.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-13-이미지-Smoothing/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-13-%EC%9D%B4%EB%AF%B8%EC%A7%80-Smoothing/","excerpt":"","text":"[OpenCV-Python Tutorials] 13. 이미지 Smoothing 목표 배울 내용 다양한 저역 통과 필터로 이미지를 흐리게 처리. 이미지에 맞춤 필터 적용 (2D convolution) 2D Convolution (이미지 필터링) 1차원 신호의 경우 이미지는 다양한 저역 통과 필터 (LPF), 고역 통과 필터 (HPF) 등으로 필터링 할 수도 있습니다. LPF는 노이즈를 제거하거나 이미지를 흐리게 합니다. HPF 필터는 이미지의 가장자리를 찾는 데 도움이 됩니다. OpenCV는 이미지로 커널을 컨볼루션하는 함수, cv2.filter2D()를 제공합니다. 예를 들어 이미지에 대한 평균화 필터를 시도해 보겠습니다. 5x5 평균 필터 커널은 다음과 같이 정의 할 수 있습니다. K=125[1111111111111111111111111]K = \\frac{1}{25} \\begin{bmatrix} 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\\\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\\\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\\\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\\\\\ 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\end{bmatrix} K=251​⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​11111​11111​11111​11111​11111​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 위의 커널로 필터링하면 다음과 같은 결과가 발생합니다. 각 픽셀은 5x5 윈도우 픽셀의 가운데에 위치하며 이 창에 속하는 모든 픽셀을 더한 다음 결과를 25로 나눕니다. 해당 창 내부의 픽셀 값 중 이 작업은 출력 필터링 된 이미지를 생성하기 위해 이미지의 모든 픽셀에 대해 수행됩니다. 이 코드를 실행하고 결과를 확인하십시오. 12345678910111213141516171819import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&#x27;model.jpg&#x27;)img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)size = 50kernel = np.ones((size, size), np.float32) / (size * size)dst = cv2.filter2D(img, -1, kernel)cv2.imwrite(&#x27;model_output.png&#x27;, cv2.cvtColor(dst, cv2.COLOR_RGB2BGR))plt.subplot(121), plt.imshow(img), plt.title(&#x27;Original&#x27;)plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(dst), plt.title(&#x27;Averaging&#x27;)plt.xticks([]), plt.yticks([])plt.show() 결과: 변환 결과를 차이나게 만들기 위해서, 50 X 50 으로 변경하였습니다. 이미지 블러링 (이미지 스무딩) 이미지 블러링은 이미지를 저역 통과 필터 커널과 컨볼루션함으로써 달성됩니다. 소음을 제거 할 때 유용합니다. 이 필터를 적용하면 이미지에서 고주파 콘텐츠 (예 : 노이즈, 가장자리)가 실제로 흐려져 가장자리가 흐려집니다. (모서리를 흐리게 하지 않는 흐림 기법이 있습니다.) OpenCV는 주로 네 가지 유형의 흐림 기술을 제공합니다. 1. 평균화 이는 정규화된 상자 필터로 이미지를 컨벌루션하여 수행됩니다. 커널 영역 아래의 모든 픽셀의 평균을 취하고 중심 요소를 평균으로 바꿉니다. 이것은 cv2.blur() 또는 cv2.boxFilter() 함수에 의해 수행됩니다. 커널에 대한 자세한 내용은 문서를 확인하십시오. 커널의 너비와 높이를 지정해야합니다. 3x3 정규화 된 상자 필터는 다음과 같습니다. K=19[111111111]K = \\frac{1}{9} \\begin{bmatrix} 1 &amp; 1 &amp; 1 \\\\\\\\ 1 &amp; 1 &amp; 1 \\\\\\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix} K=91​⎣⎢⎢⎢⎢⎢⎡​111​111​111​⎦⎥⎥⎥⎥⎥⎤​ 정규화된 상자 필터를 사용하지 않으려면 cv2.boxFilter()를 사용하고 normalize = False 인수를 함수에 전달합니다. 아래의 샘플 데모를 5x5 크기의 커널로 확인하십시오. 12345678910111213import cv2from matplotlib import pyplot as pltimg = cv2.imread(&#x27;image.jpg&#x27;)img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)blur = cv2.blur(img, (5, 5))plt.subplot(121), plt.imshow(img), plt.title(&#x27;Original&#x27;)plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(blur), plt.title(&#x27;Blurred&#x27;)plt.xticks([]), plt.yticks([])plt.show() 결과: 2. 가우시안 필터링 이러한 접근법에서, 동일한 필터 계수로 구성된 박스 필터 대신에, 가우시안 커널이 사용된다. 함수 cv2.GaussianBlur()로 끝납니다. 커널의 너비와 높이를 지정해야 합니다. 커널의 너비와 높이는 양수이면서 홀수여야 합니다. X와 Y 방향의 표준 편차 sigmaX와 sigmaY를 각각 지정해야 합니다. sigmaX 만 지정된 경우 sigmaY는 sigmaX와 동일하게 취급됩니다. 둘 다 0으로 주어지면 커널 크기로부터 계산됩니다. 가우시안 필터링은 이미지에서 가우스 노이즈를 제거하는 데 매우 효과적입니다. 원하는 경우, 함수 cv2.getGaussianKernel()을 사용하여 가우스 커널을 생성 할 수 있습니다. 위의 코드는 가우시안 블러링으로 수정될 수 있습니다. 1blur = cv2.GaussianBlur(img,(5,5),0) 12345678910111213import cv2from matplotlib import pyplot as pltimg = cv2.imread(&#x27;happy.png&#x27;)img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)blur = cv2.GaussianBlur(img,(5,5),0)plt.subplot(121), plt.imshow(img), plt.title(&#x27;Original&#x27;)plt.xticks([]), plt.yticks([])plt.subplot(122), plt.imshow(blur), plt.title(&#x27;Blurred&#x27;)plt.xticks([]), plt.yticks([])plt.show() 결과: 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_filtering/py_filtering.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 12. 이미지의 기하학적 변환","slug":"2018/OpenCV-Python-Tutorials-12-이미지의-기하학적-변환","date":"2018-01-12T10:15:26.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-12-이미지의-기하학적-변환/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-12-%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%9D%98-%EA%B8%B0%ED%95%98%ED%95%99%EC%A0%81-%EB%B3%80%ED%99%98/","excerpt":"","text":"[OpenCV-Python Tutorials] 12. 이미지의 기하학적 변환 목표 translation, 회전, affine 변환 등과 같은 이미지에 다른 기하학적 변환을 적용하는 방법을 배웁니다. 다음 함수를 볼 수 있습니다 : cv2.getPerspectiveTransform 변환 OpenCV는 모든 종류의 변형을 가질 수 있는 두 가지 변환 함수, cv2.warpAffine 및 cv2.warpPerspective를 제공합니다. cv2.warpPerspective는 3x3 변환 행렬을 입력으로 받는 반면 cv2.warpAffine은 2x3 변환 행렬을 사용합니다. 스케일링 크기 조절은 단지 이미지의 크기를 조절하는 것입니다. OpenCV는 이 목적을 위해 함수 cv2.resize()를 제공합니다. 이미지의 크기는 수동으로 지정하거나 배율 인수를 지정할 수 있습니다. 다른 보간 방법이 사용됩니다. 바람직한 보간 방법은 축소를 위한 cv2.INTER_AREA와 확대를 위한 cv2.INTER_CUBIC(느림) &amp; cv2.INTER_LINEAR입니다. 기본값으로, 모든 사이즈 변경을 위해 사용되는 보간 법은 cv2.INTER_LINEAR입니다. 다음 방법 중 하나를 사용하여 입력 이미지의 크기를 조정할 수 있습니다. 12345678910import cv2import numpy as npimg = cv2.imread(&#x27;messi5.jpg&#x27;)res = cv2.resize(img,None,fx=2, fy=2, interpolation = cv2.INTER_CUBIC)#ORheight, width = img.shape[:2]res = cv2.resize(img,(2*width, 2*height), interpolation = cv2.INTER_CUBIC) cv2.resize() 함수의 파라미터 src: 스케일링할 이미지 dsize: 변경할 사이즈. 가로, 세로 형태의 tuple fx – 가로 사이즈의 배수. 2배로 크게하려면 2. 반으로 줄이려면 0.5 fy – 세로 사이즈의 배수 interpolation – 보간법 코드 12345678910111213import cv2from matplotlib import pyplot as pltimg = cv2.imread(&#x27;beach.jpg&#x27;)res1 = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_CUBIC)height, width = img.shape[:2]res2 = cv2.resize(img, (int(0.5 * width), int(0.5 * height)), interpolation=cv2.INTER_CUBIC)plt.subplot(1, 2, 1), plt.imshow(cv2.cvtColor(res1, cv2.COLOR_BGR2RGB)), plt.title(&#x27;res1&#x27;)plt.subplot(1, 2, 2), plt.imshow(cv2.cvtColor(res2, cv2.COLOR_BGR2RGB)), plt.title(&#x27;res2&#x27;)plt.show() matplotlib를 사용하여 표출할 경우에는 cv2.cvtColor(IMAGE, cv2.COLOR_BGR2RGB)를 호출하여 BGR 을 RGB로 변경해주어야 합니다. 변환 변환은 물체의 위치를 이동시키는 것입니다. $$(x, y)$$ 방향의 변화를 알고 있다면 $$(t_x, t_y)$$, 다음과 같이 변환 행렬 $$\\textbf{M}$$을 만들 수 있습니다 : M=[10tx01ty]M = \\begin{bmatrix} 1 &amp; 0 &amp; t_x \\\\\\\\ 0 &amp; 1 &amp; t_y \\end{bmatrix} M=⎣⎢⎡​10​01​tx​ty​​⎦⎥⎤​ np.float32 유형의 Numpy 배열로 만들고 cv2.warpAffine() 함수로 전달할 수 있습니다. 아래 (100,50) 이동하는 아래 예를 참조하세요. 1234567891011121314import cv2import numpy as npimg = cv2.imread(&#x27;model.jpg&#x27;, 1)rows, cols = img.shape[:2]M = np.float32([[1, 0, 100], [0, 1, 50]])dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow(&#x27;Original&#x27;, img)cv2.imshow(&#x27;warpAffine&#x27;, dst)cv2.waitKey(0)cv2.destroyAllWindows() cv2.warpAffine() 함수의 세 번째 인수는 출력 이미지의 크기이며, 너비, 높이 형태여야 합니다. width = 열 수 및 height = 행 수를 기억하세요. 아래 결과를 확인하세요: 회전 각도 $$\\theta$$에 대한 이미지의 회전은 형태의 변환 행렬에 의해 이루어진다. M=[cosθ−sinθsinθcosθ]M = \\begin{bmatrix} cos\\theta &amp; -sin\\theta \\\\\\\\ sin\\theta &amp; cos\\theta \\end{bmatrix} M=⎣⎢⎡​cosθsinθ​−sinθcosθ​⎦⎥⎤​ 그러나 OpenCV는 조정 가능한 회전 중심으로 크기가 조정 된 회전을 제공하므로 원하는 위치에서 회전 할 수 있습니다. 수정된 변환 행렬은 아래 수식에 의해 주어진다. [αβ(1−α)⋅center.x−β⋅center.y−βαβ⋅center.x+(1−α)⋅center.y]\\begin{bmatrix} \\alpha &amp; \\beta &amp; (1- \\alpha ) \\cdot center.x - \\beta \\cdot center.y \\\\\\\\ - \\beta &amp; \\alpha &amp; \\beta \\cdot center.x + (1- \\alpha ) \\cdot center.y \\end{bmatrix} ⎣⎢⎡​α−β​βα​(1−α)⋅center.x−β⋅center.yβ⋅center.x+(1−α)⋅center.y​⎦⎥⎤​ where: α=scale⋅cos⁡θ,β=scale⋅sin⁡θ\\begin{array}{l} \\alpha = scale \\cdot \\cos \\theta , \\\\\\\\ \\beta = scale \\cdot \\sin \\theta \\end{array} α=scale⋅cosθ,β=scale⋅sinθ​ 이 변환 행렬을 찾기 위해 OpenCV는 cv2.getRotationMatrix2D 함수를 제공합니다. 크기 조정없이 중앙을 기준으로 이미지를 90도 회전시키는 아래 예제를 확인하십시오. 12345678910111213import cv2img = cv2.imread(&#x27;rotate.jpg&#x27;, 1)rows, cols = img.shape[:2]M = cv2.getRotationMatrix2D((cols / 2, rows / 2), 90, 1)dst = cv2.warpAffine(img, M, (cols, rows))cv2.imshow(&#x27;Original&#x27;, img)cv2.imshow(&#x27;warpAffine&#x27;, dst)cv2.waitKey(0)cv2.destroyAllWindows() 결과보기 : Affine 변환 Affine 변환에서 원본 이미지의 모든 평행선은 출력 이미지에서 여전히 평행합니다. 변환 행렬을 찾으려면 입력 이미지와 출력 이미지의 해당 위치에서 세 점이 필요합니다. 그런 다음 cv2.getAffineTransform은 cv2.warpAffine에 전달 될 2x3 행렬을 작성합니다. 아래 예제를 확인하고 선택한 점(녹색으로 표시)을 확인하십시오. 123456789101112131415161718import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&#x27;affine.jpg&#x27;)rows, cols, ch = img.shape[:3]pts1 = np.float32([[50, 50], [200, 50], [50, 200]])pts2 = np.float32([[10, 100], [200, 50], [100, 250]])M = cv2.getAffineTransform(pts1, pts2)dst = cv2.warpAffine(img, M, (cols, rows))plt.subplot(121), plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB)), plt.title(&#x27;Input&#x27;)plt.subplot(122), plt.imshow(cv2.cvtColor(dst, cv2.COLOR_BGR2RGB)), plt.title(&#x27;Output&#x27;)plt.show() 결과보기 : 원근법 변환 원근감 변환의 경우 3x3 변환 행렬이 필요합니다. 직선은 변환 후에도 직선으로 유지됩니다. 이 변환 행렬을 찾으려면 입력 이미지와 출력 이미지의 해당 점에 4 포인트가 필요합니다. 이 4 점 중 3 점은 동일 선상에 있지 않아야 합니다. 그러면 변환 행렬은 함수 cv2.getPerspectiveTransform에서 찾을 수 있습니다. 그런 다음이 3x3 변환 행렬로 cv2.warpPerspective를 적용하십시오. 아래 코드를 참조하십시오. 123456789101112131415161718import cv2import numpy as npfrom matplotlib import pyplot as pltimg = cv2.imread(&#x27;sudoku.jpg&#x27;)rows, cols, ch = img.shape[:3]# pts1 = np.float32([[56, 65], [368, 52], [28, 387], [389, 390]])pts1 = np.float32([[101, 131], [500, 114], [66, 504], [544, 489]])pts2 = np.float32([[0, 0], [300, 0], [0, 300], [300, 300]])M = cv2.getPerspectiveTransform(pts1, pts2)dst = cv2.warpPerspective(img, M, (300, 300))plt.subplot(121), plt.imshow(img), plt.title(&#x27;Input&#x27;)plt.subplot(122), plt.imshow(dst), plt.title(&#x27;Output&#x27;)plt.show() 결과: np.float32([[101, 131], [500, 114], [66, 504], [544, 489]]) 에서 배열은 좌상, 우상, 좌하, 우하 의 순으로 포인트를 나열한 것입니다. 추가 리소스 컴퓨터 비전 : 알고리즘 및 응용, Richard Szeliski (“Computer Vision: Algorithms and Applications”, Richard Szeliski) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html http://opencv-python.readthedocs.io/en/latest/# https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220504966397&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 11. 이미지 임계값","slug":"2018/OpenCV-Python-Tutorials-11-이미지-임계값","date":"2018-01-11T10:15:03.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-11-이미지-임계값/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-11-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%9E%84%EA%B3%84%EA%B0%92/","excerpt":"","text":"[OpenCV-Python Tutorials] 11. 이미지 임계값 목표 이 튜토리얼에서는 Simple thresholding, Adaptive thresholding, Otsu의 thresholding 등을 배웁니다. cv2.threshold, cv2.adaptiveThreshold 등의 함수를 배웁니다. 단순 임계값 여기서 문제는 간단합니다. 픽셀 값이 임계 값보다 크면 하나의 값 (흰색 일 수 있음)이 지정되고, 그렇지 않으면 다른 값 (검정 일 수 있음)이 지정됩니다. 사용 된 함수는 cv2.threshold입니다. 첫 번째 인수는 원본 이미지이며 그레이 스케일 이미지여야만 합니다. 두 번째 인수는 픽셀 값을 분류하는 데 사용되는 임계 값입니다. 세 번째 인수는 픽셀 값이 임계 값보다 크거나 (때로는 작지 만) 주어질 값을 나타내는 maxVal입니다. OpenCV는 다양한 스타일의 임계 값을 제공하며 함수의 네 번째 매개 변수에 의해 결정됩니다. 다른 유형은 다음과 같습니다. cv2.THRESH_BINARY cv2.THRESH_BINARY_INV cv2.THRESH_TRUNC cv2.THRESH_TOZERO cv2.THRESH_TOZERO_INV 문서는 각 유형의 의미를 명확히 설명합니다. 문서를 확인하십시오. 2 개의 출력이 얻어진다. 첫 번째는 나중에 설명 할 retval입니다. 두 번째 출력은 임계값 이미지입니다. 코드: 12345678910111213141516171819import cv2from matplotlib import pyplot as pltimg = cv2.imread(&#x27;gradient.jpg&#x27;, 0)ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)titles = [&#x27;Original Image&#x27;, &#x27;BINARY&#x27;, &#x27;BINARY_INV&#x27;, &#x27;TRUNC&#x27;, &#x27;TOZERO&#x27;, &#x27;TOZERO_INV&#x27;]images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]for i in range(6): plt.subplot(2, 3, i + 1), plt.imshow(images[i], &#x27;gray&#x27;) plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 여러 이미지를 플롯하기 위해 plt.subplot() 함수를 사용했습니다. 자세한 내용은 Matplotlib 문서를 확인하십시오. 결과는 다음과 같습니다. 123def threshold(src, thresh, maxval, type, dst=None): # real signature unknown; restored from __doc__ &quot;&quot;&quot; threshold(src, thresh, maxval, type[, dst]) -&gt; retval, dst &quot;&quot;&quot; pass 적응형 임계값 이전 섹션에서는 임계 값으로 전역 값을 사용했습니다. 그러나 이미지가 다른 영역에서 다른 조명 조건을 갖는 모든 조건에서 좋지 않을 수 있습니다. 이 경우 적응형 임계값을 찾습니다. 이 알고리즘은 이미지의 작은 영역에 대한 임계값을 계산합니다. 따라서 동일한 이미지의 서로 다른 영역에 대해 서로 다른 임계값을 얻을 수 있으며 다양한 조명을 사용하여 이미지를 더 나은 결과를 얻을 수 있습니다. 3 개의 '특수'입력 매개 변수와 하나의 출력 인수만 있습니다. 적응 방법 - 임계 값 계산 방법을 결정합니다. cv2.ADAPTIVE_THRESH_MEAN_C : 임계값은 인접 지역의 평균입니다. cv2.ADAPTIVE_THRESH_GAUSSIAN_C : 임계값은 가중치 가우시안 윈도우인 이웃값의 가중치 합입니다. Block Size - 인접 지역의 크기를 결정합니다. C - 계산 된 평균 또는 가중 평균에서 빼는 상수입니다. 아래 코드는 다양한 조명을 사용하는 이미지의 전역 임계값과 적응 임계값을 비교합니다. 123456789101112131415161718192021import cv2from matplotlib import pyplot as pltimg = cv2.imread(&#x27;sunrise.jpg&#x27;, 0)img = cv2.medianBlur(img, 5)ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2)th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)titles = [&#x27;Original Image&#x27;, &#x27;Global Thresholding (v = 127)&#x27;, &#x27;Adaptive Mean Thresholding&#x27;, &#x27;Adaptive Gaussian Thresholding&#x27;]images = [img, th1, th2, th3]for i in range(4): plt.subplot(2, 2, i + 1), plt.imshow(images[i], &#x27;gray&#x27;) plt.title(titles[i]) plt.xticks([]), plt.yticks([])plt.show() 123def adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C, dst=None): # real signature unknown; restored from __doc__ &quot;&quot;&quot; adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst]) -&gt; dst &quot;&quot;&quot; pass Otsu 이선화 첫 번째 섹션에서는 retVal이라는 두 번째 매개 변수가 있다고 말씀드렸습니다. 오츠(Otsu)의 바이너리화(Binarization)를 할 때 사용됩니다. 무엇일까요? 전역 thresholding에서는 임계값에 임의의 값을 사용했습니다. 그렇다면 우리가 선택한 가치가 얼마나 좋은지 알 수 있습니까? 답은 시행 착오 방법입니다. 그러나 bimodal 이미지를 고려하십시오 (간단히 말하면, bimodal 이미지는 히스토그램에 두 개의 피크가 있는 이미지입니다). 그 이미지의 경우, 우리는 임계값으로 그 피크의 중간에서 값을 취할 수 있습니다. 맞습니까? Otsu 이진화가 그것이다. 따라서 간단한 말로, bimodal 이미지의 이미지 히스토그램으로부터 임계값을 자동으로 계산합니다. (bimodal이 아닌 이미지의 경우 이진화가 정확하지 않습니다.) 이를 위해 우리의 cv2.threshold() 함수가 사용되었지만 여분의 플래그인 cv2.THRESH_OTSU를 전달합니다. 임계값의 경우 단순히 0을 전달하십시오. 그런 다음 알고리즘은 최적임계 값을 찾아서 두 번째 출력인 retVal로 반환합니다. Otsu thresholding이 사용되지 않으면 retVal은 사용 된 임계값과 같습니다. 아래 예제를 확인하십시오. 입력 이미지는 잡음이 많은 이미지입니다. 첫 번째 경우에는 전역 임계값을 127로 적용했습니다. 두 번째 경우에는 Otsu의 임계값을 직접 적용했습니다. 세 번째 경우에는 노이즈를 제거하기 위해 5x5 가우시안 커널로 이미지를 필터링한 다음 Otsu thresholding을 적용했습니다. 노이즈 필터링이 어떻게 결과를 향상시키는 확인하십시오. 12345678910111213141516171819202122232425262728293031import cv2from matplotlib import pyplot as pltimg = cv2.imread(&#x27;model.jpg&#x27;, 0)# global thresholdingret1, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)# Otsu&#x27;s thresholdingret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# Otsu&#x27;s thresholding after Gaussian filteringblur = cv2.GaussianBlur(img, (5, 5), 0)ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# plot all the images and their histogramsimages = [img, 0, th1, img, 0, th2, blur, 0, th3]titles = [&#x27;Original Noisy Image&#x27;, &#x27;Histogram&#x27;, &#x27;Global Thresholding (v=127)&#x27;, &#x27;Original Noisy Image&#x27;, &#x27;Histogram&#x27;, &quot;Otsu&#x27;s Thresholding&quot;, &#x27;Gaussian filtered Image&#x27;, &#x27;Histogram&#x27;, &quot;Otsu&#x27;s Thresholding&quot;]for i in range(3): plt.subplot(3, 3, i * 3 + 1), plt.imshow(images[i * 3], &#x27;gray&#x27;) plt.title(titles[i * 3]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 2), plt.hist(images[i * 3].ravel(), 256) plt.title(titles[i * 3 + 1]), plt.xticks([]), plt.yticks([]) plt.subplot(3, 3, i * 3 + 3), plt.imshow(images[i * 3 + 2], &#x27;gray&#x27;) plt.title(titles[i * 3 + 2]), plt.xticks([]), plt.yticks([])plt.show() 결과: Otsu 이진화 동작 방법 이 섹션에서는 실제로 작동하는 방법을 보여주기 위해 Python이 Otsu의 이진화를 구현하는 방법을 보여줍니다. 관심이 없으면 이것을 건너 뛸 수 있습니다. Otsu의 알고리즘은 bimodal 이미지로 작업하기 때문에 관계에 의해 주어진 가중 클래스 내 분산을 최소화하는 임계 값 (t)을 찾으려고합니다. σw2(t)=q1(t)σ12(t)+q2(t)σ22(t)\\sigma_w^2(t) = q_1(t)\\sigma_1^2(t)+q_2(t)\\sigma_2^2(t) σw2​(t)=q1​(t)σ12​(t)+q2​(t)σ22​(t) where q1(t)=∑i=1tP(i)&amp;q1(t)=∑i=t+1IP(i)μ1(t)=∑i=1tiP(i)q1(t)&amp;μ2(t)=∑i=t+1IiP(i)q2(t)σ12(t)=∑i=1t[i−μ1(t)]2P(i)q1(t)&amp;σ22(t)=∑i=t+1I[i−μ1(t)]2P(i)q2(t)\\begin{array}{l} q_1(t) = \\sum_{i=1}^{t} P(i) \\quad \\&amp; \\quad q_1(t) = \\sum_{i=t+1}^{I} P(i) \\mu_1(t) = \\sum_{i=1}^{t} \\frac{iP(i)}{q_1(t)} \\quad \\&amp; \\quad \\mu_2(t) = \\sum_{i=t+1}^{I} \\frac{iP(i)}{q_2(t)} \\sigma_1^2(t) = \\sum_{i=1}^{t} [i-\\mu_1(t)]^2 \\frac{P(i)}{q_1(t)} \\quad \\&amp; \\quad \\sigma_2^2(t) = \\sum_{i=t+1}^{I} [i-\\mu_1(t)]^2 \\frac{P(i)}{q_2(t)} \\end{array} q1​(t)=∑i=1t​P(i)&amp;q1​(t)=∑i=t+1I​P(i)μ1​(t)=∑i=1t​q1​(t)iP(i)​&amp;μ2​(t)=∑i=t+1I​q2​(t)iP(i)​σ12​(t)=∑i=1t​[i−μ1​(t)]2q1​(t)P(i)​&amp;σ22​(t)=∑i=t+1I​[i−μ1​(t)]2q2​(t)P(i)​​ 실제로 두 개의 피크 사이에있는 t의 값을 찾음으로써 두 클래스에 대한 분산이 최소가 되도록 합니다. 다음과 같이 간단하게 파이썬으로 구현할 수 있습니다 : 1234567891011121314151617181920212223242526272829303132333435import cv2import numpy as npimg = cv2.imread(&#x27;model.jpg&#x27;, 0)blur = cv2.GaussianBlur(img, (5, 5), 0)# find normalized_histogram, and its cumulative distribution functionhist = cv2.calcHist([blur], [0], None, [256], [0, 256])hist_norm = hist.ravel() / hist.max()Q = hist_norm.cumsum()bins = np.arange(256)fn_min = np.infthresh = -1for i in range(1, 256): p1, p2 = np.hsplit(hist_norm, [i]) # probabilities q1, q2 = Q[i], Q[255] - Q[i] # cum sum of classes b1, b2 = np.hsplit(bins, [i]) # weights # finding means and variances m1, m2 = np.sum(p1 * b1) / q1, np.sum(p2 * b2) / q2 v1, v2 = np.sum(((b1 - m1) ** 2) * p1) / q1, np.sum(((b2 - m2) ** 2) * p2) / q2 # calculates the minimization function fn = v1 * q1 + v2 * q2 if fn &lt; fn_min: fn_min = fn thresh = i# find otsu&#x27;s threshold value with OpenCV functionret, otsu = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)print(thresh, ret) (일부 기능은 여기에서 새로 추가되었지만 다음 장에서 설명 할 것입니다.) 추가 리소스 디지털 이미지 프로세싱, Rafael C. Gonzalez 연습 문제 Otsu의 이진화에 사용할 수있는 최적화가 있습니다. 검색하고 구현할 수 있습니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html https://pixabay.com","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 10. 색상 공간 변경하기","slug":"2018/OpenCV-Python-Tutorials-10-색상-공간-변경하기","date":"2018-01-10T10:14:45.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-10-색상-공간-변경하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-10-%EC%83%89%EC%83%81-%EA%B3%B5%EA%B0%84-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0/","excerpt":"","text":"[OpenCV-Python Tutorials] 10. 색상 공간 변경하기 목표 이 튜토리얼에서는 BGR $$\\leftrightarrow$$ Gray, BGR $$\\leftrightarrow$$ HSV 등과 같이 한 색상 공간에서 다른 색상 공간으로 이미지를 변환하는 방법을 배웁니다. 그 외에도 비디오에서 채색 된 객체를 추출하는 응용 프로그램을 만듭니다. 다음 함수를 배울 것입니다 : cv2.cvtColor(), cv2.inRange() 등등. 색 공간 변경하기 OpenCV에는 150 가지 이상의 색 공간 변환 방법이 있습니다. 그러나 우리는 가장 널리 사용되는 두 가지를 살펴볼 것입니다. BGR $$\\leftrightarrow$$ Gray와 BGR $$\\leftrightarrow$$ HSV. 색상 변환을 위해 함수 cv2.cvtColor(input_image, flag)를 사용합니다. 여기서 flag는 변환 유형을 결정합니다. BGR $$\\rightarrow$$ 회색 변환의 경우 우리는 플래그 cv2.COLOR_BGR2GRAY를 사용합니다. 마찬가지로 BGR $$\\rightarrow$$ HSV에 대해서도 플래그 cv2.COLOR_BGR2HSV를 사용합니다. 다른 플래그를 얻으려면 Python 터미널에서 다음 명령을 실행하십시오. 1234567import cv2flags = [i for i in dir(cv2) if i.startswith(&#x27;COLOR_&#x27;)]print(flags)# 출력 : [&#x27;COLOR_BAYER_BG2BGR&#x27;, &#x27;COLOR_BAYER_BG2BGR_EA&#x27;, &#x27;COLOR_BAYER_BG2BGR_VNG&#x27;, &#x27;COLOR_BAYER_BG2GRAY&#x27;, &#x27;COLOR_BAYER_BG2RGB&#x27;, &#x27;COLOR_BAYER_BG2RGB_EA&#x27;, &#x27;COLOR_BAYER_BG2RGB_VNG&#x27;, &#x27;COLOR_BAYER_GB2BGR&#x27;, &#x27;COLOR_BAYER_GB2BGR_EA&#x27;, &#x27;COLOR_BAYER_GB2BGR_VNG&#x27;, &#x27;COLOR_BAYER_GB2GRAY&#x27;, &#x27;COLOR_BAYER_GB2RGB&#x27;, &#x27;COLOR_BAYER_GB2RGB_EA&#x27;, &#x27;COLOR_BAYER_GB2RGB_VNG&#x27;, &#x27;COLOR_BAYER_GR2BGR&#x27;, &#x27;COLOR_BAYER_GR2BGR_EA&#x27;, &#x27;COLOR_BAYER_GR2BGR_VNG&#x27;, &#x27;COLOR_BAYER_GR2GRAY&#x27;, &#x27;COLOR_BAYER_GR2RGB&#x27;, &#x27;COLOR_BAYER_GR2RGB_EA&#x27;, &#x27;COLOR_BAYER_GR2RGB_VNG&#x27;, &#x27;COLOR_BAYER_RG2BGR&#x27;, &#x27;COLOR_BAYER_RG2BGR_EA&#x27;, &#x27;COLOR_BAYER_RG2BGR_VNG&#x27;, &#x27;COLOR_BAYER_RG2GRAY&#x27;, &#x27;COLOR_BAYER_RG2RGB&#x27;, &#x27;COLOR_BAYER_RG2RGB_EA&#x27;, &#x27;COLOR_BAYER_RG2RGB_VNG&#x27;, &#x27;COLOR_BGR2BGR555&#x27;, &#x27;COLOR_BGR2BGR565&#x27;, &#x27;COLOR_BGR2BGRA&#x27;, &#x27;COLOR_BGR2GRAY&#x27;, &#x27;COLOR_BGR2HLS&#x27;, &#x27;COLOR_BGR2HLS_FULL&#x27;, &#x27;COLOR_BGR2HSV&#x27;, &#x27;COLOR_BGR2HSV_FULL&#x27;, &#x27;COLOR_BGR2LAB&#x27;, &#x27;COLOR_BGR2LUV&#x27;, &#x27;COLOR_BGR2Lab&#x27;, &#x27;COLOR_BGR2Luv&#x27;, &#x27;COLOR_BGR2RGB&#x27;, &#x27;COLOR_BGR2RGBA&#x27;, &#x27;COLOR_BGR2XYZ&#x27;, &#x27;COLOR_BGR2YCR_CB&#x27;, &#x27;COLOR_BGR2YCrCb&#x27;, &#x27;COLOR_BGR2YUV&#x27;, &#x27;COLOR_BGR2YUV_I420&#x27;, &#x27;COLOR_BGR2YUV_IYUV&#x27;, &#x27;COLOR_BGR2YUV_YV12&#x27;, &#x27;COLOR_BGR5552BGR&#x27;, &#x27;COLOR_BGR5552BGRA&#x27;, &#x27;COLOR_BGR5552GRAY&#x27;, &#x27;COLOR_BGR5552RGB&#x27;, &#x27;COLOR_BGR5552RGBA&#x27;, &#x27;COLOR_BGR5652BGR&#x27;, &#x27;COLOR_BGR5652BGRA&#x27;, &#x27;COLOR_BGR5652GRAY&#x27;, &#x27;COLOR_BGR5652RGB&#x27;, &#x27;COLOR_BGR5652RGBA&#x27;, &#x27;COLOR_BGRA2BGR&#x27;, &#x27;COLOR_BGRA2BGR555&#x27;, &#x27;COLOR_BGRA2BGR565&#x27;, &#x27;COLOR_BGRA2GRAY&#x27;, &#x27;COLOR_BGRA2RGB&#x27;, &#x27;COLOR_BGRA2RGBA&#x27;, &#x27;COLOR_BGRA2YUV_I420&#x27;, &#x27;COLOR_BGRA2YUV_IYUV&#x27;, &#x27;COLOR_BGRA2YUV_YV12&#x27;, &#x27;COLOR_BayerBG2BGR&#x27;, &#x27;COLOR_BayerBG2BGR_EA&#x27;, &#x27;COLOR_BayerBG2BGR_VNG&#x27;, &#x27;COLOR_BayerBG2GRAY&#x27;, &#x27;COLOR_BayerBG2RGB&#x27;, &#x27;COLOR_BayerBG2RGB_EA&#x27;, &#x27;COLOR_BayerBG2RGB_VNG&#x27;, &#x27;COLOR_BayerGB2BGR&#x27;, &#x27;COLOR_BayerGB2BGR_EA&#x27;, &#x27;COLOR_BayerGB2BGR_VNG&#x27;, &#x27;COLOR_BayerGB2GRAY&#x27;, &#x27;COLOR_BayerGB2RGB&#x27;, &#x27;COLOR_BayerGB2RGB_EA&#x27;, &#x27;COLOR_BayerGB2RGB_VNG&#x27;, &#x27;COLOR_BayerGR2BGR&#x27;, &#x27;COLOR_BayerGR2BGR_EA&#x27;, &#x27;COLOR_BayerGR2BGR_VNG&#x27;, &#x27;COLOR_BayerGR2GRAY&#x27;, &#x27;COLOR_BayerGR2RGB&#x27;, &#x27;COLOR_BayerGR2RGB_EA&#x27;, &#x27;COLOR_BayerGR2RGB_VNG&#x27;, &#x27;COLOR_BayerRG2BGR&#x27;, &#x27;COLOR_BayerRG2BGR_EA&#x27;, &#x27;COLOR_BayerRG2BGR_VNG&#x27;, &#x27;COLOR_BayerRG2GRAY&#x27;, &#x27;COLOR_BayerRG2RGB&#x27;, &#x27;COLOR_BayerRG2RGB_EA&#x27;, &#x27;COLOR_BayerRG2RGB_VNG&#x27;, &#x27;COLOR_COLORCVT_MAX&#x27;, &#x27;COLOR_GRAY2BGR&#x27;, &#x27;COLOR_GRAY2BGR555&#x27;, &#x27;COLOR_GRAY2BGR565&#x27;, &#x27;COLOR_GRAY2BGRA&#x27;, &#x27;COLOR_GRAY2RGB&#x27;, &#x27;COLOR_GRAY2RGBA&#x27;, &#x27;COLOR_HLS2BGR&#x27;, &#x27;COLOR_HLS2BGR_FULL&#x27;, &#x27;COLOR_HLS2RGB&#x27;, &#x27;COLOR_HLS2RGB_FULL&#x27;, &#x27;COLOR_HSV2BGR&#x27;, &#x27;COLOR_HSV2BGR_FULL&#x27;, &#x27;COLOR_HSV2RGB&#x27;, &#x27;COLOR_HSV2RGB_FULL&#x27;, &#x27;COLOR_LAB2BGR&#x27;, &#x27;COLOR_LAB2LBGR&#x27;, &#x27;COLOR_LAB2LRGB&#x27;, &#x27;COLOR_LAB2RGB&#x27;, &#x27;COLOR_LBGR2LAB&#x27;, &#x27;COLOR_LBGR2LUV&#x27;, &#x27;COLOR_LBGR2Lab&#x27;, &#x27;COLOR_LBGR2Luv&#x27;, &#x27;COLOR_LRGB2LAB&#x27;, &#x27;COLOR_LRGB2LUV&#x27;, &#x27;COLOR_LRGB2Lab&#x27;, &#x27;COLOR_LRGB2Luv&#x27;, &#x27;COLOR_LUV2BGR&#x27;, &#x27;COLOR_LUV2LBGR&#x27;, &#x27;COLOR_LUV2LRGB&#x27;, &#x27;COLOR_LUV2RGB&#x27;, &#x27;COLOR_Lab2BGR&#x27;, &#x27;COLOR_Lab2LBGR&#x27;, &#x27;COLOR_Lab2LRGB&#x27;, &#x27;COLOR_Lab2RGB&#x27;, &#x27;COLOR_Luv2BGR&#x27;, &#x27;COLOR_Luv2LBGR&#x27;, &#x27;COLOR_Luv2LRGB&#x27;, &#x27;COLOR_Luv2RGB&#x27;, &#x27;COLOR_M_RGBA2RGBA&#x27;, &#x27;COLOR_RGB2BGR&#x27;, &#x27;COLOR_RGB2BGR555&#x27;, &#x27;COLOR_RGB2BGR565&#x27;, &#x27;COLOR_RGB2BGRA&#x27;, &#x27;COLOR_RGB2GRAY&#x27;, &#x27;COLOR_RGB2HLS&#x27;, &#x27;COLOR_RGB2HLS_FULL&#x27;, &#x27;COLOR_RGB2HSV&#x27;, &#x27;COLOR_RGB2HSV_FULL&#x27;, &#x27;COLOR_RGB2LAB&#x27;, &#x27;COLOR_RGB2LUV&#x27;, &#x27;COLOR_RGB2Lab&#x27;, &#x27;COLOR_RGB2Luv&#x27;, &#x27;COLOR_RGB2RGBA&#x27;, &#x27;COLOR_RGB2XYZ&#x27;, &#x27;COLOR_RGB2YCR_CB&#x27;, &#x27;COLOR_RGB2YCrCb&#x27;, &#x27;COLOR_RGB2YUV&#x27;, &#x27;COLOR_RGB2YUV_I420&#x27;, &#x27;COLOR_RGB2YUV_IYUV&#x27;, &#x27;COLOR_RGB2YUV_YV12&#x27;, &#x27;COLOR_RGBA2BGR&#x27;, &#x27;COLOR_RGBA2BGR555&#x27;, &#x27;COLOR_RGBA2BGR565&#x27;, &#x27;COLOR_RGBA2BGRA&#x27;, &#x27;COLOR_RGBA2GRAY&#x27;, &#x27;COLOR_RGBA2M_RGBA&#x27;, &#x27;COLOR_RGBA2RGB&#x27;, &#x27;COLOR_RGBA2YUV_I420&#x27;, &#x27;COLOR_RGBA2YUV_IYUV&#x27;, &#x27;COLOR_RGBA2YUV_YV12&#x27;, &#x27;COLOR_RGBA2mRGBA&#x27;, &#x27;COLOR_XYZ2BGR&#x27;, &#x27;COLOR_XYZ2RGB&#x27;, &#x27;COLOR_YCR_CB2BGR&#x27;, &#x27;COLOR_YCR_CB2RGB&#x27;, &#x27;COLOR_YCrCb2BGR&#x27;, &#x27;COLOR_YCrCb2RGB&#x27;, &#x27;COLOR_YUV2BGR&#x27;, &#x27;COLOR_YUV2BGRA_I420&#x27;, &#x27;COLOR_YUV2BGRA_IYUV&#x27;, &#x27;COLOR_YUV2BGRA_NV12&#x27;, &#x27;COLOR_YUV2BGRA_NV21&#x27;, &#x27;COLOR_YUV2BGRA_UYNV&#x27;, &#x27;COLOR_YUV2BGRA_UYVY&#x27;, &#x27;COLOR_YUV2BGRA_Y422&#x27;, &#x27;COLOR_YUV2BGRA_YUNV&#x27;, &#x27;COLOR_YUV2BGRA_YUY2&#x27;, &#x27;COLOR_YUV2BGRA_YUYV&#x27;, &#x27;COLOR_YUV2BGRA_YV12&#x27;, &#x27;COLOR_YUV2BGRA_YVYU&#x27;, &#x27;COLOR_YUV2BGR_I420&#x27;, &#x27;COLOR_YUV2BGR_IYUV&#x27;, &#x27;COLOR_YUV2BGR_NV12&#x27;, &#x27;COLOR_YUV2BGR_NV21&#x27;, &#x27;COLOR_YUV2BGR_UYNV&#x27;, &#x27;COLOR_YUV2BGR_UYVY&#x27;, &#x27;COLOR_YUV2BGR_Y422&#x27;, &#x27;COLOR_YUV2BGR_YUNV&#x27;, &#x27;COLOR_YUV2BGR_YUY2&#x27;, &#x27;COLOR_YUV2BGR_YUYV&#x27;, &#x27;COLOR_YUV2BGR_YV12&#x27;, &#x27;COLOR_YUV2BGR_YVYU&#x27;, &#x27;COLOR_YUV2GRAY_420&#x27;, &#x27;COLOR_YUV2GRAY_I420&#x27;, &#x27;COLOR_YUV2GRAY_IYUV&#x27;, &#x27;COLOR_YUV2GRAY_NV12&#x27;, &#x27;COLOR_YUV2GRAY_NV21&#x27;, &#x27;COLOR_YUV2GRAY_UYNV&#x27;, &#x27;COLOR_YUV2GRAY_UYVY&#x27;, &#x27;COLOR_YUV2GRAY_Y422&#x27;, &#x27;COLOR_YUV2GRAY_YUNV&#x27;, &#x27;COLOR_YUV2GRAY_YUY2&#x27;, &#x27;COLOR_YUV2GRAY_YUYV&#x27;, &#x27;COLOR_YUV2GRAY_YV12&#x27;, &#x27;COLOR_YUV2GRAY_YVYU&#x27;, &#x27;COLOR_YUV2RGB&#x27;, &#x27;COLOR_YUV2RGBA_I420&#x27;, &#x27;COLOR_YUV2RGBA_IYUV&#x27;, &#x27;COLOR_YUV2RGBA_NV12&#x27;, &#x27;COLOR_YUV2RGBA_NV21&#x27;, &#x27;COLOR_YUV2RGBA_UYNV&#x27;, &#x27;COLOR_YUV2RGBA_UYVY&#x27;, &#x27;COLOR_YUV2RGBA_Y422&#x27;, &#x27;COLOR_YUV2RGBA_YUNV&#x27;, &#x27;COLOR_YUV2RGBA_YUY2&#x27;, &#x27;COLOR_YUV2RGBA_YUYV&#x27;, &#x27;COLOR_YUV2RGBA_YV12&#x27;, &#x27;COLOR_YUV2RGBA_YVYU&#x27;, &#x27;COLOR_YUV2RGB_I420&#x27;, &#x27;COLOR_YUV2RGB_IYUV&#x27;, &#x27;COLOR_YUV2RGB_NV12&#x27;, &#x27;COLOR_YUV2RGB_NV21&#x27;, &#x27;COLOR_YUV2RGB_UYNV&#x27;, &#x27;COLOR_YUV2RGB_UYVY&#x27;, &#x27;COLOR_YUV2RGB_Y422&#x27;, &#x27;COLOR_YUV2RGB_YUNV&#x27;, &#x27;COLOR_YUV2RGB_YUY2&#x27;, &#x27;COLOR_YUV2RGB_YUYV&#x27;, &#x27;COLOR_YUV2RGB_YV12&#x27;, &#x27;COLOR_YUV2RGB_YVYU&#x27;, &#x27;COLOR_YUV420P2BGR&#x27;, &#x27;COLOR_YUV420P2BGRA&#x27;, &#x27;COLOR_YUV420P2GRAY&#x27;, &#x27;COLOR_YUV420P2RGB&#x27;, &#x27;COLOR_YUV420P2RGBA&#x27;, &#x27;COLOR_YUV420SP2BGR&#x27;, &#x27;COLOR_YUV420SP2BGRA&#x27;, &#x27;COLOR_YUV420SP2GRAY&#x27;, &#x27;COLOR_YUV420SP2RGB&#x27;, &#x27;COLOR_YUV420SP2RGBA&#x27;, &#x27;COLOR_YUV420p2BGR&#x27;, &#x27;COLOR_YUV420p2BGRA&#x27;, &#x27;COLOR_YUV420p2GRAY&#x27;, &#x27;COLOR_YUV420p2RGB&#x27;, &#x27;COLOR_YUV420p2RGBA&#x27;, &#x27;COLOR_YUV420sp2BGR&#x27;, &#x27;COLOR_YUV420sp2BGRA&#x27;, &#x27;COLOR_YUV420sp2GRAY&#x27;, &#x27;COLOR_YUV420sp2RGB&#x27;, &#x27;COLOR_YUV420sp2RGBA&#x27;, &#x27;COLOR_mRGBA2RGBA&#x27;] HSV의 경우 색조 범위는 [0,179], 채도 범위는 [0,255], 값 범위는 [0,255]입니다. 서로 다른 소프트웨어는 서로 다른 가늠자를 사용합니다. 따라서 OpenCV 값을 비교하는 경우이 범위를 정규화 해야 합니다. 객체 추적 이제 우리는 BGR 이미지를 HSV로 변환하는 방법을 알고 있습니다. 이 도구를 사용하여 색상이 지정된 객체를 추출 할 수 있습니다. HSV에서는 RGB 색상 공간보다 색상을 표현하는 것이 더 쉽습니다. 우리의 응용 프로그램에서 우리는 파란색 객체를 추출하려고합니다. 그래서 여기에 방법이 있습니다 : 비디오의 각 프레임 가져 오기 BGR에서 HSV 색 공간으로 변환 우리는 파란색 범위의 HSV 이미지를 임계값으로 설정합니다. 이제 파란색 물체 만 추출하면 우리가 원하는 이미지를 만들 수 있습니다. 아래 코드에 자세히 설명되어 있습니다 : 123456789101112131415161718192021222324252627282930313233import cv2import numpy as npfile = &#x27;blue_light.mp4&#x27;cap = cv2.VideoCapture(file)while True: # Take each frame _, frame = cap.read() # Convert BGR to HSV hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) # define range of blue color in HSV lower_blue = np.array([110, 50, 50]) upper_blue = np.array([130, 255, 255]) # Threshold the HSV image to get only blue colors mask = cv2.inRange(hsv, lower_blue, upper_blue) # Bitwise-AND mask and original image res = cv2.bitwise_and(frame, frame, mask=mask) cv2.imshow(&#x27;frame&#x27;, frame) cv2.imshow(&#x27;mask&#x27;, mask) cv2.imshow(&#x27;res&#x27;, res) k = cv2.waitKey(5) &amp; 0xFF if k == 27: breakcv2.destroyAllWindows() 아래 이미지는 파란색 물체의 추적을 보여줍니다. 이미지에 약간의 노이즈가 있습니다. 나중 챕터에서 제거하는 방법을 살펴볼 것입니다. 이것은 객체 추적에서 가장 간단한 방법입니다. 윤곽선의 기능을 익히면이 물체의 중심을 찾아 객체를 추적하는 데 사용할 수 있고 카메라 앞에 손을 움직여 다이어그램을 그릴 수 있습니다. 추적 할 HSV 값은 어떻게 찾을까요? 이것은 stackoverflow.com 에 있는 일반적인 질문입니다. 그것은 매우 간단하며 동일한 함수, cv2.cvtColor()를 사용할 수 있습니다. 이미지를 전달하는 대신 원하는 BGR 값을 전달하면 됩니다. 예를 들어, Green의 HSV 값을 찾으려면 Python 터미널에서 다음 명령을 시도하십시오. 12345678import cv2import numpy as npgreen = np.uint8([[[0, 255, 0]]])hsv_green = cv2.cvtColor(green, cv2.COLOR_BGR2HSV)print(hsv_green)# 출력 : [[[ 60 255 255]]] 이제 [H-10, 100,100]과 [H + 10, 255, 255]를 하한선과 상한선으로 취합니다. 이 방법 외에도 GIMP 또는 온라인 변환기와 같은 이미지 편집 도구를 사용하여 이러한 값을 찾을 수 있지만 HSV 범위를 조정하는 것을 잊지 마십시오. 연습 문제 예를 들어 적색, 청색, 녹색 물체를 동시에 추출하기 위해 하나 이상의 색상이 있는 물체를 추출하는 방법을 찾으십시오. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 09 성능 측정 및 개선 기법","slug":"2018/OpenCV-Python-Tutorials-09-성능-측정-및-개선-기법","date":"2018-01-09T10:14:25.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-09-성능-측정-및-개선-기법/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-09-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95-%EB%B0%8F-%EA%B0%9C%EC%84%A0-%EA%B8%B0%EB%B2%95/","excerpt":"","text":"[OpenCV-Python Tutorials] 09 성능 측정 및 개선 기법 목표 이미지 처리에서는 초당 많은 작업을 처리하기 때문에 코드가 올바른 솔루션을 제공 할 뿐만 아니라 가장 빠른 방식으로 제공되어야 합니다. 따라서 이 장에서는 다음과 같은 내용을 배울 수 있습니다. 코드의 성능을 측정합니다. 코드의 성능을 향상시키기 위한 몇 가지 팁. cv2.getTickCount, cv2.getTickFrequency 등의 함수를 확인합니다. OpenCV 외에도 Python은 실행 시간을 측정하는 데 유용한 모듈 시간을 제공합니다. 다른 모듈 프로파일은 코드의 각 함수가 얼마나 많은 시간을 사용하는지, 얼마나 많은 시간이 함수가 호출되었는지 등과 같은 코드에 대한 자세한 보고서를 얻는 데 도움이 됩니다. IPython을 사용하는 경우 이러한 모든 기능이 사용자 친화적 방법으로 포함되어 있습니다. 우리는 몇 가지 중요한 것들을 보게 될 것이며, 자세한 내용은 Additional Resouces 섹션의 링크를 확인하십시오. OpenCV로 성능 측정 cv2.getTickCount 함수는 이 함수가 호출되는 순간까지 참조 이벤트 (순간 기계가 켜졌을 때처럼) 이후의 클럭 사이클 수를 반환합니다. 따라서 함수를 실행하기 전후에 함수를 호출하면 함수를 실행하는데 사용되는 클럭 사이클 수를 얻게 됩니다. cv2.getTickFrequency 함수는 클럭 사이클의 빈도 또는 초당 클럭 사이클 수를 반환합니다. 따라서 실행 시간을 초 단위로 확인하려면 다음을 수행 할 수 있습니다. 1234e1 = cv2.getTickCount()# your code executione2 = cv2.getTickCount()time = (e2 - e1)/ cv2.getTickFrequency() 우리는 다음 예제를 통해 설명 할 것입니다. 다음 예제는 5부터 49까지의 홀수 크기의 커널을 사용하여 중간 필터링을 적용합니다. (결과가 어떻게 보이는지 걱정하지 마십시오. 이것은 우리의 목표가 아닙니다.) 12345678910111213141516171819import cv2img1 = cv2.imread(&#x27;model.jpg&#x27;)e1 = cv2.getTickCount()for i in range(5, 49, 2): img2 = cv2.medianBlur(img1, i)e2 = cv2.getTickCount()t = (e2 - e1) / cv2.getTickFrequency()cv2.imshow(&#x27;Original&#x27;, img1)cv2.imshow(&#x27;Blur&#x27;, img2)cv2.waitKey(0)cv2.destroyAllWindows()print(t)# 결과: 2.5564403101561437 당신은 time 모듈을 사용할 수도 있습니다. cv2.getTickCount 대신 time.time() 함수를 사용하십시오. 그런 다음 두 시각의 차이를 사용하면 됩니다. OpenCV의 기본 최적화 많은 OpenCV 기능은 SSE2, AVX 등을 사용하여 최적화됩니다. 최적화되지 않은 코드도 포함되어 있습니다. 따라서 우리 시스템이 이러한 기능을 지원한다면, 우리는 이를 이용해야합니다 (거의 모든 현대 프로세서가 이를 지원합니다). 컴파일하는 동안 기본적으로 활성화됩니다. 따라서 OpenCV는 최적화 된 코드를 실행하면 활성화되고 그렇지 않으면 최적화되지 않은 코드가 실행됩니다. cv2.useOptimized()를 사용하여 활성화 / 비활성화되어 있는지 확인하고 cv2.setUseOptimized()를 사용하여 활성화 / 비활성화 할 수 있습니다. 간단한 예를 봅시다. 123456789101112131415# check if optimization is enabledIn [5]: cv2.useOptimized()Out[5]: TrueIn [6]: %timeit res = cv2.medianBlur(img,49)10 loops, best of 3: 34.9 ms per loop# Disable itIn [7]: cv2.setUseOptimized(False)In [8]: cv2.useOptimized()Out[8]: FalseIn [9]: %timeit res = cv2.medianBlur(img,49)10 loops, best of 3: 64.1 ms per loop 최적화 된 중앙 필터링은 최적화되지 않은 버전보다 ~2 배 빠릅니다. 소스를 확인하면 중간 필터링이 SIMD에 최적화 된 것을 볼 수 있습니다. 따라서 이것을 사용하여 코드 상단에서 최적화를 활성화 할 수 있습니다 (기본적으로 활성화되어 있음을 기억하십시오). IPython에서 성능 측정 때로는 두 가지 유사한 작업의 성능을 비교해야 할 수도 있습니다. IPython은 이것을 수행하는 마법 명령 %timeit 제공합니다. 더 정확한 결과를 얻기 위해 코드를 여러 번 실행합니다. 다시 한번 말하지만, 단일 라인 코드를 측정하는 데 적합합니다. 예를 들어, 다음 중 더 나은 연산이 어떤것인지 알 수 있습니까? x = 5; y = x ** 2 x = 5; y = x * x x = np.uint8([5]); y = x * x 또는 y = np.square(x)? 우리는 IPython 셸에서 %timeit을 사용하여 찾아보겠습니다. 123456789101112131415In [10]: x = 5In [11]: %timeit y=x**210000000 loops, best of 3: 73 ns per loopIn [12]: %timeit y=x*x10000000 loops, best of 3: 58.3 ns per loopIn [15]: z = np.uint8([5])In [17]: %timeit y=z*z1000000 loops, best of 3: 1.25 us per loopIn [19]: %timeit y=np.square(z)1000000 loops, best of 3: 1.16 us per loop x = 5; y = x * x는 가장 빠르며 Numpy에 비해 20 배 정도 빠른 것을 확인할 수 있습니다. 배열 생성도 고려한다면 최대 100 배까지 빨라질 수 있습니다. 멋지지 않습니까? (Numpy devs는이 문제를 해결하기 위해 노력하고 있습니다) 파이썬 스칼라 연산은 Numpy 스칼라 연산보다 빠릅니다. 따라서 하나 또는 두 개의 요소를 포함하는 연산의 경우 Python 스칼라가 Numpy 배열보다 낫습니다. Numpy는 배열의 크기가 조금 더 클 때 이점을 취합니다. 우리는 한 가지 더 많은 예제를 시도 할 것입니다. 이번에는 동일한 이미지에 대해 cv2.countNonZero() 및 np.count_nonzero()의 성능을 비교합니다. 12345In [35]: %timeit z = cv2.countNonZero(img)100000 loops, best of 3: 15.8 us per loopIn [36]: %timeit z = np.count_nonzero(img)1000 loops, best of 3: 370 us per loop OpenCV 기능이 Numpy 기능보다 25배 빠릅니다. 일반적으로 OpenCV 기능은 Numpy 기능보다 빠릅니다. 따라서 동일한 작업을 위해 OpenCV 기능이 선호됩니다. 그러나 예외가 있을 수 있습니다. 특히 Numpy가 사본 대신 보기를 사용할 때 그렇습니다. 더 많은 IPython 마법 명령 성능, 프로파일링, 라인 프로파일링, 메모리 측정 등을 측정하는 몇 가지 다른 마법 명령이 있습니다. 그것들 모두 잘 문서화되어 있습니다. 따라서 해당 문서에 대한 링크만 제공됩니다. 관심있는 독자는 링크를 확인하시기 바랍니다. 성능 최적화 기법 Python과 Numpy의 최대 성능을 활용하기 위한 몇 가지 기술과 코딩 방법이 있습니다. 관련된 것만이 여기에 표시되며 링크는 중요한 출처에 제공됩니다. 여기서 주목해야 할 점은 먼저 알고리즘을 간단한 방식으로 구현하려고 시도한다는 것입니다. 일단 작동되면 프로파일링하고 병목 현상을 찾아 최적화하십시오. Python에서 가능한 한 루프를 사용하지 마십시오. 특히 이중 / 삼중 루프 등은 본질적으로 느립니다. Numpy와 OpenCV가 벡터 연산에 최적화되어 있기 때문에 알고리즘 / 코드를 가능한 최대로 벡터화하십시오. 캐시 일관성을 이용하십시오. 필요하지 않으면 배열의 복사본을 만들지 마십시오. 대신 보기를 사용해보십시오. 배열 복사는 비용이 많이 드는 작업입니다. 이러한 모든 작업을 수행 한 후에도 코드가 여전히 느리거나 큰 루프를 사용해야하는 경우에는 Cython과 같은 추가 라이브러리를 사용하여 더 빨리 수행 할 수 있습니다. 추가 리소스 파이썬 최적화 기법 Scipy 강의 노트 - 고급 Numpy IPython의 타이밍 및 프로파일링 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_optimization/py_optimization.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials 06] 색상표 트랙바 사용하기","slug":"2018/OpenCV-Python-Tutorials-06-색상표-트랙바-사용하기","date":"2018-01-06T10:12:16.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-06-색상표-트랙바-사용하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-06-%EC%83%89%EC%83%81%ED%91%9C-%ED%8A%B8%EB%9E%99%EB%B0%94-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/","excerpt":"","text":"[OpenCV-Python Tutorials 06] 색상표 트랙바 사용하기 목표 트랙바를 OpenCV 창에 바인딩하는 방법 배우기 cv2.getTrackbarPos(), cv2.createTrackbar() 등의 함수를 배웁니다. 코드 데모 여기에서는 지정한 색상을 보여주는 간단한 응용 프로그램을 만듭니다. B, G, R 각 색상을 지정하는 색상과 세 개의 트랙바를 보여주는 창이 있습니다. 트랙바를 슬라이드하고 그에 따라 창 색상이 변경됩니다. 기본적으로 초기 색은 검은색으로 설정됩니다. cv2.getTrackbarPos() 함수의 경우 첫 번째 인수는 트랙바 이름이고, 두 번째 인수는 연결될 창 이름이며 세 번째 인수는 기본값이며 네 번째 매개 변수는 최대값이며 다섯 번째 매개 변수는 실행되는 콜백 함수입니다 트랙볼 값이 매번 변경됩니다. 콜백 함수에는 항상 트랙바 위치인 기본 인수가 있습니다. 우리의 경우 함수는 아무 것도하지 않으므로 간단히 패스합니다. 파라미터 목록 트랙바 이름 연결될 창 이름 기본값 최대값 콜백 함수 트랙바의 또 다른 중요한 응용 프로그램은 단추 또는 스위치로 사용하는 것입니다. OpenCV는 기본적으로 버튼 기능이 없습니다. 따라서 트랙바를 사용하여 이러한 기능을 사용할 수 있습니다. 우리의 응용 프로그램에서는 스위치가 ON 인 경우에만 응용 프로그램이 작동하는 스위치 하나를 만들었습니다. 그렇지 않으면 화면이 항상 검은색입니다. 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npdef nothing(x): pass# Create a black image, a windowimg = np.zeros((300,512,3), np.uint8)cv2.namedWindow(&#x27;image&#x27;)# create trackbars for color changecv2.createTrackbar(&#x27;R&#x27;,&#x27;image&#x27;,0,255,nothing)cv2.createTrackbar(&#x27;G&#x27;,&#x27;image&#x27;,0,255,nothing)cv2.createTrackbar(&#x27;B&#x27;,&#x27;image&#x27;,0,255,nothing)# create switch for ON/OFF functionalityswitch = &#x27;0 : OFF \\n1 : ON&#x27;cv2.createTrackbar(switch, &#x27;image&#x27;,0,1,nothing)while(1): cv2.imshow(&#x27;image&#x27;,img) k = cv2.waitKey(1) &amp; 0xFF if k == 27: break # get current positions of four trackbars r = cv2.getTrackbarPos(&#x27;R&#x27;,&#x27;image&#x27;) g = cv2.getTrackbarPos(&#x27;G&#x27;,&#x27;image&#x27;) b = cv2.getTrackbarPos(&#x27;B&#x27;,&#x27;image&#x27;) s = cv2.getTrackbarPos(switch,&#x27;image&#x27;) if s == 0: img[:] = 0 else: img[:] = [b,g,r]cv2.destroyAllWindows() 애플리케이션의 스크린 샷은 다음과 같습니다. ESC 키를 눌러서 윈도우를 종료합니다. 연습 문제 트랙 바를 사용하여 색상 및 브러쉬 반경을 조정할 수있는 페인트 응용 프로그램을 만듭니다. 그리기에 대해서는 마우스 조작에 대한 이전 자습서를 참조하십시오. 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npdef nothing(x): pass# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: # get current positions of four trackbars r = cv2.getTrackbarPos(&#x27;R&#x27;, &#x27;image&#x27;) g = cv2.getTrackbarPos(&#x27;G&#x27;, &#x27;image&#x27;) b = cv2.getTrackbarPos(&#x27;B&#x27;, &#x27;image&#x27;) d = cv2.getTrackbarPos(&#x27;Distance&#x27;, &#x27;image&#x27;) cv2.circle(img, (x, y), d, (b, g, r), -1)# Create a black image, a windowimg = np.zeros((300,512,3), np.uint8)cv2.namedWindow(&#x27;image&#x27;)# create trackbars for color changecv2.createTrackbar(&#x27;R&#x27;,&#x27;image&#x27;,0,255, nothing)cv2.createTrackbar(&#x27;G&#x27;,&#x27;image&#x27;,0,255, nothing)cv2.createTrackbar(&#x27;B&#x27;,&#x27;image&#x27;,0,255, nothing)cv2.createTrackbar(&#x27;Distance&#x27;,&#x27;image&#x27;,0,255, nothing)cv2.setMouseCallback(&#x27;image&#x27;, draw_circle)while(1): cv2.imshow(&#x27;image&#x27;,img) k = cv2.waitKey(1) &amp; 0xFF if k == 27: breakcv2.destroyAllWindows() 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_trackbar/py_trackbar.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials] 08 이미지의 산술 연산","slug":"2018/OpenCV-Python-Tutorials-08-이미지의-산술-연산","date":"2018-01-05T10:12:55.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-08-이미지의-산술-연산/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-08-%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%9D%98-%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0/","excerpt":"","text":"[OpenCV-Python Tutorials] 08 이미지의 산술 연산 목표 더하기, 빼기, 비트 연산 등과 같은 이미지에 대한 여러 가지 산술 연산에 대해 배웁니다. cv2.add(), cv2.addWeighted() 등의 함수를 배우게 됩니다. 이미지 추가 OpenCV 함수 cv2.add() 또는 단순히 numpy 연산인 res = img1 + img2로 두 개의 이미지를 추가 할 수 있습니다. 두 이미지는 모두 같은 깊이와 유형이어야 하며 두 번째 이미지는 스칼라 값일 수 있습니다. OpenCV 추가와 Numpy 추가에는 차이가 있습니다. OpenCV 추가는 포화된 작업이며 Numpy 추가는 모듈러스 연산입니다. 예를 들어, 다음 샘플을 확인하십시오. 12345678&gt;&gt;&gt; x = np.uint8([250])&gt;&gt;&gt; y = np.uint8([10])&gt;&gt;&gt; print cv2.add(x,y) # 250+10 = 260 =&gt; 255[[255]]&gt;&gt;&gt; print x+y # 250+10 = 260 % 256 = 4[4] 두 개의 이미지를 추가하면 더 잘 보입니다. OpenCV 기능이 더 나은 결과를 제공합니다. 항상 OpenCV 기능을 더 잘 사용하십시오. 코드 12345678import cv2import numpy as npx = np.uint8([250])y = np.uint8([10])print(cv2.add(x, y)) # 250+10 = 260 =&gt; 255print(x + y) # 250+10 = 260 % 256 = 4 이미지 블렌딩 이것은 이미지 추가이지만 이미지에 다른 가중치가 주어지기 때문에 블렌딩이나 투명성을 부여합니다. 이미지는 아래의 방정식에 따라 추가됩니다. g(x)=(1−α)f0(x)+αf1(x)g(x) = (1-\\alpha)f_0(x) + \\alpha f_1(x) g(x)=(1−α)f0​(x)+αf1​(x) \\alpha$$ 값을 0에서 1로 변경하면서 이미지간에 멋진 전환을 수행 할 수 있습니다. 섞기 위해 두 개의 이미지를 사용했습니다. 첫 번째 이미지에는 0.7의 가중치가 부여되고 두 번째 이미지에는 0.3이 주어집니다. `cv2.addWeighted()`는 이미지에 다음 방정식을 적용합니다. dst = \\alpha \\cdot img1 + \\beta \\cdot img2 + \\gamma 여기서 $$\\gamma$$는 0으로 간주됩니다. 12345678910import cv2img1 = cv2.imread(&#x27;resize_model1.jpg&#x27;)img2 = cv2.imread(&#x27;resize_model2.jpg&#x27;)dst = cv2.addWeighted(img1, 0.7, img2, 0.3, 0)cv2.imshow(&#x27;dst&#x27;, dst)cv2.waitKey(0)cv2.destroyAllWindows() 아래의 결과를 확인하십시오: ![](https://goo.gl/DWRX2h) &gt; 두 이미지의 사이즈가 동일해야 합니다. ## 비트 연산 여기에는 비트 AND, OR, NOT 및 XOR 연산이 포함됩니다. 그들은 직사각형이 아닌 ROI 등을 정의하고 작업하면서 이미지의 어떤 부분을 추출하는 동안 매우 유용 할 것입니다 (아래 장에서 보게 될 것입니다). 아래에서는 이미지의 특정 영역을 변경하는 방법에 대한 예제를 보도록 하겠습니다. OpenCV 로고를 이미지 위에 올려 놓고 싶습니다. 두 개의 이미지를 추가하면 색이 바뀝니다. 그것을 섞으면 투명한 효과를 얻습니다. 그러나 나는 그것을 불투명하게 하고 싶다. 직사각형 영역이라면 마지막 장에서했던 것처럼 ROI를 사용할 수 있습니다. 그러나 OpenCV 로고는 직사각형이 아닙니다. 그래서 아래와 같이 bitwise 연산으로 할 수 있습니다: 12345678910111213141516171819202122232425262728293031import cv2img1 = cv2.imread(&#x27;resize_model1.jpg&#x27;)img2 = cv2.imread(&#x27;opencv-logo-white.png&#x27;)# I want to put logo on top-left corner, So I create a ROIrows, cols, channels = img2.shapeprint(rows, cols, channels) # 222 180 3roi = img1[0:rows, 0:cols]# Now create a mask of logo and create its inverse mask alsoimg2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY)mask_inv = cv2.bitwise_not(mask)# Now black-out the area of logo in ROIimg1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv)# Take only region of logo from logo image.img2_fg = cv2.bitwise_and(img2, img2, mask=mask)# Put logo in ROI and modify the main imagedst = cv2.add(img1_bg, img2_fg)img1[0:rows, 0:cols] = dstcv2.imshow(&#x27;bg&#x27;, img1)cv2.imshow(&#x27;res&#x27;, img1)cv2.imshow(&#x27;res&#x27;, img1)cv2.waitKey(0)cv2.destroyAllWindows() 아래 결과를 보십시오. 왼쪽 이미지는 우리가 만든 마스크를 보여줍니다. 오른쪽 이미지는 최종 결과를 보여줍니다. 이해를 돕기 위해 위의 코드에서 모든 중간 이미지, 특히 `img1_bg` 및 `img2_fg`를 표시하십시오. ![img1_bg](https://goo.gl/YnKTiM) ![img2_fg](https://goo.gl/UiWZCy) ![비트연산](https://goo.gl/qbchHu) ## 연습 문제 `cv2.addWeighted` 함수를 사용하여 폴더에 있는 이미지간에 부드러운 전환이 슬라이드 쇼 만들기 ## 출처 - https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_image_arithmetics/py_image_arithmetics.html &lt;script src=&quot;https://gist.github.com/jacegem/60ce233cf6adaa7a385233e1f164ed13.js&quot;&gt;&lt;/script&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials 07] 이미지에 대한 기본 작업","slug":"2018/OpenCV-Python-Tutorials-07-이미지에-대한-기본-작업","date":"2018-01-05T10:12:36.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-07-이미지에-대한-기본-작업/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-07-%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B8%B0%EB%B3%B8-%EC%9E%91%EC%97%85/","excerpt":"","text":"[OpenCV-Python Tutorials 07] 이미지에 대한 기본 작업 모든 파일은 Github에서 확인 할 수 있습니다. 목표 배울 내용: 픽셀 값에 액세스 및 수정 이미지 속성에 액세스 이미지 영역 설정 (ROI: Region of Image) 이미지 분할 및 병합 이 섹션의 거의 모든 작업은 주로 OpenCV보다는 Numpy와 관련이 있습니다. OpenCV로 더 최적화 된 코드를 작성하기 위해서는 Numpy에 대한 좋은 지식이 필요합니다. (예제는 단일 라인 코드이기 때문에 Python 터미널에 표시되는 내용입니다.) 픽셀 값 액세스 및 수정 먼저 컬러 이미지를 로드 해 봅시다. 1234&gt;&gt;&gt; import cv2&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; img = cv2.imread(&#x27;messi5.jpg&#x27;) 행 및 열 좌표로 픽셀 값에 액세스 할 수 있습니다. BGR 이미지의 경우 Blue, Green, Red 값의 배열을 반환합니다. 회색 음영 이미지의 경우 해당 강도 만 반환됩니다. 12345678&gt;&gt;&gt; px = img[100,100]&gt;&gt;&gt; print px[178 197 205]# accessing only blue pixel&gt;&gt;&gt; blue = img[100,100,0]&gt;&gt;&gt; print blue178 img[100,100,0] 에서 배열 3번째 값이 0이므로 blue 입니다. BGR 이므로 아래와 같습니다. 0: Blue 1: Green R: Red 같은 방법으로 픽셀값을 수정할 수 있습니다. 123&gt;&gt;&gt; img[100,100] = [255,255,255]&gt;&gt;&gt; print img[100,100][255 255 255] 전체 코드는 다음과 같습니다. 1234567891011121314import cv2import numpy as npimage_file = &#x27;ball_image.jpg&#x27;img = cv2.imread(image_file)px = img[100, 100]print(px)blue = img[100,100,0]print(blue)img[100,100] = [255,255,255]print(img[100,100]) Numpy는 빠른 배열 계산을 위해 최적화된 라이브러리입니다. 따라서 각 픽셀 값에 액세스하고 수정하는 것은 매우 느릴 것이며 권장하지 않습니다. 위에서 언급 한 방법은 일반적으로 배열 영역을 선택하는 데 사용됩니다. 예를 들어 처음 5 행과 마지막 3 열을 말합니다. 개별 픽셀에 액세스하는 경우 Numpy 배열 메서드인 array.item() 및 array.itemset()을 사용하는 것이 더 좋습니다. 하지만 항상 스칼라를 반환합니다. 따라서 모든 B, G, R 값에 액세스하려면 array.item()을 개별적으로 호출해야합니다. 더 나은 픽셀 액세스 및 편집 방법 : 12345678# accessing RED value&gt;&gt;&gt; img.item(10,10,2)59# modifying RED value&gt;&gt;&gt; img.itemset((10,10,2),100)&gt;&gt;&gt; img.item(10,10,2)100 이미지 속성에 액세스하기 이미지 속성에는 행 수, 열 및 채널, 이미지 데이터 유형, 픽셀 수 등이 포함됩니다. 이미지의 모양은 img.shape에 의해 액세스됩니다. 행, 열 및 채널 수의 튜플을 반환합니다 (이미지가 색상인 경우). 12&gt;&gt;&gt; print img.shape(342, 548, 3) 이미지가 회색조인 경우 반환되는 튜플에는 행과 열만 포함됩니다. 따라서 로드 된 이미지가 회색조 또는 컬러 이미지인지 확인하는 좋은 방법입니다. img.size는 총 픽셀 수에 액세스합니다. 12&gt;&gt;&gt; print img.size562248 이미지 데이터 유형은 img.dtype를 통해서 얻을 수 있습니다. 12&gt;&gt;&gt; print img.dtypeuint8 OpenCV-Python 코드에서 많은 수의 오류가 잘못된 데이터 유형으로 인해 발생하기 때문에 img.dtype은 디버깅하는 동안 매우 중요합니다. 터미널이 아닌 소스파일로 작성한 전체 코드는 다음과 같습니다. 123456789import cv2import numpy as npimage_file = &#x27;ball_image.jpg&#x27;img = cv2.imread(image_file)print(&quot;shape:&quot; + str(img.shape))print(&quot;size:&quot; + str(img.size))print(&quot;dtype:&quot; + str(img.dtype)) 결과 123shape:(205, 246, 3)size:151290dtype:uint8 이미지 ROI 때로는 이미지의 특정 영역을 가지고 작업을 해야 합니다. 이미지에서 눈을 검색하려면 먼저 얼굴을 찾을 때까지 이미지에서 얼굴 검색을 수행 한 다음 얼굴 영역 내에서 눈을 검색하십시오. 이 방법은 정확도와 성능 향상시킵니다 (눈이 항상 얼굴에 있기 때문에 우리는 작은 영역만 검색을 수행하면 됩니다) ROI는 Numpy 색인을 사용하여 다시 얻습니다. 여기서 공을 선택하여 이미지의 다른 영역으로 복사합니다. 12&gt;&gt;&gt; ball = img[280:340, 330:390]&gt;&gt;&gt; img[273:333, 100:160] = ball 전체 코드는 다음과 같습니다. 123456789101112import cv2image_file = &#x27;ball_image.jpg&#x27;img = cv2.imread(image_file)ball = img[0:113, 349:459]img[100:213, 449:559] = ballcv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 결과 이미지 채널 분할 및 병합 필요한 경우 이미지의 B, G, R 채널을 개별 평면으로 분할 할 수 있습니다. 그런 다음 개별 채널을 다시 병합하여 BGR 이미지를 다시 형성 할 수 있습니다. 이것은 다음과 같이 수행 할 수 있습니다. 12&gt;&gt;&gt; b,g,r = cv2.split(img)&gt;&gt;&gt; img = cv2.merge((b,g,r)) 또는 1&gt;&gt;&gt; b = img[:,:,0] 빨간색 픽셀을 모두 0으로 만들고 싶다면, 이렇게 분할하고 0으로 놓을 필요가 없습니다. 더 빠르다고 말하는 Numpy 색인 생성을 간단하게 사용할 수 있습니다. 1img[:,:,2] = 0 cv2.split()은 값 비싼 연산이므로 (시간의 관점에서) 필요한 경우에만 사용하십시오. Numpy 색인 생성은 훨씬 효율적이기 때문에 가능하면 사용해야 합니다. 이미지에 테두리 만들기 (안쪽 여백 만들기) 포토 프레임과 같은 이미지 주위에 테두리를 만들려면 cv2.copyMakeBorder() 함수를 사용할 수 있습니다. 그러나 이 함수는 컨볼루션 연산, 제로 패딩 (zero padding) 등의 애플리케이션이 더 많습니다. 이 함수는 다음과 같은 인수를 취합니다. src - 입력 이미지 위쪽, 아래쪽, 왼쪽, 오른쪽 - 경계의 폭 (해당 방향의 픽셀 수) borderType - 추가되는 경계의 종류를 정의하는 플래그. 다음 유형이 될 수 있습니다. cv2.BORDER_CONSTANT - 일정한 색상의 테두리를 추가합니다. 값은 다음 인수로 제공되어야합니다. cv2.BORDER_REFLECT - 테두리는 다음과 같이 테두리 요소를 반영합니다. fedcba|abcdefgh|hgfedcb cv2.BORDER_REFLECT_101 또는 cv2.BORDER_DEFAULT - 위와 동일하지만 다음과 같이 약간 변경되었습니다. gfedcb|abcdefgh|gfedcba cv2.BORDER_REPLICATE - 마지막 요소는 다음과 같이 전체적으로 복제됩니다. aaaaaa|abcdefgh|hhhhhhh cv2.BORDER_WRAP - 설명 할 수 없습니다. 다음과 같이 보일 것이다 : cdefgh|abcdefgh|abcdefg value - 경계 형이 cv2.BORDER_CONSTANT의 경우는 경계의 색 abcdefgh 는 원본을 의미합니다. fedcba|abcdefgh|hgfedcb 는 세로줄 |을 기준으로 양쪽으로 반영된 상태를 표시합니다. 원본이 abcdefgh 이므로, 왼쪽에 fedcba 의 순서로 반영된 이미지가 나오고 오른쪽에는 hgfedcb 으로 반영된 이미지가 나오는 것을 표시하고 있습니다. 다음은 더 나은 이해를 위해 이러한 모든 경계 유형을 보여주는 샘플 코드입니다. 12345678910111213141516171819202122232425import cv2import numpy as npfrom matplotlib import pyplot as pltBLUE = [255, 0, 0]image_file = &#x27;opencv-logo-white.png&#x27;img1 = cv2.imread(image_file)pixel = 100replicate = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_REPLICATE)reflect = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_REFLECT)reflect101 = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_REFLECT_101)wrap = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_WRAP)constant = cv2.copyMakeBorder(img1, pixel, pixel, pixel, pixel, cv2.BORDER_CONSTANT, value=BLUE)plt.subplot(231), plt.imshow(img1, &#x27;gray&#x27;), plt.title(&#x27;ORIGINAL&#x27;)plt.subplot(232), plt.imshow(replicate, &#x27;gray&#x27;), plt.title(&#x27;REPLICATE&#x27;)plt.subplot(233), plt.imshow(reflect, &#x27;gray&#x27;), plt.title(&#x27;REFLECT&#x27;)plt.subplot(234), plt.imshow(reflect101, &#x27;gray&#x27;), plt.title(&#x27;REFLECT_101&#x27;)plt.subplot(235), plt.imshow(wrap, &#x27;gray&#x27;), plt.title(&#x27;WRAP&#x27;)plt.subplot(236), plt.imshow(constant, &#x27;gray&#x27;), plt.title(&#x27;CONSTANT&#x27;)plt.show() 아래 결과를보십시오. (이미지는 matplotlib과 함께 표시되므로 RED 및 BLUE 평면이 상호 교환됩니다.) 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_core/py_basic_ops/py_basic_ops.html#basic-ops","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials 05] 마우스로 그리기","slug":"2018/OpenCV-Python-Tutorials-05-마우스로-그리기","date":"2018-01-05T10:11:51.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-05-마우스로-그리기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-05-%EB%A7%88%EC%9A%B0%EC%8A%A4%EB%A1%9C-%EA%B7%B8%EB%A6%AC%EA%B8%B0/","excerpt":"","text":"[OpenCV-Python Tutorials 05] 마우스로 그리기 모든 파일은 Github에서 확인 할 수 있습니다. 목표 OpenCV에서 마우스 이벤트 처리 방법 배우기 다음 함수를 배웁니다. cv2.setMouseCallback() 간단한 데모 여기서 우리는 두 번 클릭 할 때마다 이미지에 원을 그리는 간단한 애플리케이션을 만듭니다. 먼저 마우스 이벤트가 발생할 때 실행되는 마우스 콜백 함수를 만듭니다. 마우스 이벤트는 왼쪽 버튼 누를 때, 왼쪽 버튼 놓을 때, 왼쪽 버튼 두 번 클릭 등과 같은 마우스 관련 항목 일 수 있습니다. 모든 마우스 이벤트에 대한 좌표 (x, y)를 제공합니다. 이 이벤트와 위치로 우리는 무엇이든 할 수 있습니다. 사용 가능한 이벤트를 모두 나열하려면 Python 터미널에서 다음 코드를 실행하십시오. 123&gt;&gt;&gt; import cv2&gt;&gt;&gt; events = [i for i in dir(cv2) if &#x27;EVENT&#x27; in i]&gt;&gt;&gt; print events python3 의 경우에는 print(events) 로 입력합니다. 결과는 아래와 같습니다. 12345&gt;&gt;&gt; import cv2&gt;&gt;&gt; events = [i for i in dir(cv2) if &#x27;EVENT&#x27; in i]&gt;&gt;&gt; print(events)[&#x27;EVENT_FLAG_ALTKEY&#x27;, &#x27;EVENT_FLAG_CTRLKEY&#x27;, &#x27;EVENT_FLAG_LBUTTON&#x27;, &#x27;EVENT_FLAG_MBUTTON&#x27;, &#x27;EVENT_FLAG_RBUTTON&#x27;, &#x27;EVENT_FLAG_SHIFTKEY&#x27;, &#x27;EVENT_LBUTTONDBLCLK&#x27;, &#x27;EVENT_LBUTTONDOWN&#x27;, &#x27;EVENT_LBUTTONUP&#x27;, &#x27;EVENT_MBUTTONDBLCLK&#x27;, &#x27;EVENT_MBUTTONDOWN&#x27;, &#x27;EVENT_MBUTTONUP&#x27;, &#x27;EVENT_MOUSEHWHEEL&#x27;, &#x27;EVENT_MOUSEMOVE&#x27;, &#x27;EVENT_MOUSEWHEEL&#x27;, &#x27;EVENT_RBUTTONDBLCLK&#x27;, &#x27;EVENT_RBUTTONDOWN&#x27;, &#x27;EVENT_RBUTTONUP&#x27;]&gt;&gt;&gt; 마우스 콜백 함수를 생성하는 것은 어디서나 같은 형식을 취합니다. 함수가 하는 것만 다릅니다. 따라서 마우스 콜백 함수는 한 가지 작업을 수행합니다. 두 번 클릭하면 원이 그려집니다. 아래 코드를 참조하십시오. 코드 내용을 보면서 확인할 수 있습니다. 1234567891011121314151617181920import cv2import numpy as np# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): if event == cv2.EVENT_LBUTTONDBLCLK: cv2.circle(img, (x, y), 100, (255, 0, 0), -1)# 검은색 바탕을 생성합니다. 마우스 콜백함수를 바인드 합니다.img = np.zeros((512, 512, 3), np.uint8)cv2.namedWindow(&#x27;image&#x27;)cv2.setMouseCallback(&#x27;image&#x27;, draw_circle)while True: cv2.imshow(&#x27;image&#x27;, img) if cv2.waitKey(20) &amp; 0xFF == 27: breakcv2.destroyAllWindows() 더블클릭을 하면 원이 그려지는 것을 확인할 수 있습니다. 종료를 하려면 ESC 키를 눌러야 합니다. 고급 데모 이제 우리는 훨씬 더 나은 응용 프로그램으로 갑니다. 이 그림에서는 Paint 응용 프로그램에서와 같이 마우스를 끌어서 선택한 사각형에 따라 직사각형 또는 원을 그립니다. 그래서 우리의 마우스 콜백 함수는 두 부분을 가지고 있습니다. 하나는 직사각형을 그리고 다른 하나는 원을 그립니다. 이 특정 예제는 객체 추적, 이미지 분할 등과 같은 일부 대화식 응용 프로그램을 작성하고 이해하는데 실제로 도움이 될 것입니다. 123456789101112131415161718192021222324252627282930import cv2import numpy as npdrawing = False # True 이면 마우스가 눌린 상태입니다.mode = True # True이면 사각형을 그립니다. &#x27;m&#x27;을 누르면 곡선으로 변경(토글)됩니다 ix, iy = -1, -1# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): global ix, iy, drawing, mode if event == cv2.EVENT_LBUTTONDOWN: drawing = True ix, iy = x, y elif event == cv2.EVENT_MOUSEMOVE: if drawing == True: if mode == True: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), -1) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1) elif event == cv2.EVENT_LBUTTONUP: drawing = False if mode == True: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), -1) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1) 다음으로이 마우스 콜백 함수를 OpenCV 윈도우에 바인딩해야합니다. 메인 루프에서 사각형과 원 사이를 토글(toggle)하기 위해 키 'm'에 대한 키보드 바인딩을 설정해야 합니다. 12345678910111213img = np.zeros((512,512,3), np.uint8)cv2.namedWindow(&#x27;image&#x27;)cv2.setMouseCallback(&#x27;image&#x27;,draw_circle)while(1): cv2.imshow(&#x27;image&#x27;,img) k = cv2.waitKey(1) &amp; 0xFF if k == ord(&#x27;m&#x27;): mode = not mode elif k == 27: breakcv2.destroyAllWindows() 기본은 사각형을 그리게 되고, m키를 누르면 원을 그리게 됩니다. 추가 리소스 연습 문제 마지막 예제에서는 채워진 직사각형을 그렸습니다. 코드를 수정하여 채워지지 않은 사각형을 그립니다. 1cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), True) 마지막 파라미터 값을 True로 변경하여 채워지지 않은 사각형으로 변경합니다. 12345678910111213141516171819202122232425262728293031323334353637import cv2import numpy as npdrawing = False # True 이면 마우스가 눌린 상태입니다.mode = True # True이면 사각형을 그립니다. &#x27;m&#x27;을 누르면 곡선으로 변경(토글)됩니다ix, iy = -1, -1# 마우스 콜백 함수def draw_circle(event, x, y, flags, param): global ix, iy, drawing, mode if event == cv2.EVENT_LBUTTONDOWN: drawing = True ix, iy = x, y elif event == cv2.EVENT_LBUTTONUP: drawing = False if mode == True: cv2.rectangle(img, (ix, iy), (x, y), (0, 255, 0), True) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1)img = np.zeros((512, 512, 3), np.uint8)cv2.namedWindow(&#x27;image&#x27;)cv2.setMouseCallback(&#x27;image&#x27;, draw_circle)while (1): cv2.imshow(&#x27;image&#x27;, img) k = cv2.waitKey(1) &amp; 0xFF if k == ord(&#x27;m&#x27;): mode = not mode elif k == 27: breakcv2.destroyAllWindows() 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_mouse_handling/py_mouse_handling.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials 04] OpenCV의 그리기 함수","slug":"2018/OpenCV-Python-Tutorials-04-OpenCV의-그리기-함수","date":"2018-01-04T10:11:27.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-04-OpenCV의-그리기-함수/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-04-OpenCV%EC%9D%98-%EA%B7%B8%EB%A6%AC%EA%B8%B0-%ED%95%A8%EC%88%98/","excerpt":"","text":"[OpenCV-Python Tutorials 04] OpenCV의 그리기 함수 모든 파일은 Github에서 확인 할 수 있습니다. 목표 OpenCV를 사용하여 다양한 기하학적 모양을 그리는 방법을 배웁니다. cv2.line(), cv2.circle(), cv2.rectangle(), cv2.ellipse(), cv2.putText() 등의 함수를 배웁니다. 코드 위의 모든 기능에서 다음과 같은 몇 가지 일반적인 인수가 표시됩니다. img : 도형을 그리려는 이미지 color : 도형의 색. BGR의 경우에는 튜플 (예 : (255,0,0), 파란색)으로 전달합니다. 그레이 스케일의 경우 스칼라 값을 전달하십시오. thickness : 선이나 원 등의 두께입니다. 원과 같은 닫힌 그림에 -1이 전달되면 모양이 채워집니다. 기본 두께 = 1 lineType : 8-connected, 앤티 앨리어싱 된 라인 등의 라인 유형. 기본적으로 8-connected 입니다. cv2.LINE_AA는 커브를 위해 멋진 앤티 앨리어싱 된 선을 제공합니다. 8-connected은 가장자리 또는 모서리 중 하나에 닿는 모든 픽셀에 이웃합니다. 선 그리기 선을 그리려면 선의 시작과 끝 좌표를 전달해야 합니다. 우리는 검은색 이미지를 만들고 왼쪽 위부터 오른쪽 아래까지 파란 선을 그릴 것입니다. 12345678import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pximg = cv2.line(img,(0,0),(511,511),(255,0,0),5) 선은 그렸지만 보이지 않으므로, 보이는 코드를 추가합니다. 123456789101112import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pximg = cv2.line(img,(0,0),(511,511),(255,0,0),5)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.line(img,(0,0),(511,511),(255,0,0),5) cv2.line() 함수의 파라미터 값은 다음과 같습니다. img: 배경 (0,0): 시작좌표 (511,511): 마지막좌표 (255,0,0): 컬러는 BGR 이므로, 파란색 5: 두께 BGR 은 Blue, Green, Red 를 의미합니다. 직사각형 그리기 직사각형을 그리려면 직사각형의 왼쪽 위모서리와 오른쪽 하단 모서리가 필요합니다. 이번에는 이미지의 오른쪽 상단에 녹색 사각형을 그려 보겠습니다. 1234567891011import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)img = cv2.rectangle(img,(384,0),(510,128),(0,255,0),3)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.rectangle(img,(384,0),(510,128),(0,255,0),3) cv2.rectangle 함수의 파라미터 값은 다음과 같습니다. img: 배경 (384,0) : 시작 좌표 (좌측 상단) (510,128): 끝 좌표 (우측 하단) (0,255,0): BGR 이므로 녹색 3 : 두께 원 그리기 원을 그리려면 중심 좌표와 반지름이 필요합니다. 위에서 그린 직사각형 안에 원을 그립니다. 1234567891011import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)img = cv2.circle(img,(447,63), 63, (0,0,255), -1)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.circle(img,(447,63), 63, (0,0,255), -1) cv2.circle() 함수의 파라미터는 다음과 같습니다. img: 배경 (447,63): 중심좌표 63: 반지름 (0,0,255): 컬러 BGR 이므로 빨간색 -1 : 두께가 -1 이므로 색상 채우기 타원 그리기 타원을 그리려면 몇 가지 인수를 전달해야합니다. 하나의 인수는 중심 위치 (x, y)입니다. 다음 인수는 축 길이 (장축 길이, 보조 축 길이)입니다. angle은 반 시계 방향으로 타원의 회전 각도입니다. startAngle과 endAngle은 장축에서 시계 방향으로 측정 된 타원 호의 시작과 끝을 나타냅니다. 0과 360의 값을 부여하면 타원이됩니다. 자세한 내용은 cv2.ellipse() 문서를 확인하십시오. 아래 예제에서는 이미지의 중앙에 반 타원을 그립니다. 1234567891011import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)img = cv2.ellipse(img,(256,256),(100,50),0,0,180,255,-1)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 1img = cv2.ellipse(img,(256,256),(100,50),0,0,180,255,-1) cv2.ellipse() 함수의 파라미터는 다음과 같습니다. img: 배경 (256,256): 중심점 (100,50): 장축길이, 보조축길이 0: 회전 각도 0: 시각 각도 180: 종료 각도 255: 색상, (255,0,0)로 입력해도 동일한 결과를 얻을 수 있습니다. -1: 두께, 채우기 다각형 그리기 다각형을 그리려면 먼저 정점 좌표가 필요합니다. 이러한 점을 모양 ROWSx1x2의 배열로 만듭니다. 여기서 ROWS는 정점의 수이고 int32 유형이어야합니다. 여기서 우리는 4 개의 꼭지점이있는 작은 폴리곤을 노란색으로 그립니다. 12345678910111213import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts = pts.reshape((-1,1,2))img = cv2.polylines(img,[pts],True,(0,255,255))cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 123pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts = pts.reshape((-1,1,2))img = cv2.polylines(img,[pts],True,(0,255,255)) cv2.polylines() 함수의 파라미터는 다음과 같습니다. img: 배경 [pts]: 좌표 배열 True: 닫힘 여부 설정 (0,255,255)): 컬러 세 번째 인수가 False인 경우 닫힌 모양이 아닌 모든 점에 합류하는 폴리 라인을 가져옵니다. 여러 줄을 그리려면 cv2.polylines()를 사용할 수 있습니다. 그리기 원하는 모든 선 목록을 만들어 함수에 전달하십시오. 모든 선은 개별적으로 그려집니다. 각 행에 대해 cv2.line()을 호출하는 것보다 더 효율적이고 빠른 방법으로 행 그룹을 그립니다. 이미지에 텍스트 추가하기 이미지에 텍스트를 넣으려면 다음을 지정해야합니다. 입력할 텍스트 데이터 놓을 위치의 좌표 (즉, 데이터가 시작되는 왼쪽 하단 모서리). 글꼴 유형 (지원되는 글꼴은 cv2.putText() 문서를 확인하십시오) 글꼴 크기 (글꼴 크기 지정) color, thickness, lineType 등과 같은 일반적인 것들. 더 나은 모양을 위해 lineType = cv2.LINE_AA가 권장됩니다. 우리는 우리의 이미지에 흰색으로 Hello OpenCV!!!를 씁니다. 123456789101112import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)font = cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,&#x27;Hello OpenCV!!!&#x27;,(10,500), font, 2, (255,255,255), 2, cv2.LINE_AA)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 12font = cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,&#x27;OpenCV&#x27;,(10,500), font, 4,(255,255,255),2,cv2.LINE_AA) cv2.putText()함수의 파라미터는 다음과 같습니다. img: 배경 ‘OpenCV’: 문자열 (10,500): 시작위치 font: 폰트 4: 폰트 크기 (255,255,255): 색상 2: 두께 cv2.LINE_AA: 선 유형 LINE_4 = 4 LINE_8 = 8 LINE_AA = 16 결과 이제 우리가 그린 그림의 최종 결과를 볼 시간입니다. 이전 기사에서 공부하면서 이미지를 표시하여 이미지를 봅니다. 12345678910111213141516171819202122import numpy as npimport cv2# Create a black imageimg = np.zeros((512,512,3), np.uint8)# Draw a diagonal blue line with thickness of 5 pximg = cv2.line(img,(0,0),(511,511),(255,0,0),5)img = cv2.rectangle(img,(384,0),(510,128),(0,255,0),3)img = cv2.circle(img,(447,63), 63, (0,0,255), -1)img = cv2.ellipse(img,(256,256),(100,50),0,0,180,(255,0,0),-1)pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts = pts.reshape((-1,1,2))img = cv2.polylines(img,[pts],True,(0,255,255))font = cv2.FONT_HERSHEY_SIMPLEXcv2.putText(img,&#x27;Hello OpenCV!!!&#x27;,(10,500), font, 2, (255,255,255), 2, cv2.LINE_AA)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 추가 리소스 타원 함수에 사용 된 각도는 원형 각도가 아닙니다. 자세한 내용은이 토론을 방문하십시오. 연습 문제 OpenCV에서 사용할 수있는 그리기 기능을 사용하여 OpenCV 로고 만들기 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_drawing_functions/py_drawing_functions.html http://radio.feld.cvut.cz/matlab/toolbox/images/binary6.html http://docs.opencv.org/2.4/modules/core/doc/drawing_functions.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials 03] 비디오 시작하기","slug":"2018/OpenCV-Python-Tutorials-03-비디오-시작하기","date":"2018-01-03T10:11:01.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-03-비디오-시작하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-03-%EB%B9%84%EB%94%94%EC%98%A4-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","excerpt":"","text":"[OpenCV-Python Tutorials 03] 비디오 시작하기 모든 파일은 Github에서 확인 할 수 있습니다. 목표 비디오 읽기, 비디오 디스플레이 및 비디오 저장 방법을 배웁니다. 카메라에서 캡처하여 표시하는 방법을 배웁니다. 다음 함수를 배웁니다. cv2.VideoCapture(), cv2.VideoWriter() 카메라에서 비디오 캡처 가끔 우리는 카메라로 라이브 스트림을 캡처 해야 합니다. OpenCV는 매우 간단한 인터페이스를 제공합니다. 카메라에서 비디오를 캡처하고 (저는 노트북의 내장 웹캠을 사용하고 있습니다.) 그레이 스케일 비디오로 변환하여 표시하는 간단한 작업부터 시작합니다. 비디오를 캡처하려면 VideoCapture 객체를 만들어야 합니다. 인수는 장치 색인이나 비디오 파일 이름이 될 수 있습니다. 장치 색인은 카메라를 지정하는 번호입니다. 일반적으로 하나의 카메라가 연결됩니다 (필자의 경우). 단순히 0 (또는 -1)을 전달합니다. 1을 전달하여 두 번째 카메라를 선택할 수 있습니다. 그 후에 프레임 단위로 캡처 할 수 있습니다. 그러나 마지막에 release 하는 것을 잊지 마십시오. 1234567891011121314151617181920import numpy as npimport cv2cap = cv2.VideoCapture(0)while(True): # Capture frame-by-frame ret, frame = cap.read() # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow(&#x27;frame&#x27;,gray) if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;): break# When everything done, release the capturecap.release()cv2.destroyAllWindows() 내장 웹캠이 없는 경우에는 에러가 발생하므로, 파일에서 비디오 재생하기 내용을 확인하여 저장 파일을 읽도록 변경합니다. cap.read()는 bool (True/False)을 반환합니다. 프레임을 올바르게 읽으면 True입니다. 따라서 이 반환 값을 확인하여 동영상의 끝을 확인할 수 있습니다. 경우에 따라 cap이 캡처를 초기화하지 않았을 수 있습니다. 이 경우이 코드는 오류를 표시합니다. cap.isOpened() 메소드를 통해서 초기화되었는지 여부를 확인할 수 있습니다. True이면 OK입니다. 그렇지 않으면 cap.open()을 사용하여 열 수 있습니다. 또한 cap.get(propId) 메소드를 사용하여 이 비디오의 일부 기능에 액세스 할 수 있습니다. 여기서 propId는 0에서 18사이의 숫자입니다. 각 숫자는 비디오의 속성을 나타내며 (해당 비디오에 적용 가능할 경우) 자세한 내용은 여기서 볼 수 있습니다 : Property Identifier.. 이 값 중 일부는 cap.set(propId, value)을 사용하여 수정할 수 있습니다. Value는 원하는 새 값입니다. 속성 설명 CV_CAP_PROP_POS_MSEC 밀리 세컨드 단위의 비디오 파일의 현재의 위치 또는 비디오 캡춰의 타임 스탬프. CV_CAP_PROP_POS_FRAMES 다음에 디코드 또는 캡춰되는, 프레임의 0베이스의 인덱스 CV_CAP_PROP_POS_AVI_RATIO 비디오 파일의 상대 위치 : 0 - 필름의 시작 부분, 필름의 끝 부분. CV_CAP_PROP_FRAME_WIDTH 비디오 스트림의 프레임의 폭. CV_CAP_PROP_FRAME_HEIGHT 비디오 스트림의 프레임의 높이. CV_CAP_PROP_FPS 프레임 속도. CV_CAP_PROP_FOURCC 코덱의 4-character 코드입니다. CV_CAP_PROP_FRAME_COUNT 비디오 파일의 프레임 수. CV_CAP_PROP_FORMAT retrieve()에 의해 반환 된 Mat 객체의 형식. CV_CAP_PROP_MODE 현재의 캡춰 모드를 나타내는 백엔드 고유의 값. CV_CAP_PROP_BRIGHTNESS 이미지의 밝기입니다 (카메라에만 해당). CV_CAP_PROP_CONTRAST 이미지의 명암 (카메라에만 해당). CV_CAP_PROP_SATURATION 이미지 포화 (카메라 만). CV_CAP_PROP_HUE 이미지의 색조입니다 (카메라에만 해당). CV_CAP_PROP_GAIN 이미지의 게인 (카메라에만 해당). CV_CAP_PROP_EXPOSURE 노출 (카메라에만 해당). CV_CAP_PROP_CONVERT_RGB 이미지를 RGB로 변환할지 어떨지를 나타내는 Boolean 형의 플래그. CV_CAP_PROP_WHITE_BALANCE_U 화이트 밸런스 설정의 U 값 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_WHITE_BALANCE_V 화이트 밸런스 설정의 V 값 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_RECTIFICATION 스테레오 카메라의 정류 플래그 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_ISO_SPEED 카메라의 ISO 속도 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) CV_CAP_PROP_BUFFERSIZE 내부 버퍼 메모리에 저장된 프레임 수 (참고 : 현재 DC1394 v 2.x 백엔드에서만 지원됨) 예를 들어, 프레임 너비와 높이를 cap.get(3)과 cap.get(4)로 확인할 수 있습니다. 기본적으로 640x480을 제공하는 것을 320x240으로 수정하고 싶다면 ret = cap.set(3,320) 와 ret = cap.set(4,240) 만 사용하십시오. 12ret = cap.set(CV_CAP_PROP_FRAME_WIDTH,320)ret = cap.set(CV_CAP_PROP_FRAME_HEIGHT,240) 오류가 발생하면 다른 카메라 응용 프로그램 (예 : Linux의 Cheese)을 사용하여 카메라가 제대로 작동하는지 확인하십시오. 파일에서 비디오 재생하기 카메라에서 캡쳐하는 것과 같습니다. 비디오 파일 이름으로 카메라 인덱스를 변경하면 됩니다. 또한 프레임을 표시하는 동안 cv2.waitKey()을 이용하여 적절한 시간을 사용하십시오. 너무 적으면 비디오가 매우 빠르며 너무 높으면 비디오가 느려집니다 (즉, 비디오를 느린 동작으로 표시 할 수 있습니다). 정상적인 경우 25 밀리 초가 정상입니다. 123456789101112131415161718192021import numpy as npimport cv2file = &#x27;01_video.mp4&#x27;cap = cv2.VideoCapture(file)while(True): # Capture frame-by-frame ret, frame = cap.read() # Our operations on the frame come here gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) # Display the resulting frame cv2.imshow(&#x27;frame&#x27;,gray) if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;): break# When everything done, release the capturecap.release()cv2.destroyAllWindows() 동영상을 끝내기 위해서는 q 키를 입력해야 합니다. ffmpeg 또는 gstreamer의 올바른 버전이 설치되어 있는지 확인하십시오. 때로는 ffmpeg / gstreamer가 잘못 설치되어 비디오 캡쳐 작업에 문제가 생깁니다. 비디오 저장하기 따라서 우리는 비디오를 캡처하여 프레임 단위로 처리하고 해당 비디오를 저장하려고 합니다. 이미지의 경우 매우 간단합니다. cv2.imwrite()만 사용하면됩니다. 비디오에서는 좀 더 많은 작업이 필요합니다. 이번에는 VideoWriter 객체를 만듭니다. 출력 파일 이름을 지정해야 합니다 (예 : output.avi). 그런 다음 FourCC 코드를 지정해야 합니다 (다음 단락에 세부사항이 설명되어 있습니다). 그런 다음 초당 프레임 수(fps)와 프레임 크기를 전달해야 합니다. 그리고 마지막 하나는 isColor 플래그입니다. True이면 인코더는 컬러 프레임을 요구하고 그렇지 않으면 그레이 스케일 프레임과 함께 작동합니다. FourCC는 비디오 코덱을 지정하는 데 사용되는 4 바이트 코드입니다. 사용 가능한 코드 목록은 fourcc.org에서 찾을 수 있습니다. 플랫폼에 따라 다릅니다. 다음 코덱은 잘 작동합니다. FourCC(Four Character Code)는 말 그대로 &quot;4글자 코드&quot;라는 뜻이며, 4 바이트로 된 문자열은 데이터 형식을 구분하는 고유 글자가 된다. Fedora : DIVX, XVID, MJPG, X264, WMV1, WMV2. (XVID가 더 바람직합니다. MJPG는 고화질 비디오를 만듭니다 .X264는 매우 작은 크기의 비디오를 제공합니다) Windows의 경우 : DIVX (테스트 및 추가 예정) FourCC 코드는 MJPG의 경우 cv2.VideoWriter_fourcc('M', 'J', 'P', 'G') 또는 cv2.VideoWriter_fourcc(*'MJPG')로 전달됩니다. 카메라의 코드 캡처 아래에서 모든 프레임을 수직 방향으로 뒤집어 저장합니다. 123456789101112131415161718192021222324252627import numpy as npimport cv2cap = cv2.VideoCapture(0)# Define the codec and create VideoWriter objectfourcc = cv2.VideoWriter_fourcc(*&#x27;XVID&#x27;)out = cv2.VideoWriter(&#x27;output.avi&#x27;,fourcc, 20.0, (640,480))while(cap.isOpened()): ret, frame = cap.read() if ret==True: frame = cv2.flip(frame,0) # write the flipped frame out.write(frame) cv2.imshow(&#x27;frame&#x27;,frame) if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;): break else: break# Release everything if job is finishedcap.release()out.release()cv2.destroyAllWindows() 위아래가 뒤집어진 영상이 저장된 것을 확인할 수 있습니다. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image https://videos.pexels.com/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials 02] 이미지 시작하기","slug":"2018/OpenCV-Python-Tutorials-02-이미지-시작하기","date":"2018-01-02T10:10:35.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-02-이미지-시작하기/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-02-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/","excerpt":"","text":"[OpenCV-Python Tutorials 02] 이미지 시작하기 모든 파일은 Github에서 확인 할 수 있습니다. 목표 여기에서 이미지를 읽는 방법, 이미지를 표시하는 방법 및 이미지를 다시 저장하는 방법에 대해 배웁니다. 다음 함수를 배웁니다. cv2.imread(), cv2.imshow(), cv2.imwrite() 선택적으로 Matplotlib을 사용하여 이미지를 표시하는 방법을 배우게됩니다. OpenCV 사용 이미지 읽기 이미지를 읽으려면 cv2.imread() 함수를 사용하십시오. 이미지는 작업 디렉토리에 있거나 이미지의 전체 경로가 주어져야 합니다. 두 번째 인수는 이미지를 읽어야하는 방법을 지정하는 플래그입니다. cv2.IMREAD_COLOR : 컬러 이미지를 로드합니다. 이미지의 투명성은 무시됩니다. 기본 플래그입니다. cv2.IMREAD_GRAYSCALE : 이미지를 회색조 모드로 로드합니다. cv2.IMREAD_UNCHANGED : 알파 채널을 포함하여 이미지를 로드합니다. 이 세 개의 플래그 대신 정수 1, 0 또는 -1을 각각 전달할 수 있습니다. 아래 코드를 참조하십시오. 123456import numpy as npimport cv2# Load an color image in grayscalefile = &#x27;01_model.jpg&#x27;img = cv2.imread(file, 0) 이미지 경로가 잘못 되어도 오류는 발생하지 않지만 img(print img)는 아무것도(None) 표시되지 않습니다. 이미지 표시 창에 이미지를 표시하려면 cv2.imshow() 함수를 사용하십시오. 창은 이미지 크기에 자동으로 맞춰집니다. 첫 번째 파라미터는 창 이름을 나타내는 문자열입니다. 두 번째 파라미터는 출력할 이미지입니다. 원하는 만큼 창을 만들 수 있지만 창이름은 다르게 해야 합니다. 12345678910import numpy as npimport cv2# Load an color image in grayscalefile = &#x27;01_model.jpg&#x27;img = cv2.imread(file, 0)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 윈도우의 스크린 샷은 다음과 같습니다. cv2.imread(file, 0) 호출시에 두번째 파라미터로 0을 전달하여 그레이스케일 이미지로 출력됩니다. 12345678910import numpy as npimport cv2# 컬러 이미지를 로드 합니다. file = &#x27;01_model.jpg&#x27;img = cv2.imread(file, cv2.IMREAD_COLOR)cv2.imshow(&#x27;image&#x27;, img)cv2.waitKey(0)cv2.destroyAllWindows() 두번째 파라미터에 cv2.IMREAD_COLOR를 전달하여 컬러 이미지로 출력되도록 변경합니다. cv2.waitKey()는 키보드 바인딩 함수입니다. 인수는 밀리 초 단위의 시간입니다. 이 함수는 키보드 이벤트에 대해 지정된 밀리 초를 기다립니다. 그 시간에 아무 키나 누르면 프로그램이 계속됩니다. 0을 전달하면 키 스트로크가 무기한 대기됩니다. 키 a가 눌려 졌을 때 등과 같은 특정 키 스트로크를 감지하도록 설정할 수도 있습니다. cv2.destroyAllWindows()는 우리가 만든 모든 창을 단순히 파괴합니다. 특정 윈도우를 파기하려면 정확한 윈도우 이름을 인수로 전달하는 cv2.destroyWindow() 함수를 사용하십시오. 이미 창을 만들고 나중에 이미지를 로드 하는 특별한 경우가 있습니다. 이 경우 창 크기를 조정할 수 있는지 여부를 지정할 수 있습니다. 이것은 cv2.namedWindow() 함수로 처리됩니다. 플래그 기본값은 cv2.WINDOW_AUTOSIZE입니다. 그러나 플래그를 cv2.WINDOW_NORMAL로 지정하면 윈도우의 크기를 조정할 수 있습니다. 이미지의 크기가 너무 크고 트랙 바를 윈도우에 추가 할 때 유용합니다. 아래 코드를 참조하십시오. 1234cv2.namedWindow(&#x27;image&#x27;, cv2.WINDOW_NORMAL)cv2.imshow(&#x27;image&#x27;,img)cv2.waitKey(0)cv2.destroyAllWindows() 이미지 저장 이미지를 저장하려면 cv2.imwrite() 함수를 사용하십시오. 첫 번째 인수는 파일 이름이고, 두 번째 인수는 저장할 이미지입니다. 12345678import numpy as npimport cv2# 컬러 이미지를 로드 합니다.file = &#x27;01_model.jpg&#x27;img = cv2.imread(file, cv2.IMREAD_COLOR)cv2.imwrite(&#x27;04_image_write_output.png&#x27;, img) 그러면 작업 디렉토리에 이미지가 PNG 형식으로 저장됩니다. 작업폴더에 파일이 생성되는 것을 확인할 수 있습니다. 소스파일은 모두 Github에서 확인할 수 있습니다. Sum it up 아래 프로그램은 그레이 스케일로 이미지를 로드하고, 표시하고, 's’를 누르면 이미지를 저장하고 종료합니다. 아니면 ESC 키를 누르면 저장하지 않고 종료합니다. 1234567891011121314import numpy as npimport cv2# Load an color image in grayscalefile = &#x27;01_model.jpg&#x27;img = cv2.imread(file, 0)cv2.imshow(&#x27;image&#x27;, img)k = cv2.waitKey(0)if k == 27: # wait for ESC key to exit cv2.destroyAllWindows()elif k == ord(&#x27;s&#x27;): # wait for &#x27;s&#x27; key to save and exit cv2.imwrite(&#x27;05_sum_it_up_output.png&#x27;, img) cv2.destroyAllWindows() Matplotlib 사용하기 Matplotlib은 다양한 플로팅 방법을 제공하는 Python용 플로팅 라이브러리입니다. 당신은 다음 내용에서 Matplotlib에 대해 볼 수 있습니다. 여기서는 Matplotlib을 사용하여 이미지를 표시하는 방법을 배우게 됩니다. Matplotlib을 사용하여 이미지를 확대/축소하고 저장할 수 있습니다. matplotlib는 파이썬에서 자료를 차트(chart)나 플롯(plot)으로 시각화(visulaization)하는 패키지이다. 123456789import numpy as npimport cv2from matplotlib import pyplot as pltfile = &#x27;01_model.jpg&#x27;img = cv2.imread(file, 0)plt.imshow(img, cmap = &#x27;gray&#x27;, interpolation = &#x27;bicubic&#x27;)plt.xticks([]), plt.yticks([]) # to hide tick values on X and Y axisplt.show() 화면의 스크린 샷은 다음과 같습니다. Matplotlib에서는 다양한 플롯팅 옵션을 사용할 수 있습니다. 자세한 내용은 Matplotlib 문서를 참조하십시오. OpenCV로로드 된 컬러 이미지는 BGR 모드입니다. 그러나 Matplotlib은 RGB 모드로 표시됩니다. 따라서 OpenCV로 이미지를 읽으면 컬러 이미지가 Matplotlib에서 올바르게 표시되지 않습니다. 자세한 내용은 연습 문제를 참조하십시오. Additional Resources Matplotlib Plotting Styles and Features 연습 문제 OpenCV에서 컬러 이미지를로드하여 Matplotlib에 표시하려고 할 때 약간의 문제가 있습니다. 이 토론을 읽고 이해하십시오. 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_gui/py_image_display/py_image_display.html#display-image https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220499281999&amp;parentCategoryNo=&amp;categoryNo=66&amp;viewDate=&amp;isShowPopularPosts=false&amp;from=postList","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"[OpenCV-Python Tutorials 01] OpenCV-Python Tutorials 소개","slug":"2018/OpenCV-Python-Tutorials-01-OpenCV-Python-Tutorials-소개","date":"2018-01-01T10:13:45.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2018/OpenCV-Python-Tutorials-01-OpenCV-Python-Tutorials-소개/","link":"","permalink":"http://jacegem.github.io/blog/2018/OpenCV-Python-Tutorials-01-OpenCV-Python-Tutorials-%EC%86%8C%EA%B0%9C/","excerpt":"","text":"[OpenCV-Python Tutorials 01] OpenCV-Python Tutorials 소개 모든 파일은 Github에서 확인 할 수 있습니다. OpenCV OpenCV는 1999년 Gary Bradsky에 의해 인텔에서 시작되었으며 첫번째 릴리스는 2000년에 나왔습니다. Vadim Pisarevsky는 Intel의 러시아 소프트웨어 OpenCV 팀을 관리하기 위해 Gary Bradsky에 합류했습니다. 2005년, OpenCV는 2005 DARPA 그랜드 챌린지에서 우승 한 차량인 Stanley에 사용되었습니다. 다르파 그랜드 챌린지(The DARPA Grand Challenge)는 미 국방성 최고위 연구기관인 국방고등기획국(Defense Advanced Research Projects Agency, DARPA, 다르파)이 후원하는 무인 자동차 경주 대회다. 나중에 Gary Bradsky와 Vadim Pisarevsky가 프로젝트를 이끌면서 Willow Garage의 지원하에 적극적으로 발전했습니다. 현재 OpenCV는 컴퓨터 비전 및 기계 학습과 관련된 많은 알고리즘을 지원하며 날마다 확장되고 있습니다. 현재 OpenCV는 C++, Python, Java 등 다양한 프로그래밍 언어를 지원하며 Windows, Linux, OS X, Android, iOS 등 다양한 플랫폼에서 사용할 수 있습니다. 또한 CUDA 및 OpenCL을 기반으로 한 인터페이스도 고속 GPU 작동을 위해 활발히 개발 중입니다. CUDA (“Compute Unified Device Architecture”, 쿠다)는 그래픽 처리 장치(GPU)에서 수행하는 (병렬 처리) 알고리즘을 C 프로그래밍 언어를 비롯한 산업 표준 언어를 사용하여 작성할 수 있도록 하는 GPGPU 기술이다. OpenCV-Python은 OpenCV의 Python API입니다. OpenCV C++ API와 Python 언어의 최상의 특성을 결합합니다. OpenCV-Python Python은 Guido van Rossum에 의해 시작된 범용 프로그래밍 언어입니다. 이 언어는 단순성과 코드 가독성으로 인해 단기간에 큰 인기를 끌게 되었습니다. Python을 사용하면 프로그래머는 가독성을 떨어 뜨리지 않으면서 적은 수의 코드 행으로 자신의 아이디어를 표현할 수 있습니다. C/C와 같은 다른 언어와 비교할 때 Python은 속도가 느립니다. 그러나 파이썬의 또 다른 중요한 특징은 C/C로 쉽게 확장 할 수 있다는 것입니다. 이 기능은 C/C++에서 계산 집약적인 코드를 작성하고 파이썬 래퍼를 작성하여 이러한 래퍼를 파이썬 모듈로 사용할 수 있게 도와줍니다. 이것은 두 가지 이점을 제공합니다. 첫번째, 우리의 코드는 원래의 C/C++ 코드만큼 빠르며 (실제 C++ 코드가 백그라운드에서 작동하기 때문에) 두번째, Python으로 코딩하는 것이 매우 쉽습니다. 이것은 OpenCV-Python이 작동하는 방식으로 원래의 C++ 구현을 둘러싼 파이썬 wrapper입니다. 그리고 Numpy의 지원으로 작업이 더 쉬워졌습니다. Numpy는 수치 연산을 위해 최적화된 라이브러리입니다. Numpy는 MATLAB 스타일의 구문을 제공합니다. 모든 OpenCV 배열 구조는 Numpy 배열로 변환됩니다. Numpy에서 할 수 있는 어떤 작업도 OpenCV와 결합하여 당신의 무기고의 무기 개수를 늘릴 수 있습니다. 그 외에도 Numpy를 지원하는 SciPy, Matplotlib과 같은 여러 라이브러리와 함께 사용할 수 있습니다. 따라서 OpenCV-Python은 컴퓨터 비전 문제의 신속한 프로토타이핑을 위한 적절한 도구입니다. 프로토타입은 '정보시스템의 미완성 버전 또는 중요한 기능들이 포함되어 있는 시스템의 초기모델’이다. OpenCV-Python Tutorials OpenCV는 OpenCV-Python에서 사용할 수 있는 다양한 기능을 안내하는 새로운 자습서 세트를 소개합니다. 이 가이드는 주로 OpenCV 3.x 버전에 초점을 맞추고 있습니다. (대부분의 자습서는 OpenCV 2.x에서도 작동합니다.) Python과 Numpy에 대한 사전 지식은 안내서에서 다루지 않기 때문에 시작하기 전에 필요합니다. 특히, OpenCV-Python에서 최적화된 코드를 작성하기 위해서 Numpy에 대한 좋은 지식이 필요합니다. 이 자습서는 Alexander Mordvintsev의 지도하에 2013년 Google Summer of Code 프로그램의 일환으로 Abid Rahman K가 시작했습니다. OpenCV Needs You !!! OpenCV는 오픈 소스 이니셔티브이기 때문에 이 라이브러리에 기여할 수 있습니다. 그리고 이 튜토리얼에서도 마찬가지입니다. 오픈 소스 이니셔티브(Open Source Initiative, 줄여서 OSI)는 오픈 소스 소프트웨어 사용을 장려하기 위하여 만들어진 단체이다. 따라서 이 튜토리얼에서 실수를 발견하면 (작은 맞춤법 오류, 코드, 개념의 큰 오류 등 어떤 것이든) 자유롭게 수정하십시오. 오픈 소스 프로젝트에 기여하기 시작하는 사람들에게는 좋은 일이 될 것입니다. OpenCV를 Github에서 fork 하고 필요한 부분을 수정하고 OpenCV에 pull request 를 보내면 됩니다. OpenCV 개발자는 pull request 요청을 확인하고 중요한 피드백을 주며 검토자 승인을 통과하면 OpenCV에 병합됩니다. 그러면 당신은 오픈 소스 기여자가 됩니다. 다른 튜토리얼, 문서 등의 경우에서도 마찬가지 입니다 OpenCV-Python에 새로운 모듈이 추가됨에 따라 이 튜토리얼은 확장되어야 합니다. 그래서 특정 알고리즘을 아는 사람들은 알고리즘의 기본 이론과 알고리즘의 기본 사용법을 보여주는 코드를 포함하는 튜토리얼을 작성하여 OpenCV에 제출할 수 있습니다. 우리는 함께 이 프로젝트를 성공적으로 만들 수 있다는 것을 잊지 마십시오!!! Contributors 다음은 OpenCV-Python에 자습서를 제출한 기고자 목록입니다. Alexander Mordvintsev (GSoC-2013 mentor) Abid Rahman K. (GSoC-2013 intern) 설치 Anaconda를 설치합니다. 파이썬 라이브러리 모음 사이트에서 opencv를 찾아 설치합니다. 12345&gt; D:\\8.Download&gt;pip install &quot;opencv_python-3.2.0+contrib-cp36-cp36m-win_amd64.whl&quot;Processing d:\\8.download\\opencv_python-3.2.0+contrib-cp36-cp36m-win_amd64.whlInstalling collected packages: opencv-pythonSuccessfully installed opencv-python-3.2.0+contrib Additional Resources A Quick guide to Python - A Byte of Python Basic Numpy Tutorials Numpy Examples List OpenCV Documentation OpenCV Forum 출처 https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_setup/py_intro/py_intro.html#intro https://blog.naver.com/PostView.nhn?blogId=samsjang&amp;logNo=220498694383&amp;categoryNo=66&amp;parentCategoryNo=0&amp;viewDate=&amp;currentPage=6&amp;postListTopCurrentPage=1&amp;from=postList&amp;userTopListOpen=true&amp;userTopListCount=10&amp;userTopListManageOpen=false&amp;userTopListCurrentPage=6 https://ko.wikipedia.org","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"}]},{"title":"Youtube 다운로드 받기","slug":"2017/youtube-download-program","date":"2017-05-03T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/youtube-download-program/","link":"","permalink":"http://jacegem.github.io/blog/2017/youtube-download-program/","excerpt":"","text":"Youtube 다운로드 받기 NAS NAS 를 사용하시면 Synology 에서는 Download Station 을 사용 QNAP 에서는 happyget2를 사용 Download Station 설정 방법은 이곳을 참조하시면 됩니다. Windows Program http://www.techradar.com/news/the-best-free-youtube-downloader 에서 나열한 프로그램을들 설치하여 실행하면서 비교하였습니다. 결론은, ClipGrab 을 추천 합니다. 무료이고 광고도 없습니다. 다운로드 URL : https://clipgrab.org 비교 프로그램 실행 무료 광고 ClipGrab 실행 무료 없음 Freemake Video Downloader 실행 무료 있음 aTube Catcher 응답 없음 Any Video Converter Free 응답 없음 Free YouTube Download 실행 유료 Freemake Video Downloader 설치시에, 다른 프로그램 설치되는 체크박스가 활성화 되어 있으므로, 이 부분은 해제해 주어야 합니다. 앞뒤로 광고 영상을 붙이는 단점이 있다. 이런식으로… aTube Catcher 위와 동일한 링크를 넣고 다운로드를 실행하였는데, 계속 응답 없음 사태가 발생합니다. Any Video Converter Free 동일 URL 을 붙여넣었다. Analyzing video URL... 이라고 나오며 변화가 안 보입니다. Free YouTube Download 설치시에 체크박스가 비활성화 되어 있어서, 양심적인 프로그램으로 보입니다. 무료로는 다운로드 받을 수 있는 방법이 안 보입니다. 다 Premium 이네요 ClipGrab 다운로드 URL : https://clipgrab.org 설치시에 여기서 체크박스 해제하고 진행하세요. QT 로 만들어져 있네요. https://www.youtube.com/watch?v=9J5Z_pyqP_s&amp;index=1&amp;list=PLG7te9eYUi7sj1mAKtunTzO7s_jPxez-e 링크를 입력해 봅니다. URL 을 입력하고 이 클립 잡기 ((한글 번역으로 이렇게 나오는 것으로 생각됩니다)) 를 누르면 다운로드가 진행됩니다. 광고 없이 다운로드된 영상을 확인할 수 있습니다. 출처 https://nas.moe/archives/683 http://www.techradar.com/news/the-best-free-youtube-downloader","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Download","slug":"Application/Download","permalink":"http://jacegem.github.io/blog/categories/Application/Download/"}],"tags":[{"name":"youtube","slug":"youtube","permalink":"http://jacegem.github.io/blog/tags/youtube/"},{"name":"download","slug":"download","permalink":"http://jacegem.github.io/blog/tags/download/"}]},{"title":"Xamarin for Mac 설치","slug":"2017/xamarin-for-mac","date":"2017-05-02T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/xamarin-for-mac/","link":"","permalink":"http://jacegem.github.io/blog/2017/xamarin-for-mac/","excerpt":"","text":"Xamarin for Mac 설치 Xamarin Installer 실행 Xamarin Installer 를 실행합니다. Downloading and installing components 기본설정으로 설치하는데 용량이 4.1GB 입니다.","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"IDE","slug":"Application/IDE","permalink":"http://jacegem.github.io/blog/categories/Application/IDE/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://jacegem.github.io/blog/tags/mac/"},{"name":"xamarin","slug":"xamarin","permalink":"http://jacegem.github.io/blog/tags/xamarin/"}]},{"title":"책. 어서와~ 머신러닝은 처음이지","slug":"2017/welcom-machine-learning","date":"2017-05-01T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/welcom-machine-learning/","link":"","permalink":"http://jacegem.github.io/blog/2017/welcom-machine-learning/","excerpt":"","text":"책. 어서와~ 머신러닝은 처음이지 데이터 마이닝, 기계학습 → 데이터사이언스 유사한 분류를 찾는다. 유사성이란 무엇일까. distance=(x1−x2)2+(y1−y2)2distance = \\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2} distance=(x1​−x2​)2+(y1​−y2​)2​ 다차원 척도법(Multi-Dimensinal Scaling, MDS) 민코우스키(Minkowski) 거리 (r=1이 되면 맨타한 거리, r=2이 되면 유클리드 거리) d(x,y)=(∑n=1m∣xn−yn∣r)1rd(x,y) = (\\sum^{m}_{n=1}|x_n-y_n|^r)^\\frac{1}{r} d(x,y)=(n=1∑m​∣xn​−yn​∣r)r1​ d(x,y)=cos⁡(x,y)=x⋅y∣x∣∣y∣d(x,y) = \\cos(x,y) = \\frac{x\\cdot y}{|x||y|} d(x,y)=cos(x,y)=∣x∣∣y∣x⋅y​ 변화의 시작 1234567academy &lt;- read.csv(&#x27;academy.csv&#x27;, stringsAsFactors=F, header=T)academy &lt;- academy[-1]head(academy)tow_coord &lt;- cmdscale(dist_academy)plot(two_coord, type=&#x27;n&#x27;)text(two_coord, as.caracter(1:52)) Entropy(x)는 x에 대한 정보를 나타내기 위하여 평균적으로 알아야할 bit의 개수이다. 이것은 정보의 기대값이다. Pruning(가지치기)은 트리를 생성한 후에 overfitting을 방지하기 위해 필요없는 node를 줄이는 것을 의미한다. Clustering Analysis(군집분석) 최단연결법(Single Linkage) : 데이터 A와 군집 C와의 거리, 데이터 B와 군지 C와의 거리 중 최소값을 선택한다. d(AB)C=min(dAC,dBC)d_{(A B)C}=min(d_{A C}, d_{B C}) d(AB)C​=min(dAC​,dBC​) K-means(K-평균군집) 임의의 K개의 학습데이터를 평균벡터로 설정한다. (군집의 중심 초기설정) 데이터들을 K개의 평균벡터에 대하여 분류한다. (가장 가까운 점으로) 분류된 데이터들에 대하여 평균벡터(군집 중심)를 구한다. 그래서 새로운 K개의 평균벡터를 구한다. 2번을 반복한다. 3번을 반복한다. K평균벡터가 거의 변동이 없을 때까지 2번, 3번을 반복한다. 각각의 K개의 평균 vector로부터 해당군집의 분산이 최소가 되는 군집을 찾는 기법","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"R","slug":"Programming/R","permalink":"http://jacegem.github.io/blog/categories/Programming/R/"}],"tags":[{"name":"machine","slug":"machine","permalink":"http://jacegem.github.io/blog/tags/machine/"},{"name":"learning","slug":"learning","permalink":"http://jacegem.github.io/blog/tags/learning/"},{"name":"R","slug":"R","permalink":"http://jacegem.github.io/blog/tags/R/"}]},{"title":"Vue v-for 사용","slug":"2017/vue-v-for","date":"2017-04-12T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/vue-v-for/","link":"","permalink":"http://jacegem.github.io/blog/2017/vue-v-for/","excerpt":"","text":"Vue v-for 사용 데이터 요청 12345678this.$http.post(&#x27;/web/stat/mapSearch.json&#x27;, &#123;&#x27;text&#x27;: this.text, &#x27;x&#x27;: center.x, &#x27;y&#x27;:center.y&#125;).then(function(response)&#123; debugger; list = response.data.list; page = response.data.page;&#125;, function(response)&#123; //debugger;&#125;); 파라미터가 전달되지 않을 시에, 아래 내용을 추가한다. 1234http: &#123; emulateJSON: true, emulateHTTP: true&#125;, 결과 데이터 확인 페이지 정보를 가지고 최소, 최대 페이지를 구한다. 내부적으로 계산하는 코드 추가 123456789data: &#123; type : &#x27;&#x27;, text : &#x27;&#x27;, items: [], page : &#123;&#125;, displayCount : 5, pageStart : 1, pageEnd : 10,&#125;, data 를 정의 해 놓고, this로 사용한다. 123456this.items = response.data.list;this.page = response.data.page; this.pageStart = this.page.pageNo - parseInt((this.displayCount - 1) / 2, 10)if (this.pageStart &lt; 1) this.pageStart = 1;this.pageEnd = this.pageStart + this.displayCount - 1;if (this.pageEnd &gt; this.page.pageCount) this.pageEnd = this.page.pageCount; range 사용 range 메소드 생성 12345range: function (start, end)&#123; list = [] for (i = start; i &lt;= end ; i ++) list.push(i); return list;&#125; 123&lt;div class=&quot;btn-group btn-group-xs&quot; role=&quot;group&quot; aria-label=&quot;page number&quot; v-for=&quot;n in range(5, 20)&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/button&gt; &lt;/div&gt; 표출되는 것을 확인한 이후, click 함수 이벤트를 추가한다. 1&lt;button type=&quot;button&quot; class=&quot;btn&quot; v-on:click=&quot;search(n)&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/button&gt; search 함수 변경 123456789101112131415search: function(page)&#123; center = wmap.getCenter(); this.$http.post(&#x27;/web/stat/mapSearch.json&#x27;, &#123;&#x27;text&#x27;: this.text, &#x27;x&#x27;: center.x, &#x27;y&#x27;:center.y, &#x27;row_count&#x27;: this.rowCount, &#x27;page&#x27;: page&#125;) .then(function(response)&#123; debugger; this.items = response.data.list; this.page = response.data.page; this.pageStart = this.page.pageNo - parseInt((this.displayCount - 1) / 2, 10) if (this.pageStart &lt; 1) this.pageStart = 1; this.pageEnd = this.pageStart + this.displayCount - 1; if (this.pageEnd &gt; this.page.pageCount) this.pageEnd = this.page.pageCount; &#125;, function(response)&#123; //debugger; &#125;);&#125;, active 지정하기 출처 https://github.com/vuejs/vue/issues/211 https://github.com/vuejs/vue/issues/3641","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"for","slug":"for","permalink":"http://jacegem.github.io/blog/tags/for/"}]},{"title":"[Vue.js] v-for 에서 index 사용하기","slug":"2017/vue-v-for-index","date":"2017-04-11T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/vue-v-for-index/","link":"","permalink":"http://jacegem.github.io/blog/2017/vue-v-for-index/","excerpt":"","text":"[Vue.js] v-for 에서 index 사용하기 v-for 기본 사용 12345&lt;ul id=&quot;example-1&quot;&gt; &lt;li v-for=&quot;item in items&quot;&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; index 사용 12345&lt;ul id=&quot;example-2&quot;&gt; &lt;li v-for=&quot;(item, index) in items&quot;&gt; &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; method 추가 123456methods: &#123; chr: function(index)&#123; return String.fromCharCode(65 + index); &#125;, // 생략...&#125; HTML 수정 1&lt;li class=&quot;list-group-item&quot; v-for=&quot;item in items&quot; v-on:click=&quot;move(item.bd_mgt_sn, item.st_x, item.st_y)&quot;&gt;&lt;span class=&quot;map-point&quot;&gt;A&lt;/span&gt;&#123;&#123; item.buld_nm &#125;&#125;&lt;/li&gt; 1&lt;li class=&quot;list-group-item&quot; v-for=&quot;(item, index) in items&quot; v-on:click=&quot;move(item.bd_mgt_sn, item.st_x, item.st_y)&quot;&gt;&lt;span class=&quot;map-point&quot;&gt;&#123;&#123; chr(index) &#125;&#125;&lt;/span&gt;&#123;&#123; item.buld_nm &#125;&#125;&lt;/li&gt; v-for 인덱스에 따라 다른 결과가 나오도록 함. 인덱스 12340 =&gt; `A`1 =&gt; `B`2 =&gt; `C`... 출처 https://vuejs.org/v2/guide/list.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"for","slug":"for","permalink":"http://jacegem.github.io/blog/tags/for/"},{"name":"index","slug":"index","permalink":"http://jacegem.github.io/blog/tags/index/"}]},{"title":"Vue.js Start","slug":"2017/vue-js-start","date":"2017-04-10T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/vue-js-start/","link":"","permalink":"http://jacegem.github.io/blog/2017/vue-js-start/","excerpt":"","text":"Vue.js Start id=“StatEventCtrl” id를 대상으로 vue 생성 vue repeat v-for=&quot;(item, index) in items eventTypeClass 필터를 생성 v-bind :class=“{ ‘first’: index == 0, ‘odd’: !(index % 2), ‘even’: index % 2, ‘last’: index == (filteredItems.length - 1) }” app.filter(‘eventTypeClass’, function(){ return function(event_type){ switch(event_type){ case ‘0001’: return ‘event_emergency’; case ‘0002’: return ‘event_missing’; case ‘0003’: return ‘event_crime’; case ‘0004’: return ‘event_facility’; case ‘0005’: return ‘event_traffic’; default : return ‘event_etc’; } } }) app.filter(‘spreadTypeClass’, function(){ return function(type){ switch(type){ case ‘0001’: return ‘spread_emergency’; case ‘0002’: return ‘spread_missing’; case ‘0003’: return ‘spread_crime’; case ‘0004’: return ‘spread_facility’; case ‘0005’: return ‘spread_traffic_accident’; case ‘0006’: return ‘spread_traffic_control’; case ‘0007’: return ‘spread_fastival’; default : return ‘spread_etc’; } } }) wmap.setView(x, y); // 댓글 정보 조회 var scope = angular.element(document.getElementById(“popSpreadDetail”)).scope(); scope.update(data.spread_seq, “&lt;c:url value=‘/web/stat/spreadDetailReply.json’ /&gt;”); var scope = angular.element(document.getElementById(“popEventDetail”)).scope(); scope.update(base.event_seq, “&lt;c:url value=‘/web/stat/eventDetailReply.json’ /&gt;”); vue_event_detail.update(base.event_seq); var vue_stat_event_ctrl = new Vue({ vue_stat_event_ctrl.update(“&lt;c:url value=‘/web/stat/statEventList.json’ /&gt;”); var vue_stat_spread_ctrl = new Vue({ vue_stat_spread_ctrl.update(“&lt;c:url value=‘/web/stat/statSpreadList.json’ /&gt;”); url : “/web/stat/spreadRegist.json”, 직접입력 ${code.code_name} this.options[this.selectedIndex].text","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"start","slug":"start","permalink":"http://jacegem.github.io/blog/tags/start/"}]},{"title":"[Vue.js] input 값 길이 체크","slug":"2017/vue-js-length-check","date":"2017-04-09T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/vue-js-length-check/","link":"","permalink":"http://jacegem.github.io/blog/2017/vue-js-length-check/","excerpt":"","text":"[Vue.js] input 값 길이 체크 input 입력 데이터의 길이를 확인해서, 길이 초과시에 메시지를 출력한다. v-on:input 추가 1&lt;input type=&quot;text&quot; id=&quot;title&quot; v-on:input=&quot;title_typing&quot; name=&quot;title&quot; value=&quot;&quot; title=&quot;제목&quot; class=&quot;form-control&quot; /&gt; vue 생성 methods 를 추가합니다. 12345678910111213141516var vue_event_regist = new Vue(&#123; el: &#x27;#title&#x27;, methods: &#123; title_typing : function(e)&#123; this.max_length(e, 5, &#x27;제목&#x27;, &#x27;#title&#x27;); &#125;, max_length : function(e, len, title, id)&#123; var val = e.target.value; if (val.length &gt; len)&#123; var msg = title + &#x27;의 최대 입력 길이는 &#x27; + len + &#x27;입니다.&#x27;; fnShowMsg(msg); $(id).val(val.substring(0, len)); &#125; &#125; &#125;&#125;); watch를 사용하였으나, 한글입력시에 제대로 처리되지 않아, methods로 바꾸고, jquery 를 같이 사용하였습니다. 출처 https://vuejs.org/v2/guide/computed.html#Watchers https://vuejs.org/v2/guide/computed.html#Computed-vs-Watched-Property","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"length","slug":"length","permalink":"http://jacegem.github.io/blog/tags/length/"},{"name":"input","slug":"input","permalink":"http://jacegem.github.io/blog/tags/input/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"check","slug":"check","permalink":"http://jacegem.github.io/blog/tags/check/"}]},{"title":"Vue.js 엔터키 입력 처리","slug":"2017/vue-js-enter-key","date":"2017-04-08T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/vue-js-enter-key/","link":"","permalink":"http://jacegem.github.io/blog/2017/vue-js-enter-key/","excerpt":"","text":"Vue.js 엔터키 입력 처리 keyup 이벤트를 사용한다. 1&lt;input v-on:keyup.enter=&quot;submit&quot;&gt; 짧게 표현도 가능하다. 12&lt;!-- also works for shorthand --&gt;&lt;input @keyup.enter=&quot;submit&quot;&gt; 출처 https://vuejs.org/v2/guide/events.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"input","slug":"input","permalink":"http://jacegem.github.io/blog/tags/input/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"enter","slug":"enter","permalink":"http://jacegem.github.io/blog/tags/enter/"},{"name":"key","slug":"key","permalink":"http://jacegem.github.io/blog/tags/key/"}]},{"title":"Vue Class and Style","slug":"2017/vue-js-class","date":"2017-04-07T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/vue-js-class/","link":"","permalink":"http://jacegem.github.io/blog/2017/vue-js-class/","excerpt":"","text":"Vue Class and Style 1&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt; 123v-if=&quot;range(pageStart, pageEnd).shift() != 1&quot;v-if=&quot;range(pageStart, pageEnd).pop() != pageLast&quot;v-bind:class=&quot;&#123; active: isActive(n) &#125;&quot; 123456789101112&lt;div class=&quot;btn-toolbar&quot; role=&quot;toolbar&quot; aria-label=&quot;page group&quot; v-if=&quot;pageStart &gt; 0&quot;&gt; &lt;div class=&quot;btn-group btn-group-xs&quot; role=&quot;group&quot; aria-label=&quot;preview page&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn&quot; v-on:click=&quot;search(pageStart)&quot; v-if=&quot;range(pageStart, pageEnd).shift() != 1&quot;&gt;&lt;span class=&quot;sr-only&quot;&gt;이전&lt;/span&gt;&lt;span class=&quot;glyphicon glyphicon-menu-left&quot;&gt;&lt;/span&gt;&lt;/button&gt; &lt;/div&gt;&lt;!-- /btn-group --&gt; &lt;div class=&quot;btn-group btn-group-xs&quot; role=&quot;group&quot; aria-label=&quot;page number&quot; &gt; &lt;button type=&quot;button&quot; class=&quot;btn&quot; v-on:click=&quot;search(n)&quot; v-for=&quot;n in range(pageStart, pageEnd)&quot; v-bind:class=&quot;&#123; active: isActive(n) &#125;&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/button&gt; &lt;/div&gt; &lt;!-- /btn-group --&gt; &lt;div class=&quot;btn-group btn-group-xs&quot; role=&quot;group&quot; aria-label=&quot;next page&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn&quot; v-on:click=&quot;search(pageEnd)&quot; v-if=&quot;range(pageStart, pageEnd).pop() != pageLast&quot;&gt;&lt;span class=&quot;sr-only&quot;&gt;다음&lt;/span&gt;&lt;span class=&quot;glyphicon glyphicon-menu-right&quot;&gt;&lt;/span&gt;&lt;/button&gt; &lt;/div&gt;&lt;!-- /btn-group --&gt;&lt;/div&gt;&lt;!-- /btn-toolbar --&gt; 출처 https://vuejs.org/v2/guide/class-and-style.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"class","slug":"class","permalink":"http://jacegem.github.io/blog/tags/class/"},{"name":"style","slug":"style","permalink":"http://jacegem.github.io/blog/tags/style/"}]},{"title":"Visual Studio 2017 - python","slug":"2017/visual-studio-2017-python","date":"2017-04-06T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/visual-studio-2017-python/","link":"","permalink":"http://jacegem.github.io/blog/2017/visual-studio-2017-python/","excerpt":"","text":"Visual Studio 2017 - python Visual Studio Preview visual Studio 2017 설치 이후, python 개발 환경이 보이지 않는다면, Visual Studio Preview를 설치합니다. preview 를 설치하는데 오류가 생겨서 다른 방법을 시도합니다. PTVS 시작: Visual Studio 설정 출처 https://msdn.microsoft.com/ko-kr/library/dn705847.aspx","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"Visual","slug":"Visual","permalink":"http://jacegem.github.io/blog/tags/Visual/"},{"name":"Studio","slug":"Studio","permalink":"http://jacegem.github.io/blog/tags/Studio/"}]},{"title":"버추얼박스에서 브리지끼리 통신하기","slug":"2017/virtualbox-bridge","date":"2017-04-05T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/virtualbox-bridge/","link":"","permalink":"http://jacegem.github.io/blog/2017/virtualbox-bridge/","excerpt":"","text":"버추얼박스에서 브리지끼리 통신하기 VirtualBox Bridge to Bridge VM ↔ Host VM1 ↔ VM2 VM → Internet VM ← Internet Host-only + + – – Internal – + – – Bridged + + + + NAT – – + Port forwarding NAT Network – + + Port forwarding + 를 통신이 되는 것을 나타냅니다. -는 통신 불가능입니다. VM 이 Bridge 상태에서 서로 통신을 하기 위해서는 서로 다른 어뎁터를 사용해야 합니다. 1번 서버는 어뎁터1을 사용 2번 서버는 어뎁터2를 사용 출처 https://www.virtualbox.org/manual/ch06.html","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"VM","slug":"Application/VM","permalink":"http://jacegem.github.io/blog/categories/Application/VM/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"model","slug":"model","permalink":"http://jacegem.github.io/blog/tags/model/"}]},{"title":"v-model 한글 처리","slug":"2017/v-model-hangul-problem","date":"2017-04-04T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/v-model-hangul-problem/","link":"","permalink":"http://jacegem.github.io/blog/2017/v-model-hangul-problem/","excerpt":"","text":"v-model 한글 처리 v-model 사용시 한글을 정상적으로 처리되지 않는다. v-model의 한글 사용 문제을 v-on을 사용한 해결법 - @kciter v-model 사용시 한글 사용 문제 - @kciter v-on을 사용하여 해결하여야 함. HTML 에 v-on:input=&quot;typing&quot;을 추가함 1&lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;text&quot; v-on:input=&quot;typing&quot; v-model=&quot;text&quot; placeholder=&quot;검색어를 입력하세요&quot;&gt; typing 메소드를 추가함. 12345methods: &#123; typing: function(e)&#123; this.text = e.target.value &#125;,&#125; ajax.post 사용시 파라미터 전달 this.$http.post() 사용시에 파라미터가 전달되지 않는다. 아래 내용을 추가한다. 123456new Vue(&#123; http: &#123; emulateJSON: true, emulateHTTP: true &#125;&#125;) 출처 https://vuejs-kr.github.io/snippets/ https://jsfiddle.net/kciter/tLz9gt4o/ https://jsfiddle.net/kciter/tLz9gt4o/ https://github.com/pagekit/vue-resource/blob/develop/docs/http.md https://laracasts.com/discuss/channels/vue/vue-resource-post-request-no-data","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"model","slug":"model","permalink":"http://jacegem.github.io/blog/tags/model/"}]},{"title":"책. Two Scoops of Django (모범 사례로 배우는 Django(장고) 테크닉)","slug":"2017/two-scoops-of-django","date":"2017-04-03T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/two-scoops-of-django/","link":"","permalink":"http://jacegem.github.io/blog/2017/two-scoops-of-django/","excerpt":"","text":"책. Two Scoops of Django (모범 사례로 배우는 Django(장고) 테크닉) 모범 사례로 배우는 Django(장고) 테크닉 (대니얼 로이 그린펠드 · 오드리 로이 그릴펠드 지음 / 김승진 옮김 / 프로그래밍인사이트) settings와 requirements 파일 우리가 생각하는 최선의 장고 설정 방법 버전 컨트롤 시스템으로 모든 설정 파일을 관리해야 한다. 반복되는 설정들을 없애야 한다. 암호나 비밀 키 등은 안전하게 보관해야 한다. http://2scoops.co/the-best-and-worst-of-django settings/local.py 세팅 파일을 이용하여 장고/파이썬 셸 시작 12python manage.py shell --settings=twoscoops.settings.localpython manage.py runserver --settings=twoscoops.settings.local 장고에서 모델 이용하기 장고는 세 가지 모델 상속 방법을 제공한다. 추상화 기초 클래스(abstract base class) 멀티테이블 상속(multitable inheritance) 프락시 모델(proxy model) 멀티테이블 상속은 피하자 접합 상속(concrete inheritance)이라고도 부르는 멀티테이블 상속은 가능한 이용하지 않기를 권한다. 모델에서 null=True 와 blank=True 옵션을 이용할 때는 애매한 부분을 주의하기 바란다. 쿼리와 데이터베이스 레이어 쿼리 표현식 123from django.db.models import Ffrom models.customers import Customercustomers = Customer.objects.filter(scoops_ordered__gt=F(&#x27;store_visits&#x27;)) 내부적으로 장고는 다음과 같은 코드를 실행한다. 1SELECT * from customers_customer where scoops_ordered &gt; store_visits 쿼리 표현식이 프로젝트의 안전성과 성능을 대폭 향상시켜 줄 것이다. https://docs.djangoproject.com/en/1.8/ref/models/expressions 데이터베이스 함수들 https://docs.djangoproject.com/en/1.8/ref/models/database-functions 필요에 따라 인덱스를 이용하자. 인덱스가 빈번하게(모든 쿼리의 10~25% 사이에서서 이용될 때 실제 데이터 또는 실제와 비슷한 데이터가 존재해서 인덱싱 결과에 대한 분석이 가능할 때 인덱싱을 통해 성능이 향상되는지 테스트할 수 있을 때 PostgreSQL을 이용할 때 pg_stat_activity는 실제로 어떤 인덱스들이 이용되는지 알려준다. 명시적인 트랜잭션 선언 데이터베이스에 변경이 생기지 않는 데이터베이스 작업은 트랜잭션으로 처리하지 않는다. 데이터베이스에 변경이 생기는 데이터베이스 작업은 반드시 트랜잭션으로 처리한다. 데이터베이스 읽기 작업을 수반하는 데이터베이스 변경 작업 또는 데이터베이스 성능에 관련된 특별한 경우에는 앞의 두 가이드라인을 모두 고려한다. 목적 ORM 매서드 트랜잭션을 이용할 것인가 데이터 생성 .create(), .bulk_create(), .get_or_create() ✔️ 데이터 가져오기 .get(), .filter(), .count(), .iterate(), .exists(), .exclude() 데이터 수정하기 .update() ✔️ 데이터 지우기 .delete() ✔️ 장고 ORM 트랜잭션 관련 자료 https://docs.djangoproject.com/en/1.8/topics/db/transactions https://realpython.com/blog/python/transaction-management-with-django-1-6 함수 기반 뷰와 클래스 기반 뷰 장고 1.8은 함수 기반 뷰(function-based view, FBV) 클래스 기반 뷰(class-based view, CBV) 둘 다 지원한다. 뷰의 기본 형태들 1234567891011121314# simplest_views.pyfrom django.http import HttpResponsefrom django.views.generic import View# 함수 기반 뷰의 기본 형태def simplest_view(request): # 비즈니스 로직이 여기에 위치한다. return HttpResponse(&quot;FBV&quot;)# 클래스 기반 뷰의 기본 형태class SimpleView(View): def get(self, request, *args, **kargs): # 비즈니스 로직이 여기에 위치한다. return HttpResponse(&quot;CBV&quot;) 왜 이 기본 형태가 중요한가? 종종 우리에게 한 기능만 따로 떼어 놓은 관점이 필요할 때가 있다. 가장 단순한 형태로 된 기본 장고의 뷰를 이해했다는 것은 장고 뷰의 역할을 명확히 이해했다는 것이다. 장고의 함수 기반 뷰는 HTTP 메서드에 중립적이지만, 클래스 기반 뷰의 경우 HTTP 메서드의 선언이 필요하다는 것을 설명해 준다. 함수 기반 뷰의 모범적인 이용 함수 기반 뷰의 장점 뷰 코드는 작을수록 좋다. 뷰에서 절대 코드를 반복해서 사용하지 말자 뷰는 프레젠테이션(presentation) 로직을 처리해야 한다. 비즈니스 로직은 가능한 한 모델 로직에 적용시키고 만약 해야 한다면 폼 안에 내재시켜야 한다. 뷰를 가능한 단순하게 유지하자. 403, 404, 500을 처리하는 커스텀 코드를 쓰는 데 이용하라. 복잡하게 중첩된 if 블록 구문을 피하자 데코레이터에 대한 더 많은 자료들 http://2scoops.co/decorators-explained http://2scoops.co/decorators-functional-python http://2scoops.co/decorator-cheatsheet 클래스 기반 뷰의 모범적인 이용 클래스 기반 뷰를 이용할 때의 가이드라인 뷰 코드의 양은 적으면 적을수록 좋다. 뷰 안에서 같은 코드를 반복적으로 이용하지 말자. 뷰는 프레젠테이션 로직에서 관리하도록 하자. 비즈니스 로직은 모델에서 처리하자. 매우 특별한 경우에는 폼에서 처리하자. 뷰는 간단 명료해야 한다. 403, 404, 500 에러 핸들링에 클래스 기반 뷰는 이용하지 않는다. 대신 함수 기반 뷰를 이용하자. 믹스인은 간단 명료해야 한다. 어떤 장고 제네릭 클래스 기반 뷰를 어떤 태스크에 이용할 것인가? 장고 폼의 기초 폼 패턴들 유용한 폼 관련 패키지들 django-floppyforms: 장고 폼을 HTML5로 렌더링해 준다. django-crispy-forms: 폼 레이아웃의 고급 기능들. 폼을 트위터의 부트스트랩 폼 엘리먼트와 스타일로 보여준다. django-floppyforms와 함께 쓰기 좋아서 빈번하게 함께 쓰인다. REST API 구현하기 개발자들은 AJAX와 모바일 앱을 지원해야 하며 JSON, YAML, XML을 포함한 여러 형식을 지원해야 하는 일이 큰 과제가 되었다. REST(representational state transfer) API는 다양한 환경과 용도에 맞는 데이터를 제공하는 디자인을 정의하고 있다. 패키지 API를 제작하기 위한 패키지들 django-rest-framework 는 장고의 기본 클래스 기반 뷰를 바탕으로 브라우징이 가능한 편리한 API 기능 등을 제공한다. django-tastypie는 자체적으로 구현된 클래스 기반 뷰 시스템을 제공하는 안정된 도구다. 매우 단순하고 빠르게 REST API를 제작하고 싶다면 django-braces(클래스 기반 뷰)와 django-jsonview(함수 기반 뷰)가 좋은 대안이 된다. 다만 이 도구들은 API를 제작하는데만 중점을 두고 있지는 않기 때문에 HTTP 메서드의 모든 기능을 다 이용한다거나 복잡한 디자인을 구현해야 할 때 문제가 생길 것이다. 비즈니스 계획으로서의 접속 제한 개발자(Developer) 단계는 무료로 서비스되지만 시간당 10 API 요청만 가능 한 숟갈(One Scoop) 24달러, 분당 25요청 두 숟갈(Two Scoops) 79달러, 분당 50요청 기업(Corporate) 5000달러, 분당 200요청 장고의 어드민 문서 생성기 1pip install docutils 12345INSTALLED_APPS = [ ... &#x27;django.contrib.admindocs&#x27;, ...] 1234urlpatterns = [ url(r&#x27;^admin/doc/&#x27;, include(&#x27;django.contrib.admindocs.urls&#x27;)), ...] 이후 /admin/doc으로 가서 문서들을 살펴볼 수 있다. 장고의 비법 소스: 서드 파트 패키지들 장고의 진정한 강력함은 바로 빠르게 성장하고 있는 오픈 소스 커뮤니티에서 제공하는 파이썬 패키지와 서드 파티 장고 패키지들이다. 패키지들 코어 Django (htts://djangoproject.com) 데드라인이 있는 완벽주의자를 위한 웹 프레임워크 django-debug-toolbar (http://django-debug-toolbar.readthedocs.org) 장고 디버깅을 위한 디스플레이 패널 django-model-utils (https://pypi.python.org/pypi/django-model-utils) 시계열 모델(time stamped model)을 포함한 유용한 모델 유틸리티 ipdb (https://pypi.python.org/pypi/ipdb) IPython을 이용할 수 있는 pdb Pillow (https://pypi.python.org/pypi/Pillow) 파이썬 이미지 라이브러리를 위한 편리한 설치 프로그램 pip (https://www.pip-installer.org) 파이썬 패키지 설치 프로그램. 파이썬 3.4 이상부터 파이썬에 내장되어 있다. Sphinx (http://sphinx-doc.org) 파이썬 프로젝트 문서화 도구 virtualenv (http://virtualenv.org) 파이썬 가상 환경 세팅 도구 virtualenvwrapper (http://www.doughellmann.com/projects/virtualenvwrapper) 맥 OS X과 리눅스에서 virtualenv를 좀 더 편리하게 쓰기 위한 도구 virtualenvwrapper-win (https://pypi.python.org/pypi/virtualenvwrapper-win) 윈도우에서 virtualenv를 좀 더 편리하게 쓰기 위한 도구 비동기 celery (http://www.celeryproject.org) 분산 태스크 큐 flower (https://pypi.python.org/pypi/flower) 셀러리 테스크 관리·모니터링 도구 rq (https://pypi.python.org/pypi/rq) 가벼우면서 간단한 백그라운드 작업 생성과 프로세싱 라이브러리 django-rq (https://pypi.python.org/pypi/django-rq) RQ(Redis Queue) 와 장고의 통합을 제공하는 간단한 앱 django-background-tasks (https://pypi.python.org/pypi/django-background-tasks) 데이터베이스 기반의 비동기 테스크 큐","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"django","slug":"django","permalink":"http://jacegem.github.io/blog/tags/django/"},{"name":"book","slug":"book","permalink":"http://jacegem.github.io/blog/tags/book/"}]},{"title":"책. 클린 코더","slug":"2017/클린-코더","date":"2017-04-02T10:13:45.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2017/클린-코더/","link":"","permalink":"http://jacegem.github.io/blog/2017/%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%8D%94/","excerpt":"","text":"책. 클린 코더 프로 소프트웨어 개발자라면 알아야 하는 최소한의 기술 목록 디자인 패턴 : 24가지 GOF 패턴을 설명할 수 있고, POSA 패턴을 실무에 적용할 수준으로 알아야 한다. 설계 원칙 : SOLID 객체지향 원칙을 알아야 하고 컴포넌트 개념을 충분히 이해해야 한다. 방법론 : XP, 스크럼, 린, 칸반, 폭포수, 구조적 분석, 구조적 설계 개념을 충분히 이해해야 한다. 원칙 : 테스트 주도 개발, 객체지향 설계, 구조적 프로그래밍, 지속적 통합, 짝 프로그래밍을 실천해야 한다. 도구 : UML, 데이터 흐름도(DFD), 구조 차트(Structure Chart), 페트리 넷(Petri Net), 상태 전이 다이어그램과 테이블(State Transition Diagram and Table), 흐름도(Flow Chart), 결정 테이블(Decision Table)을 어떻게 쓰는지 알아야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"ETC","slug":"Programming/ETC","permalink":"http://jacegem.github.io/blog/categories/Programming/ETC/"}],"tags":[{"name":"clean","slug":"clean","permalink":"http://jacegem.github.io/blog/tags/clean/"},{"name":"coder","slug":"coder","permalink":"http://jacegem.github.io/blog/tags/coder/"}]},{"title":"텐서플로 입문 (예제로 배우는 텐서플로)","slug":"2017/tensorflow-introduction","date":"2017-04-01T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/tensorflow-introduction/","link":"","permalink":"http://jacegem.github.io/blog/2017/tensorflow-introduction/","excerpt":"","text":"책.텐서플로 입문 (예제로 배우는 텐서플로) 머신러닝을 공부하고자 하는 학생은 유투브, 코세라, 에드엑스 등 동영상 강의를 통해 해외 유명 대학의 수업을 쉽게 접할 수 있다. 들어가며 텐서플로(Tensorflow)는 머신 러닝과 딥 러닝을 위해 만들어진 오픈소스 소프트웨어 라이브러리이다. 머신러닝 알고리즘 지도 학습 : 프로그래머가 컴퓨터에게 해야 할 행위를 가려쳐 줌 비지도 학습 : 모든 과정을 컴퓨터가 스스로 하도록 함 텐서플로의 프로그래밍적인 기능을 따루기 위해서는 먼저 파이썬 프로그램이 언어에 대해 알아둬야 한다. 이 책의 구성 1장, 텐서플로 기초 : 최적화와 디버깅에서 사용하는 텐서보드(TensorBoard) 2장, 텐서플로 기초 연산 : 자료 구조인 텐서(Tensor) 3장, 머신 러닝 시작 : 분류(Classification), 군집화(Clustering) 4장, 인공 신경망 소개 : 신경망(Neural Newtork), 단일 계층 퍼셉트론, 다중 계층 퍼셉트론 5장, 딥 러닝 : CNN(Convolutional Neural Network), RNN(Recurrent Neural Network) 6장, GPU 프로그래밍과 텐서플로 서빙 : GPU 연산 능력 이용 다운로드 예제 코드 : https://github.com/PacktPublishing/Getting-Started-with-TensorFlow 컬러 이미지 : http://www.acornpub.co.kr/book/tensorflow 텐서플로 : https://www.tensorflow.org 텐서플로 개요 주요 기능 다차원 배열(텐서)의 정의, 최적화, 효율적 산술 연산 딥 뉴럴 네트워크와 머신 러닝 프로그래밍 지원 메모리와 데이터가 자동으로 관리되는 쉬운 GPU 가속 기능 제공 별도의 코드를 작성하지 않아도 텐서플로가 자동으로 CPU와 GPU에 자원을 할당해 연산 빅데이터 처리를 위한 대규모 병렬 컴퓨팅 지원 파이썬 기초 강력한 형식 Strong Type 동적 언어 Dynamic Language 대소문자를 구별 객체지향 패러다임으로 작성된 언어 데이터 형식 리스트 list 튜플 tuple 딕셔너리 dict 클래스 파이썬은 다중 상속 클래스를 지원한다. 변수와 비공개private 메소드의 이름은 일반적으로 __(두 개의 언더스코어)를 접투어 및 접미어로 사용한다. 텐서플로 동작 확인 1pip install tensorflow 12345&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant(&#x27;hello Tensorflow!&#x27;)&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print(sess.run(hello))b&#x27;hello Tensorflow!&#x27; 12345678910&gt;&gt;&gt; x = tf.constant(1, name=&#x27;x&#x27;)&gt;&gt;&gt; y = tf.Variable(x+9, name=&#x27;y&#x27;)&gt;&gt;&gt; print(y)&lt;tf.Variable &#x27;y:0&#x27; shape=() dtype=int32_ref&gt;&gt;&gt;&gt; model = tf.global_variables_initializer()&gt;&gt;&gt; with tf.Session() as session:... session.run(model)... print(session.run(y))...10 데이터 플로우 그래프 대부분의 머신 러닝 알고리즘은 복잡한 산술식의 반복 연산으로 구성돼 있다. 텐서플로의 연산은 데이터 플로우 그래프로 구성되며, 데이터 플로우 그래프의 노드node는 산술 연산자(덧셈, 뺄셈, 곱셈, 나눗셈)이고, 에지edge는 텐서tensor라고 명명된 다중 다차원 데이터 집합을 의미하며 피연산자가 된다. jupyter 서버 설치 http://goodtogreate.tistory.com/entry/IPython-Notebook-설치방법 변경 소스 tf.initialize_all_variables() → tf.global_variables_initializer() tf.summary.merge_all → tf.summary.merge_all tf.train.SummaryWriter → tf.summary.FileWriter tf.complex_abs → tf.abs 텐서플로 기초 연산 텐서는 텐서플로의 기본 자료 구조다. 텐서는 데이터 플로우 그래프에서 에지를 연결한다. 텐서는 rank, shape, type, 세 가지의 매개변수로 구분된다. rank : 텐서의 차원은 rank로 나타낸다. shape : 텐서의 행과 열이 몇 개인지를 나타낸다. type : 텐서의 데이터가 어떤 형식인지를 나타낸다. 텐서플로 산술연자 tf.add tf.sub tf.mul tf.div tf.mod tf.abs tf.neg tf.sign tf.inv tf.square tf.round tf.sqrt tf.pow tf.exp tf.log tf.maximum tf.minimum tf.cos tf.sin 3장 머신 러닝 시작 경사 하강법 경사 하강법(Gradient Descent)을 이용해 cost_function 값을 최소화할 수 있다. 하지만 수학적인 특성으로 인해 경사 하강법은 대부분의 경우 전역 최솟값이 아닌 지역 최솟값에 머무르게 된다. 경사 하강법을 통해 비용 함수를 최소화하는 방법을 알아보자. 평가 : 함수의 정의역 내에서 임의의 값을 추출해 입력 값으로 사용한 후 결과 값에 대해 경사 하강법을 적용한다. 경사 하강법은 비용 함수가 최소화될 수 있는 경사로의 방향을 가리킨다. 선택 : 어느 방향의 경사를 따라갈 것인지를 선택해야 한다. 비용 함수 cost function 경사 하강 알고리즘 Gradient Descent Algorithm MNIST 데이터 다운로드와 스크립트 https://github.com/tensorflow/tensorflow/blob/master/tensorflow/examples/tutorials/mnist/input_data.py 1from tensorflow.contrib.learn.python.learn.datasets.mnist import read_data_sets 분류기 5장 딥러닝","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://jacegem.github.io/blog/tags/tensorflow/"},{"name":"book","slug":"book","permalink":"http://jacegem.github.io/blog/tags/book/"}]},{"title":"Visual Studio 2017 - python","slug":"2017/vscode-settings-sync","date":"2017-04-01T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/vscode-settings-sync/","link":"","permalink":"http://jacegem.github.io/blog/2017/vscode-settings-sync/","excerpt":"","text":"VSCode - Settings Sync github 으로 이동한다. Key Features Use your github account token and Gist. Can create Anonymous Gist without using your Github account token. Easy to Upload and Download on one click. Show a summary page at the end with details about config and extensions effected. Auto Download Latest Settings on Startup. Auto upload Settings on file change. Share the Gist with other users and let them download your settings. Supports GitHub Enterprise","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"Visual","slug":"Visual","permalink":"http://jacegem.github.io/blog/tags/Visual/"},{"name":"Studio","slug":"Studio","permalink":"http://jacegem.github.io/blog/tags/Studio/"}]},{"title":"Synology 에서 django 실행하기","slug":"2016/synology-django","date":"2017-03-08T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/synology-django/","link":"","permalink":"http://jacegem.github.io/blog/2016/synology-django/","excerpt":"","text":"Synology 에서 django 실행하기 ssh 로 synology에 접속합니다. root 로 접속합니다. 다른 계정으로 접속하였다면 sudo su -를 실행하여 root로 변경합니다. python3.5를 사용하기 위해 위치를 확인해 봅니다. 12root@syn:~# which python3.5/usr/local/bin/python3.5 pip 를 설치하기 위한 파일을 다운로드 합니다. 1wget https://bootstrap.pypa.io/get-pip.py pip 를 설치합니다. 1python3.5 get-pip.py python이 설치된 위치를 확인합니다. 12root@syn:/usr/local/bin# ls -al python3.5lrwxrwxrwx 1 root root 47 Mar 1 22:32 python3.5 -&gt; /volume2/@appstore/py3k/usr/local/bin/python3.5 디렉토리 이동을 합니다. 1&gt; cd /volume2/@appstore/py3k/usr/local/bin django 를 설치합니다. 123456&gt; pip install djangoCollecting django Using cached Django-1.10.6-py2.py3-none-any.whlInstalling collected packages: djangoSuccessfully installed django-1.10.6 버전 확인 123&gt; python -m django --version1.10.6 django-admin 를 설치합니다. 1&gt; pip install django-admin 프로젝트를 생성합니다. 1&gt; django-admin startproject mysite django를 실행합니다. 12&gt; cd mysite&gt; python manage.py runserver 0.0.0.0:9000 이후, django 사용법은 이곳에서 확인할 수 있습니다. 출처 https://forum.synology.com/enu/viewtopic.php?t=59837 https://docs.djangoproject.com/en/1.10/intro/tutorial01/","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"NAS","slug":"Application/NAS","permalink":"http://jacegem.github.io/blog/categories/Application/NAS/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"synology","slug":"synology","permalink":"http://jacegem.github.io/blog/tags/synology/"},{"name":"django","slug":"django","permalink":"http://jacegem.github.io/blog/tags/django/"}]},{"title":"Synology에서 자동 다운로드된 디렉토리 삭제","slug":"2016/synology-delete-directory","date":"2017-03-07T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/synology-delete-directory/","link":"","permalink":"http://jacegem.github.io/blog/2016/synology-delete-directory/","excerpt":"","text":"Synology에서 자동 다운로드된 디렉토리 삭제 사용하고 있는 삭제 스케쥴에, 빈 디렉토리를 지우는 명령어를 추가합니다. 1234567# delete old filesfind /volume2/video/ -mtime +1000 -exec rm &#123;&#125; \\;find &quot;/volume2/video/예능&quot; -mtime +60 -exec rm &#123;&#125; \\;find &quot;/volume2/video/다큐&quot; -mtime +90 -exec rm &#123;&#125; \\;# 빈 디렉토리 삭제find /volume2/video/ -empty -type d -delete 출처 https://askubuntu.com/questions/73709/how-do-i-delete-all-empty-directories-in-a-directory-from-the-command-line","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"NAS","slug":"Application/NAS","permalink":"http://jacegem.github.io/blog/categories/Application/NAS/"}],"tags":[{"name":"synology","slug":"synology","permalink":"http://jacegem.github.io/blog/tags/synology/"},{"name":"디렉토리","slug":"디렉토리","permalink":"http://jacegem.github.io/blog/tags/%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC/"},{"name":"삭제","slug":"삭제","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AD%EC%A0%9C/"}]},{"title":"스타트업 투자 환경 및 노하우","slug":"2016/startup-knowhow","date":"2017-03-06T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/startup-knowhow/","link":"","permalink":"http://jacegem.github.io/blog/2016/startup-knowhow/","excerpt":"","text":"스타트업 투자 환경 및 노하우 10분 스타트업 Coway Wi School에서 진행한 10강 스타트업 투자 환경 및 노하우 내용을 정리합니다. 경쟁자에게서 배운다 다른 산업군의 누군가는 더 생각해 보았을 수 있다. 다른 산업군의 아이디어를 가져온다. 문제를 해결하기 이해 창업을 한다. 문제인식 → 해결책 검토(벤치마킹) → 솔루션 도출 제품과 서비스에만 집중하기보다 전반적인 프로세스를 염두에 두고 벤치마킹 한다. 벤치마킹할 기업 리스트를 정한다. 한계점을 확인한다. VC가 바라보는 창업 이야기 내가 원하는 바를 명확하게 지속 가능한 분야를 찾고 우직하게 한 방은 없다. 대박 또한 없다. 어떤 아이템을 선정해야 할까 내가 즐길 수 있는 아이템 내가 잘 할 수 있는 아이템 세상이 필요로 하는 아이템 아이템에 대한 확신이 있어야 함. 나는 계속 이 곳에 있어야 할까? 장점 보람 : 내가 무엇인가를 직접 만들어서 세상에 내보이고, 그것이 동작하는 것을 볼 때의 즐거움 향후 발생할 것으로 기대되는 보상 : 내가 가지고 있는 지분 똔느 스톡옵션이 가져다 줄 경제적 보상 성장 : 도전적인 일을 하면서 내적/외적으로 성장하고 있다는 느낌 단점 시간적 여유 : 항상 일이 많고, 그것에 집중하기 때문에 시간적 여유가 다른 직업을 가지는 것보다 적을 수 있음 적은 경제적 소득 불확실한 미래 : 미래가 쉽게 예측이 되지 않음 MVP(최소요건제품)을 통한 증명 MVP(minimum viable product) 최소 기능 제품(Minimum Viable Product, MVP)는 고객의 피드백을 받아 최소한의 기능(features)을 구현한 제품이다. 초기의 MVP는 파워포인트 슬라이드, 비디오, 데모와 같이 단순한 표현으로 정의 될 수 있다. 사업계획서 작성 및 투자유치 전략 사업계획서 작성에 필요한 형식 요건 시장에서의 기회 문제 발견 해결책 비즈니스 모델 운영 계획 재무 계획 팀 구성 시장에서의 기회 하고자 한느 분야의 시장에 대한 이해는 필수. 창업자의 시각으로 살펴본 시장에서의 기회를 이야기하는 것이 중요. 시장 분석 뛰어들고자 하는 시장에 대한 기초 분석 시장의 크기, 주요 player 들은 누가 있는지, 어떤 Value chain을 가지고 시장이 움직이는지 최근의 시장 이슈는 무엇이 있는지 시장의 성장성 이 시장의 크기는 어떻게 변해가고 있는지 시장의 성장을 이끄는 동력은 무엇인지, 이것이 앞으로는 어떻게 될 것으로 생각하는지 우리가 목표로 삼고 있는 진짜 시장의 크기 위에서 분석한 전체 시장의 크기가 회사가 목표할 수 있는지 정확하게 파악할 필요가 있음 시장을 더 세분화하여 현실적인 목표를 설정할 필요가 있음 레저 티켓을 중개해서 판매하는 진짜 시장의 크기는 레저시장의 크기가 아닌 레저 시장 크기 X 온라인 판매율 X 수수료 이 곳에서 어떤 기회가 있는가 시장을 바라보는 차업자의 시각이 가장 잘 드러나는 부분 뉴스나 보고서에서 이야기하는 것이 아닌 본인의 생각을 잘 정리하여 기회를 포착하여야 함 문제 발견 핵심 고객 및 그들이 가진 문제점과 충족되지 않은 needs에 관하여 작성 문제의 제시 원래 있어야 하는 것인데, 아직까지 없다. 그것이 있긴 있는데, 많이 부족하다. 문제의 검증 사람들이 필요로 하기 때문. 여러 사람들에게 물어보니, 이런 것이 있으면 구입하고자 하는 의사가 진짜 있더라 내가 이 쪽 분야에서 10년 간 일했는데, 이런게 있으면 대박일 것이다. 현재 서비스를 제공하고 있는 다른 업체들이 있는데, 이러이러한 것들이 많이 부족하다. 어떤 것을 문제라고 생각하는가 해결책 위에서 언급한 문제에 대한 해결책에 대한 소개. 이는 제품이 될 수도 있고 서비스가 될 수도 있음 해결책에 대한 투자자의 관점 투자자들은 회사가 가지고 온 해결책 자체에 대해서 기본적으로 크게 점수를 주는 것은 아님. 성공하는 회사의 해결책이 뛰어난 것이 아니라 그들의 실행력이 뛰어난 것임 MVP(Minimum Viable Product)의 중요성 MVP는 회사의 해결책이 가지고 있는 두 가지 불확실성을 해결해 주는 가장 좋은 방식 이것이 정말 가능한 해결책인가 이 팀이 그러한 실행력이 있는가 완벽하지 않더라도 좋음 MVP는 회사가 가고자 하는 방향의 자식확신을 위해서라도 꼭 필요함 최대한 빠르게 시도하고 그곳에서 배움을 얻는 것이 좋음 어떤 시간내에 어떤 변화가 가능한가 비즈니스 모델 위의 문제를 해결함으로써 어떻게 수익을 창출할 수 있을지에 대한 흐름을 도식화함 운영 계획 해결책을 실행하기 위한 실질적인 계획 수립. 현재까지의 성과와 앞으로의 계획와 이를 통해 검증해보려고 하는 가설까지 함께 있으면 좋음 마일스톤의 설정 사업의 주요 요소들에 대한 목표 미션/고객 수 매출 인력 운영 제품/서비스 개발 마케팅/영업 기타 일정 주요 목표를 실행하는데 있어서 연/분기/월 등으로 구분하여 일정을 정리 주요 마일스톤의 우선순위도 고려하여 정리 재무 계획 위의 계획을 실현하기 위해 필요한 금액과 향후 매출/비용 흐름에 대한 예측까지 함께 작성 현금 흐름 및 자산현황 매출을 발생하지 않다러도 각 시점에서 현금 현황과 자산 현황은 예측할 필요가 있음 이를 통해 사업을 영위하기 위해 필요한 자본이 어느 정도인지 가늠할 수 있음 만약 물건을 사 둔다면, 그러한 자산 현황도 마찬 가지로 파악해둘 필요가 있음 팀 구성 실제로 계획을 실현하기 위해 적절한 역량을 가진 팀으로 구성되었는지 확인 대표이사 기술담당 운영담당 홍보담당 대표이사는 모든 영역을 넓게 알아야 함. 가징 중요한 것은 해결책과 팀구성 투자자들은 누구인가 3F (Family, Friend, Fool) Angel Venture Capital 가치 평가 및 주요 조항들 Pre-valuation 투자금 Postvaluation 상황권 투자한 투자금을 투자자가 원하는 시점에 상환해야 하는 조항 보통 충분한 이익잉여(accumulated profits)가 있어야 하지만, 회사를 팔게 하거나 상환에 대한 연대책임을 걸 수도 있으니 주의 깊게 살펴보아야 함 동반매수 청구권 Tag-along Right. 만약 창업자들이 자신의 지분 일부 혹은 전부를 매각하고자 할 때, 투자자는 자신의 지분을 매각할 수 있도록 한 조항. 이 조항이 있음으로해서 창업자의 주식을 매각하는 행위를 포괄적으로 금지하는 효과를 가짐 동반매각 청구권 Drag-along Right. 외부에서 회사를 인수하고자 하는 의사를 전달한 상황에서 투자자와 창업가의 의견이 갈리는 경우, 투자자가 창업가의 주식을 팔 수 있도록 강제하는 조항","categories":[{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"Startup","slug":"Conference/Startup","permalink":"http://jacegem.github.io/blog/categories/Conference/Startup/"}],"tags":[{"name":"startup","slug":"startup","permalink":"http://jacegem.github.io/blog/tags/startup/"},{"name":"스타트업","slug":"스타트업","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"},{"name":"투자","slug":"투자","permalink":"http://jacegem.github.io/blog/tags/%ED%88%AC%EC%9E%90/"},{"name":"노하우","slug":"노하우","permalink":"http://jacegem.github.io/blog/tags/%EB%85%B8%ED%95%98%EC%9A%B0/"}]},{"title":"Run Python as a Windows Service","slug":"2016/run-python-windows-service","date":"2017-03-05T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/run-python-windows-service/","link":"","permalink":"http://jacegem.github.io/blog/2016/run-python-windows-service/","excerpt":"","text":"Run Python as a Windows Service 단순하게 sc.exe 를 사용한다. 샘플코드인데 1sc create PythonApp binPath= &quot;C:\\Python34\\Python.exe --C:\\tmp\\pythonscript.py&quot; -- 이것이 왜 있는거지…??? 빼고 서비스를 생성해보자. 1sc create django binpath= &quot;%py32% %conoha%\\system-trading-django\\twisted_run.tac&quot; start= &quot;auto&quot; %py32%, %conoha% 는 시스템 변수로 등록해 놓았다. 중요한 것은 binpath= 뒤에 공백한칸이 있는 것이다. 모든 = 뒤에는 공백이 있어야 한다. 출처 http://stackoverflow.com/questions/32404/is-it-possible-to-run-a-python-script-as-a-service-in-windows-if-possible-how","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"windows","slug":"windows","permalink":"http://jacegem.github.io/blog/tags/windows/"},{"name":"service","slug":"service","permalink":"http://jacegem.github.io/blog/tags/service/"}]},{"title":"react.js","slug":"2016/reactjs","date":"2017-03-04T15:00:00.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/reactjs/","link":"","permalink":"http://jacegem.github.io/blog/2016/reactjs/","excerpt":"","text":"react.js 문서강좌: https://velopert.com/reactjs-tutorials 동영상: https://www.inflearn.com/course/react-강좌-velopert/?subscribe ReactJS &amp; [[Express]] React Fundamentals [[Express]] [[ES6]] MongoDB mongoose Virtual DOM DOM(Document Object Model) Redux, Webpack React.js 소개 atom 에디터, slack agility.js, angular.js, aria temmplates, backbone.js, batman.js, bolt, canjs, chaplin + brunch, closure, cujo.js, dart, derby, dermis, dijon, dojo, due, ember.js, epitome, ext.js, funnyface.js, gwt, kendo ui, knockback.js, knockoutjs, maria, marionette, meteor, montage, olives, plastrongjs, puremvc, rappid.js, sammy.js, serenade.js, socketstream, soma.js, spine, stapes, yui 또 다른 프레임워크/ 프레임워크가 아닌 라이브러리 frame; 틀 “A Javascript Library for Building User Interface” Reactive Native Angular2 Native Virtual DOM (가상 돔) React.js 장점과 단점 React 의 장점? Virtual Dom 사용. 배우기 간단하다. 단 하나를 사용한다. Component 뛰어난 Garbage Collection, 메모리 관리, 성능 서버 &amp; 클라이언트 렌더링 초기 구동 딜레이 &amp; SEO(검색엔진최적화) 매우 간편한 UI 수정 및 재사용(컴포넌트화) 페이스북이 밀어준다. php CodeIgniter 의 몰락, 인기 laravel 강좌로 돌아가기 velopert(김 민준)의 프로필 사진강사 VELOPERT(김 민준) 9 분 React.js 장점과 단점 Links: http://slides.com/minjunkim-1/deck (강의에서 사용되는 슬라이드) https://velopert.com/reactjs-tutorials (React.js 텍스트 강좌 목록) http://incleaf.github.io/react-settin… (IE8 이하 브라우저 지원) 다른 프레임워크나 라이브러리와 혼용가능 React 의 단점 View Only. IE8 이하 지원 X 섹션 2. REACT.JS 시작하기 CODEPEN 설정. ES6 클래스 강좌로 돌아가기 velopert(김 민준)의 프로필 사진강사 VELOPERT(김 민준) 4 분 Codepen 설정 , ES6 클래스 2편 강좌부터는 React.js를 직접 사용해볼텐데요, 기초개념을 배우는 과정에서 환경설정을 편하게 하기 위해 Codepen.io 라는 웹 서비스를 사용합니다. 우리가 첫 컴포넌트를 만들어볼텐데, 만들기전에 ES6의 새로운 문법인 class 에 대해서도 간단하게 짚고 넘어갑시다 Links: http://slides.com/minjunkim-1/deck (강의에서 사용되는 슬라이드) https://codepen.io/pen/ (코드펜) http://kangax.github.io/compat-table/… (런타임별 ES6 호환률) https://developer.mozilla.org/ko/docs… (JavaScript 클래스) https://velopert.com/reactjs-tutorials (React.js 텍스트 강좌 목록) Codepen.io 환경 설정. Babel ES6 사용. ES5 로 변환. 여러 브라우저 호환 react.min.js react.dom.min.js 15버전 이상부터 분리됨 ES6에 새로 도입된 문법 class JSX 의 특징 123456789101112131415161718class Codelab extends React.Component&#123; render()&#123; return( &lt;div&gt;CodeLab&lt;/div&gt; ) &#125;&#125;class App extends React.Compoent&#123; render()&#123; return ( &lt;Codelab/&gt; ) &#125;&#125;ReactDOM.render(&lt;App/&gt;.document.getElementById(&quot;root&quot;)); 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 자바스크립트에서 HTML 형식 문법을 사용할 수 있다. babel 에서 jsx 로더를 사용하여 변환해 준다. let 은 블록 범위 Javascript Expression Inline Style Comments 멀티라인 주석을 사용한다. props Links: http://slides.com/minjunkim-1/deck#/11 (강의에서 사용되는 슬라이드) https://facebook.github.io/react/docs… (React PropTypes) https://velopert.com/reactjs-tutorials (React.js 텍스트 강좌 목록) 컴포넌트 내부의 Immutable Data JSX 내부에 {this.props.propsName} 컴포넌트를 사용 할 때, &lt;&gt; 괄호 안에 propsName=“value” this.props.children은 기본적으로 갖고 있는 props로서, 여기에 있는 값이 들어간다. 1234&lt;div&gt; &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt; &lt;div&gt;&#123;this.props.children&#125;&lt;/div&gt;&lt;/div&gt; 기본 값 설정 Componet.defaultProps={…} 1234567891011class App extends React.Compoent&#123; render()&#123; return ( &lt;div&gt;&#123;this.props.value&#125;&lt;/div&gt; ) &#125;&#125;App.defaultProps = &#123; value: 0&#125; Type 검증 Componet.propType = {…} 12345678910111213141516171819class App extends React.Componet&#123; render()&#123; return ( &lt;div&gt; &#123;this.props.value&#125; &#123;this.props.secondValue&#125; &#123;this.props.thirdValue&#125; &lt;/div&gt; ) &#125;&#125;App.propTypes = &#123; value: React.PropTypes.string, secondValue: React.PropType.number, thirdValue: React.PropTypes.andy.isRequired&#125; 적용하기 min 버전은 에러가 뜨지 않는다. state Links: http://slides.com/minjunkim-1/deck#/10 (강의에서 사용되는 슬라이드) http://bit.ly/ReactCodePen (코드펜 새 React 프로젝트) https://velopert.com/867 (JSX 텍스트 강좌) 유동적인 데이터 JSX 내부에 {this.state.stateName} 최기값 설정이 필수, 생성자(constructor)에서 this.state={} 으로 설정 값을 수정 할 때에는 this.setState({…}), 렌더링 된 다음엔 this.state = 절대 사용하지 말것 기본값을 설정하지 않으면, 에러가 발생함. 1234567891011121314151617class Counter extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; value:0 &#125; &#125; render()&#123; return( &lt;div&gt; &lt;h2&gt;&#123;this.state.value&#125;&lt;/h2&gt; &lt;button&gt;Press Me&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 컴포넌트 매핑(Component Mapping) 비슷한 코드를 반복해서 렌더링 JavaScript - map 1arr.map(callback, [thisArg]) callback 새로운 배열의 요소를 생성하는 함수로서, 다음 세가지 인수를 가집니다. currentValue 현재 처리되고 있는 요소 index 현재 처리되고 있는 요소의 index 값 array 메소드가 불려진 배열 thisArg (선택항목) callback 함수 내부에서 사용 할 this 값을 설정 123456/* ES6 Syntax */let numbers = [1,2,3,4,5];let result = numbers.map((num)=&gt;&#123; return num*num;&#125;) arrow function(…) =&gt; {…} 컴포넌트 매핑 Links: http://slides.com/minjunkim-1/deck/#/12 (강의에서 사용되는 슬라이드) http://bit.ly/ReactCodePen (코드펜 새 React 프로젝트) http://codepen.io/velopert/pen/JKxKay (컴포넌트 매핑 예제 코드) https://developer.mozilla.org/ko/docs… (자바스크립트 배열의 Map 메소드) https://developer.mozilla.org/en-US/d… (자바스크립트 Arrow function) http://es6console.com/ (ES6 – ES5 변환) 12345678910111213141516171819202122232425262728293031323334353637class ContactInfo extends React.Component&#123; render()&#123; return ( &lt;div&gt;&#123;this.props.contact.name&#125; &#123;this.props.contact.phone&#125;&lt;/div&gt; ) &#125;&#125;class Contact extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; contactData : &#123; &#123;name:&#x27;Abet&#x27;, phone:&#x27;010-0000-2222&#x27;&#125;, &#123;name:&#x27;Bbet&#x27;, phone:&#x27;010-0000-2222&#x27;&#125;, &#123;name:&#x27;Cbet&#x27;, phone:&#x27;010-0000-2222&#x27;&#125; &#125; &#125; &#125; render()&#123; const mapToComponet = (data) =&gt; &#123; return data.map((contact, i) =&gt; &#123; return ( &lt;ContactInfo contact =&#123;contact&#125; key=&#123;i&#125; /&gt;; ) &#125;) &#125;; return ( &lt;div&gt; &lt;div&gt;Abet 010-0000-2222&lt;/div&gt; &lt;div&gt;Bbet 010-0000-2222&lt;/div&gt; &lt;div&gt;Cbet 010-0000-2222&lt;/div&gt; &lt;/div&gt; ) &#125;&#125; const 변할일이 없는 값을 지정 12345return( &lt;div&gt; &#123;mapToComponent(this.state.contactData)&#125; &lt;/div&gt;) 섹션 3. 개발환경 설정, 프로젝트 진행 작업환경 설정하기 https://www.nitrous.io/ c9.io groom.io codeanywhere.com React Project 만들기 Links: http://slides.com/minjunkim-1/deck#/13/1 React Project 만들기 텍스트 강좌: https://velopert.com/814 React 텍스트 강좌 목록: https://velopert.com/reactjs-tutorials 12345c:\\&gt;git --versiongit version 2.10.1.windows.1c:\\&gt;node -vv6.9.1 Global Dependency 설치 1sudo npm install -g webpack webpack-dev-server webpack: 브라우저 위에서 import(require)를 할 수 있게 해주고 자바스크립트 파일들을 하나로 합쳐줍니다. webpack-dev-server: 별도의 서버를 구축하지 않고도 static 파일을 다루는 웹서버를 열 수 있으며 hot-loader 를 통하여 코드가 수정 될 때마다 자동으로 리로드 되게 할 수 있습니다. 프로젝트 생성 123mkdir react-fundamentalscd react-fundamentaslnpm init 생활코딩 nodejs","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"react.js","slug":"react-js","permalink":"http://jacegem.github.io/blog/tags/react-js/"},{"name":"react","slug":"react","permalink":"http://jacegem.github.io/blog/tags/react/"}]},{"title":"React 공부하면서 도움되었던 글들모음","slug":"2016/React-공부하면서-도움되었던-글들모음","date":"2017-03-03T15:00:00.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/React-공부하면서-도움되었던-글들모음/","link":"","permalink":"http://jacegem.github.io/blog/2016/React-%EA%B3%B5%EB%B6%80%ED%95%98%EB%A9%B4%EC%84%9C-%EB%8F%84%EC%9B%80%EB%90%98%EC%97%88%EB%8D%98-%EA%B8%80%EB%93%A4%EB%AA%A8%EC%9D%8C/","excerpt":"","text":"React 공부하면서 도움되었던 글들모음 출처: http://witinweb.com/post/144650892442/react-공부하면서-도움되었던-글들모음 리액트 시작해보기 React 시작하기 ES2015와 React 재사용 UI컴포넌트 설계 React.js의 데이터 흐름 FLUX와 REDUX Redux 공식홈페이지(한글) Redux로의 카툰안내서 핫 리로딩(hot reloading)과 시간 여행 디버깅(time travel debugging)이 도대체 무엇일까? Redux 와 Webpack 을 사용할 때 알아두면 도움이 될 9 가지","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"React","slug":"React","permalink":"http://jacegem.github.io/blog/tags/React/"},{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"}]},{"title":"Postgresql 버전 확인","slug":"2016/postgresql-version","date":"2017-03-02T15:00:00.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/postgresql-version/","link":"","permalink":"http://jacegem.github.io/blog/2016/postgresql-version/","excerpt":"","text":"Postgresql 버전 확인 pgAdmin Query 창에서 아래 커맨드를 실행. 1select version(); 결과는 아래와 같이 나온다. 1&quot;PostgreSQL 9.5.3, compiled by Visual C++ build 1800, 64-bit&quot; 출처 https://www.postgresql.org/message-id/a2de01dd0808280738u32f76cffgaf5c740d12fff763@mail.gmail.com","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Database","slug":"Application/Database","permalink":"http://jacegem.github.io/blog/categories/Application/Database/"}],"tags":[{"name":"Postgresql","slug":"Postgresql","permalink":"http://jacegem.github.io/blog/tags/Postgresql/"}]},{"title":"PostGIS 공간쿼리","slug":"2016/postgis-spatial-query","date":"2017-03-01T15:00:00.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/postgis-spatial-query/","link":"","permalink":"http://jacegem.github.io/blog/2016/postgis-spatial-query/","excerpt":"","text":"PostGIS 공간쿼리 목표 : 전달된 좌표를 기반으로 가장 가까운 순으로 출력한다. Geometry 로 변경 좌표를 Geometry 로 변경 1select ST_SetSRID(ST_Point(126.94130, 37.37736), 4326) 문자열을 변수로 받는 경우는 double precision 으로 변경 1ST_SetSRID(ST_Point(CAST(#&#123;lng&#125; as double precision), CAST(#&#123;lat&#125; as double precision)), 4326) Geometry 에서 SRID 확인 1st_srid(geom) SRID 변경 https://postgis.net/docs/ST_Transform.html 1234geometry ST_Transform(geometry g1, integer srid);geometry ST_Transform(geometry geom, text to_proj);geometry ST_Transform(geometry geom, text from_proj, text to_proj);geometry ST_Transform(geometry geom, text from_proj, integer to_srid); Transform and Update table update 구문을 사용하니, 아래 처럼 에러메시지가 나옵니다. 1ERROR: Geometry SRID (4326) does not match column SRID (97308) Alter table로 컬럼 타입을 변경합니다. 12ALTER TABLE my_table ALTER COLUMN geom TYPE geometry(MultiPolygon,4326) USING ST_Transform(geom,4326); 거리 구하기 1ST_Distance(geom, ST_SetSRID(ST_Point(126.94130, 37.37736), 4326)) 멀티폴리곤 중앙점 구하기 123456select ST_Centroid(geom) from my_table-- 결과&quot;0101000020E6100000A2ED516D84BA5F4041F9855740B54240&quot;&quot;0101000020E6100000E6824D190DB95F407DB540B5CAB34240&quot;&quot;0101000020E61000007CB14A8739B95F40D1C60B02A0B34240&quot; 123456select st_astext(ST_Centroid(geom)) from my_table-- 결과&quot;POINT(126.914332704552 37.4160260585945)&quot;&quot;POINT(126.891424489684 37.4046236577951)&quot;&quot;POINT(126.894136259978 37.4033205564025)&quot; 123456select st_x(ST_Centroid(geom)), st_y(ST_Centroid(geom)) from my_table-- 결과126.914332704552;37.4160260585945126.891424489684;37.4046236577951126.894136259978;37.4033205564025","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"SQL","slug":"Programming/SQL","permalink":"http://jacegem.github.io/blog/categories/Programming/SQL/"}],"tags":[{"name":"query","slug":"query","permalink":"http://jacegem.github.io/blog/tags/query/"},{"name":"sql","slug":"sql","permalink":"http://jacegem.github.io/blog/tags/sql/"},{"name":"postgis","slug":"postgis","permalink":"http://jacegem.github.io/blog/tags/postgis/"}]},{"title":"마이바티스 쿼리 생성 - PostGIS 공간 쿼리","slug":"2016/postgis-spatial-query-mybatis","date":"2017-02-28T15:00:00.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/postgis-spatial-query-mybatis/","link":"","permalink":"http://jacegem.github.io/blog/2016/postgis-spatial-query-mybatis/","excerpt":"","text":"마이바티스 쿼리 생성 - PostGIS 공간 쿼리 거리순으로 대상을 조회합니다. 기본 조회 쿼리 12SELECT * FROM my_table where my_column like &#x27;%#&#123;text&#125;%&#x27;;SELECT ST_SetSRID(ST_Point(CAST(#&#123;lng&#125; as double precision), CAST(#&#123;lat&#125; as double precision)), 4326); with 절을 사용 1234WITH center AS ( SELECT ST_SetSRID(ST_Point(126.94130, 37.42187), 4326) as point )SELECT point from center 거리를 비교 123456WITH center AS ( SELECT ST_SetSRID(ST_Point(126.94130, 37.42187), 4326) as geom ), dist AS ( SELECT ST_Distance(ST_Centroid(geom), (SELECT geom FROM center)) as dist, * FROM my_table where my_column like &#x27;%대림%&#x27; )SELECT * FROM dist 정렬을 추가 12345678WITH center AS ( SELECT ST_SetSRID(ST_Point(126.94130, 37.42187), 4326) as geom ), dist AS ( SELECT ST_Distance(ST_Centroid(geom), (SELECT geom FROM center)) as dist, * FROM my_table where my_column like &#x27;%대림%&#x27; ), dist_order AS ( SELECT * FROM dist order by dist.dist asc )SELECT * FROM dist_order 페이징 추가 12345678WITH center AS ( SELECT ST_SetSRID(ST_Point(126.94130, 37.42187), 4326) as geom ), dist AS ( SELECT ST_Distance(ST_Centroid(geom), (SELECT geom FROM center)) as dist, * FROM my_table where my_column like &#x27;%대림%&#x27; ), dist_order AS ( SELECT * FROM dist order by dist.dist asc limit 10 offset (3 - 1) * 10 )SELECT * FROM dist_order 마이바티스로 변경 변수 목록 #{text} #{x} #{y} #{page} #{row_count} 1234567891011&lt;select id=&quot;listCnt&quot; resultType=&quot;int&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + text + &#x27;%&#x27;&quot; /&gt; WITH center AS ( SELECT ST_SetSRID(ST_Point(CAST(#&#123;x&#125; as double precision), CAST(#&#123;y&#125; as double precision)), 4326) as geom ), list AS ( SELECT ST_Distance(ST_Centroid(geom), (SELECT geom FROM center)) as dist, * FROM my_table where my_column like #&#123;pattern&#125; ), list_order AS ( SELECT * FROM dist order by list.dist asc limit #&#123;row_count&#125; offset (#&#123;page&#125; - 1) * #&#123;row_count&#125; ) SELECT * FROM list_order&lt;/select&gt; 총 수를 구하는 쿼리 1234&lt;select id=&quot;listCnt&quot; resultType=&quot;int&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + text + &#x27;%&#x27;&quot; /&gt; SELECT count(*) as count FROM my_table where my_column like #&#123;pattern&#125;&lt;/select&gt; 에러 The column index is out of range: 1, number of columns: 0. like 검색시에 bind를 사용합니다. 1234567891011121314&lt;select id=&quot;select&quot; parameterType=&quot;java.util.Map&quot; resultType=&quot;ViaDTO&quot;&gt; &lt;bind name=&quot;pattern&quot; value=&quot;&#x27;%&#x27; + P_NOMBRE + &#x27;%&#x27;&quot; /&gt; SELECT A.ID_VIAJE ID, A.NOMBRE, A.DESCRIPCION, A.FINICIO, A.FFIN, A.LOGO, A.URL, A.ID_CLIENTE IDCLIENTE, B.NOMBRE CLIENTE FROM VIAJE A INNER JOIN CLIENTE B ON (A.ID_CLIENTE = B.ID_CLIENTE) WHERE A.ESTATUS = 1 &lt;if test=&quot;P_NOMBRE != null&quot;&gt; AND A.NOMBRE LIKE #&#123;pattern&#125; &lt;/if&gt;&lt;/select&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"SQL","slug":"Programming/SQL","permalink":"http://jacegem.github.io/blog/categories/Programming/SQL/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://jacegem.github.io/blog/tags/Mybatis/"},{"name":"query","slug":"query","permalink":"http://jacegem.github.io/blog/tags/query/"},{"name":"sql","slug":"sql","permalink":"http://jacegem.github.io/blog/tags/sql/"},{"name":"postgis","slug":"postgis","permalink":"http://jacegem.github.io/blog/tags/postgis/"}]},{"title":"OpenVPN Windows 서버 및 클라이언트 설치","slug":"2017/openvpn-windows","date":"2017-02-26T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/openvpn-windows/","link":"","permalink":"http://jacegem.github.io/blog/2017/openvpn-windows/","excerpt":"","text":"OpenVPN Windows 서버 및 클라이언트 설치 서버설정 다운로드 및 설치 OpenVPN 설치파일 다운로드 → 설치 http://openvpn.net/index.php/open-source/downloads.html easy-rsa-old 다운로드 → 압축해제 https://github.com/OpenVPN/easy-rsa-old 커맨드 실행 cmd를 관리자 모드로 실행합니다. windows 폴더에서 커맨드를 실행합니다. 설정파일 초기화 123&gt; init-configcopy vars.bat.sample vars.bat 1 file(s) copied. 환경변수 설정 1&gt; vars 만약 아래와 같은 에러가 발생하면 var.bat 스크립트를 수정합니다. 12&#x27;#&#x27; is not recognized as an internal or external command,operable program or batch file. var.bat 파일을 에디터로 열어서 26번째 줄을 주석처리 합니다. 그리고 vars를 다시 실행합니다. 1rem # Private key size 기존 설정 파일 삭제 1&gt; clean-all 실행을 하면 key 폴더 밑에 파일이 2개 생성됩니다. index.txt serial Root CA (Certificatie Authority) 생성 1&gt; build-ca 만약 openssl-1.0.0.cnf 파일이 없다는 에러 메시지가 나오면 해당 파일을 복사합니다. 1No such file or directory:bss_file.c:175:fopen(&#x27;openssl-1.0.0.cnf&#x27;,&#x27;rb&#x27;) openssl-1.0.0.cnf 파일은 다운 받은 easy-rsa\\2.0\\openssl-1.0.0.cnf 에 있습니다. 정상적으로 실행되면 입력값을 물어봅니다. [Common Name]에서 값을 입력합니다. 2개 파일이 생성됩니다. ca.crt ca.key 서버키 생성 1&gt; build-key-server server [Common Name] 값을 입력합니다. 3개 파일이 생성됩니다. server.crt server.csr server.key DH Parameter 생성 1&gt; build-dh keys 폴더 밑에 dh4096.pem 파일이 생성됩니다. ta키 생성 keys 폴더로 이동하여 명령을 실행합니다. 1&gt; openvpn --genkey --secret ta.key ta.key 파일이 생성됩니다. 인증서 및 키파일 복사 c:\\Program Files\\OpenVPN\\config 폴더에 다음 파일을 복사합니다. ca.crt ca.key dh4096.pem ta.key server.crt server.key 서버 config파일 설정 c:\\Program Files\\OpenVPN\\sample-config 폴더에서 server.ovpn 파일을 c:\\Program Files\\OpenVPN\\config 폴더로 복사합니다. 복사한 server.ovpn 파일을 편집기로 열어서 다음 항목을 찾아(Ctrl+F) 필요한 값을 변경합니다. port : VPN서비스를 위한 포트 proto : TCP 또는 UDP를 선택 dh dh4096.pem push “redirect-gateway def1 bypass-dhcp” push “dhcp-option DNS 168.126.63.1” push “dhcp-option DNS 8.8.8.8” client-to-client tls-auth ta.key 0 # This file is secret cipher AES-256-CBC 서버 실행 커맨드창에서 c:\\Program Files\\OpenVPN\\config 폴더로 이동하여 명령어를 실행합니다. 1&gt; openvpn server.ovpn 123Options error: --dh fails with &#x27;dh2048.pem&#x27;: No such file or directoryOptions error: Please correct these errors.Use --help for more information. 에러 발생시 dh2048.pem 를 dh dh4096.pem 으로 변경합니다. 서비스 등록 확인 1&gt; services.msc 클라이언트 설정 서버에서 클라이언트 인증서 및 키 생성 서버의 easy-rsa 폴더에서 명령어를 실행합니다. 1&gt; build-key client1 [Common Name] 값을 입력합니다. 인증서 및 키파일 복사 생성된 인증서 및 키 파일을 클라이언트의 config 폴더에 복사합니다. ca.crt ca.key client.key client.crt ta.key 클라이언트 config파일 설정 클라이언트의 c:\\Program Files\\OpenVPN\\sample-config 폴더에서 client.ovpn 파일을 config 폴더로 복사합니다. 나중에 혹시 있을지 모르는 복수의 접속을 위해 client1.ovpn 으로 파일명을 변경합니다. 복사한 client1.ovpn 파일을 편집기로 열어서 다음 항목을 찾아(Ctrl+F) 필요한 값을 변경합니다. proto : TCP 또는 UDP를 선택(서버의 설정에 맞춘다) remote : 서버의 IP. 형식은 [IP Port] 의 형식임(콜론이 없음에 주의). cert : 인증서 파일. client1.crt로 변경합니다 key : 키 파일. client1.key로 변경합니다 tls-auth ta.key 0 : 맨 앞의 세미콜론을 제거합니다 cipher : 맨 앞의 세미콜론을 제거합니다 출처 http://takuma99.tistory.com/134 [Live without regrets!] http://haebi.kr/entry/OpenVPN-설치-및-사용기","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"VPN","slug":"Application/VPN","permalink":"http://jacegem.github.io/blog/categories/Application/VPN/"}],"tags":[{"name":"OpenVPN","slug":"OpenVPN","permalink":"http://jacegem.github.io/blog/tags/OpenVPN/"},{"name":"Windows","slug":"Windows","permalink":"http://jacegem.github.io/blog/tags/Windows/"}]},{"title":"OpenCV Crop Frame and Save","slug":"2017/opencv-crop-frame-and-save","date":"2017-02-25T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/opencv-crop-frame-and-save/","link":"","permalink":"http://jacegem.github.io/blog/2017/opencv-crop-frame-and-save/","excerpt":"","text":"OpenCV Crop Frame and Save 123count = 0cv2.imwrite(&quot;frame%d.jpg&quot; % count, frame)count = count+1 123456import cv2img = cv2.imread(&quot;lenna.png&quot;)crop_img = img[200:400, 100:300] # Crop from x, y, w, h -&gt; 100, 200, 300, 400# NOTE: its img[y: y + h, x: x + w] and *not* img[x: x + w, y: y + h]cv2.imshow(&quot;cropped&quot;, crop_img)cv2.waitKey(0) 출처 http://stackoverflow.com/questions/27378662/save-video-as-frames-opencvpy http://stackoverflow.com/questions/15589517/how-to-crop-an-image-in-opencv-using-python","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://jacegem.github.io/blog/tags/OpenCV/"}]},{"title":"모두를 위한 머신러닝/딥러닝 - Lec 00 - Machine/Deep learning 수업의 개요와 일정","slug":"2017/ml-lec-00","date":"2017-02-24T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/ml-lec-00/","link":"","permalink":"http://jacegem.github.io/blog/2017/ml-lec-00/","excerpt":"","text":"모두를 위한 머신러닝/딥러닝 - Lec 00 - Machine/Deep learning 수업의 개요와 일정 https://hunkim.github.io/ml/ https://www.youtube.com/watch?v=BS6O0zOGX4E&amp;list=PLlMkM4tgfjnLSOjrEJN31gZATbcj_MpUm&amp;index=1 독자 기본적인 머신러닝을 이해하길 원하는 분 목표 머신러닝 알고리즘에 대한 기본적인 이해 기본적인 알고리즘 (선형회귀, 로지스틱 회귀) 딥러닝 (Neural Networks, Convolutional Neural Network, Recurrent Neural Network) 머신러닝을 사용하여 문제를 해결 텐서플로와 파이썬 수업 구조 10분 수업 텐서플로를 사용한 프로그래밍 튜토리얼 Acknowlegement Andrew Ng’s ML class https://class.coursera.org/ml-003/lecture http://www.holehouse.org/mlclass/ (note) Convolutional Neural Networks for Visual Recognition http://cs231n.github.io Tensorflow https://www.tensorflow.org https://github.com/aymericdamien/TensorFlow-Examples 스케쥴 머신러닝 컨셉 Linear regression Logistic regression 많은 형태의 입력 데이터 처리 신경망 딥러닝","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"machine","slug":"machine","permalink":"http://jacegem.github.io/blog/tags/machine/"},{"name":"learning","slug":"learning","permalink":"http://jacegem.github.io/blog/tags/learning/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://jacegem.github.io/blog/tags/tensorflow/"}]},{"title":"모두를 위한 머신러닝 - ML lab 01 - TensorFlow의 설치및 기본적인 operations","slug":"2017/ml-labc-01","date":"2017-02-23T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/ml-labc-01/","link":"","permalink":"http://jacegem.github.io/blog/2017/ml-labc-01/","excerpt":"","text":"모두를 위한 머신러닝 - ML lab 01 - TensorFlow의 설치및 기본적인 operations (new) 텐서플로 설치 12pip install --upgrade tensorflowpip install --upgrade tensorflow-gpu TensorFlowKR https://www.facebook.com/groups/TensorFlowKR/ Check installation and version 123$ python3&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; tf.__version__","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"machine","slug":"machine","permalink":"http://jacegem.github.io/blog/tags/machine/"},{"name":"learning","slug":"learning","permalink":"http://jacegem.github.io/blog/tags/learning/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://jacegem.github.io/blog/tags/tensorflow/"}]},{"title":"Minergate에서 채굴하기","slug":"2017/Minergate에서-채굴하기","date":"2017-02-22T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/Minergate에서-채굴하기/","link":"","permalink":"http://jacegem.github.io/blog/2017/Minergate%EC%97%90%EC%84%9C-%EC%B1%84%EA%B5%B4%ED%95%98%EA%B8%B0/","excerpt":"","text":"Minergate에서 채굴하기 GUI 프로그램을 통해서 쉽게 채굴할 수 있는 환경을 제공합니다. minergate 에서 다양한 가상화폐를 채굴할 수 있습니다. ((비트코인은 없지만)) 가입 및 로그인 홈페이지(https://minergate.com/)에 가입 후에 로그인 합니다. Downloads 채굴을 위한 프로그램을 다운로드 받습니다. 상단 Downloads 메뉴를 선택합니다. 그리고, 32, 64비트중에 맞는 프로그램을 다운로드 받아서 설치합니다. 중간에 있는 GUI miners, Console miners, Admin edition 중에서 GUI 를 사용할 것이기 때문에 GUI miners 를 선택합니다. ((기본으로 선택되어 있습니다.)) minergate 실행 다운로드 받은 프로그램을 설치 후 실행합니다. 그 후 가입한 계정으로 로그인 합니다. SMART MINER 처음에 SMART MINER 메뉴가 보입니다. 123Automatic mining of the currency that has the highest exchange rate during the last hour지난 1 시간 동안 가장 높은 환율을 지닌 통화의 자동 마이닝 지난 1시간 동안 가장 높은 환율을 지닌 통화는 XMR입니다. 만약 자동 시작이 되지 않으면 start mining 을 선택합니다. 채굴중에 CPU, GPU 의 채굴 정보를 보여줍니다. GPU MINING 에서 실시간 Hashrate, 10 초 평균 값을 보여줍니다. GPU MINING 에서 실시간 Hashrate, 1분 평균 값을 보여줍니다. MINER MINER 메뉴를 선택하시면, 다른 채굴 가능한 화폐 목록을 볼 수 있습니다. 채굴을 원하는 목록의 Start mining 버튼을 클릭하여 채굴을 시작합니다. hashrate XMR 채굴시에 사용중인 CPU AMD Phenom™ X4 945 Processor 3.00 GHz 에서 3 core 사용시에 27 H/s 정도 나옵니다. GTX 1060 6G 에서 INTENSITY 를 3으로 설정시 125 kH/s 정도 나옵니다. ((수치로는 이렇게 나오지만 dashboard 에서 나오는 내용과는 다릅니다.)) BENCHMARK 컴퓨터의 CPU, GPU 채굴 능력을 비교할 수 있습니다. Dashboard 웹 페이지의 Dashboard 메뉴에서 현재 채굴되고 있는 상황을 확인 할 수 있습니다. Monero 채굴을 진행중이며 해쉬파워는 829 입니다. 여러개의 worker가 가진 해쉬파워의 합입니다. Status 가 Online 상태일 경우 배경색이 녹색으로 나오며, OFFLINE 이면 빨간색으로 나옵니다. 시세 https://www.coingecko.com/ko/시세차트/monero/usd 에서 MONERO 시세를 확인 할 수 있습니다. 1 XMR 은 $43 입니다.","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Cryptocurrency","slug":"Application/Cryptocurrency","permalink":"http://jacegem.github.io/blog/categories/Application/Cryptocurrency/"}],"tags":[{"name":"Minergate","slug":"Minergate","permalink":"http://jacegem.github.io/blog/tags/Minergate/"}]},{"title":"Microsoft Tech Summit Seoul","slug":"2017/Microsoft-Tech-Summit-Seoul","date":"2017-02-21T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/Microsoft-Tech-Summit-Seoul/","link":"","permalink":"http://jacegem.github.io/blog/2017/Microsoft-Tech-Summit-Seoul/","excerpt":"","text":"Microsoft Tech Summit Seoul 2017.04.27 (11:15 am - 12:30 pm) Defend Windows clients from modern threats and attacks with Windows 10 security (Korean) Microsoft Windows 10 offered an enormous leap forward when it comes to threat resistance, but that was just the beginning. With Windows 10 Anniversary Edition we have an impressive… (11:15 am - 12:30 pm) Discover what’s new and what’s coming to the SharePoint Mobile and Intelligent Intranet (Korean) We are evolving your intranet - making it more mobile for users on the go and infusing it with intelligence so that information finds you, not you hunting and searching for information… 2017.04.28 (10:00 am - 11:15 am) Enhance Windows 10 deployment: what’s new with Windows 10 deployment? (Korean) We continue to invest in new capabilities to make Microsoft Windows deployment easier. In this session, we provide an overview of the latest enhancements for Windows 10 deployment. … (10:00 am - 11:15 am) Explore Cloud IP Telephony (Korean) Learn how to integrate Skype into your phone system so you can make and receive Skype calls on your office phones (10:00 am - 11:15 am) Port your AWS knowledge to Azure (Korean) Most customers are considering a multi-cloud strategy for reasons that range from hedging their bets to getting best of both worlds. Whatever may be the reason, we want to support our…","categories":[{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"Microsoft","slug":"Conference/Microsoft","permalink":"http://jacegem.github.io/blog/categories/Conference/Microsoft/"}],"tags":[{"name":"Microsoft","slug":"Microsoft","permalink":"http://jacegem.github.io/blog/tags/Microsoft/"},{"name":"Tech","slug":"Tech","permalink":"http://jacegem.github.io/blog/tags/Tech/"},{"name":"Summit","slug":"Summit","permalink":"http://jacegem.github.io/blog/tags/Summit/"},{"name":"Seoul","slug":"Seoul","permalink":"http://jacegem.github.io/blog/tags/Seoul/"}]},{"title":"Leaflet.TileLayer","slug":"2017/leaflettilelayer","date":"2017-02-20T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/leaflettilelayer/","link":"","permalink":"http://jacegem.github.io/blog/2017/leaflettilelayer/","excerpt":"","text":"Leaflet.TileLayer 출처 : http://leafletjs.com/reference.html#tilelayer TileLayer 맵상에서 타일 레이러를 불러오고 표시하는데 사용합니다. ILayer 인터페이스를 구현합니다. 사용 예 1L.tileLayer(&#x27;http://&#123;s&#125;.tile.osm.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png?&#123;foo&#125;&#x27;, &#123;foo: &#x27;bar&#x27;&#125;).addTo(map); 생성 생성 설명 L.tileLayer( urlTemplate, options? ) 주어진 URL 템플릿로 타일 레이어 오브젝트와 옵션 오브젝트를 초기화합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"leaflet","slug":"leaflet","permalink":"http://jacegem.github.io/blog/tags/leaflet/"},{"name":"tilelayer","slug":"tilelayer","permalink":"http://jacegem.github.io/blog/tags/tilelayer/"},{"name":"gis","slug":"gis","permalink":"http://jacegem.github.io/blog/tags/gis/"}]},{"title":"Markdown 사용법","slug":"2017/markdown-usage","date":"2017-02-20T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/markdown-usage/","link":"","permalink":"http://jacegem.github.io/blog/2017/markdown-usage/","excerpt":"","text":"Markdown 사용법 처음 사용시에는 라이브 렌더링이 되는 것이 좋습니다. 텍스트로 마크 다운 형식으로 작성하면 바로 변형되서 화면에 보이는 것입니다. 줄바꿈으로 글을 작성하였지만, 렌더링시에 줄바꿈 글이 이어서 나오는 것을 볼 수 있습니다. 이럴때는 중간에 빈 줄을 넣어 명시적으로 줄바꿈을 표시해야 합니다. 물론, 이를 지원하는 프로그램도 있습니다. 이런 경우는 줄간격이 큰 것을 확인 할 수 있습니다. 윈도우 프로그램 마크다운을 기본으로 작성하는 문서 편집기 입니다. typora (추천) https://typora.io/ (라이브 렌더링) haroopad : http://pad.haroopress.com/ 플러그인 코드 편집기에 플러그인을 추가해서 사용하는 방식입니다. visual studio code : https://code.visualstudio.com/ atom : https://atom.io/ 웹 http://classeur.io/ (라이브 렌더링) https://www.gitbook.com https://trello.com/ 문법 공통적으로 사용하는 마크다운 문법과 각 프로그램 및 서비스에서 사용하는 확장 문법이 있습니다. 기본 문법만 익히고 확장 문법은 각 프로그램에서 제공하는 방식을 이용하면 됩니다. 기본 문법 헤더 작성 # This is an H1 ## This is an H2 ###### This is an H6 출력결과 This is an H1 This is an H2 This is an H6 인용구 > This is a blockquote with two paragraphs. This is first paragraph. > > This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. > This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. 출력결과 This is a blockquote with two paragraphs. This is first paragraph. This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. 목록 ## un-ordered list * Red * Green * Blue ordered list Red Green Blue 앞에 * , 또는 - 를 사용하여 순서가 없는 목록을 작성할 수 있습니다. (공백이 필요합니다.) 순서가 필요한 경우에는 앞에 1., 2. 숫자 와 점(.)을 이어서 사용합니다. 숫자를 증가시키면서 작성할 필요는 없습니다. 아래와 같이 작성하여도 동일한 결과를 얻을 수 있습니다. ## ordered list 1. Red 1. Green 1. Blue 출력결과 un-ordered list Red Green Blue ordered list Red Green Blue 코드 Use the `printf()` function. 출력 결과 Use the printf() function. 코드 블럭 ​``` function test() &#123; console.log(\"notice the blank line before this function?\"); &#125; 123456789&lt;/code&gt;하이라이트 문법을 적용할 경우에는 \\`\\`\\` 뒤에 언어명을 작성합니다.&lt;code&gt;```rubyrequire &#x27;redcarpet&#x27;markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html 출력결과 123require &#x27;redcarpet&#x27;markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html 표 작성 | First Header | Second Header | | ------------- | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 출력 결과 First Header Second Header Content Cell Content Cell Content Cell Content Cell 링크 This is [an example](http://example.com/ \"Title\") inline link. 이곳 의 주소는 http://doku.ml/open/마크다운_사용법 입니다. 출력 결과 This is an example inline link. 이곳 의 주소는 http://doku.ml/open/마크다운_사용법 입니다. 이미지 ![typora](https://goo.gl/CXHGTE) 출력결과 강조 *single asterisks* single underscores single asterisks single underscores 굵은 글씨 **double asterisks** 출력결과 double asterisks 밑줄 __double underscores__ 출력결과 double underscores 출처 http://support.typora.io/Markdown-Reference/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"ETC","slug":"Programming/ETC","permalink":"http://jacegem.github.io/blog/categories/Programming/ETC/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://jacegem.github.io/blog/tags/markdown/"},{"name":"pro","slug":"pro","permalink":"http://jacegem.github.io/blog/tags/pro/"}]},{"title":"[leaflet] divIcon 마커 찍기","slug":"2017/leaflet-marker","date":"2017-02-19T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/leaflet-marker/","link":"","permalink":"http://jacegem.github.io/blog/2017/leaflet-marker/","excerpt":"","text":"[leaflet] divIcon 마커 찍기 데이터 구조 1234567891011items = [ &#123; buld_nm : &#x27;A 아파트&#x27;, st_x : &#x27;126.123&#x27;, st_y : &#x27;37.123&#x27; &#125;, &#123; buld_nm : &#x27;B 백화점&#x27;, st_x : &#x27;123.123&#x27;, st_y : &#x27;34.123&#x27; &#125;] 함수 호출 12// 마커 찍기mymap.addSearchMarker(this.items); 마커 레이어 추가 123456var cities = new L.LayerGroup();L.marker([39.61, -105.02]).bindPopup(&#x27;This is Littleton, CO.&#x27;).addTo(cities),L.marker([39.74, -104.99]).bindPopup(&#x27;This is Denver, CO.&#x27;).addTo(cities),L.marker([39.73, -104.8]).bindPopup(&#x27;This is Aurora, CO.&#x27;).addTo(cities),L.marker([39.77, -105.23]).bindPopup(&#x27;This is Golden, CO.&#x27;).addTo(cities); 레이어 관리 오브젝트 1var layerMap = &#123;&#125;; 123456var key = &quot;searchMarker&quot;;var layer = layerMap[key];if (layer) map.removeLayer(layer);layer = new L.LayerGroup().addTo(map);layerMap[key] = layer; 데이터 삽입 for 문 사용 1234for (var i =0; i &lt; items.length; i++)&#123; item = items[i]; L.marker([item.st_y, item.st_x]).addTo(layer);&#125; 마커가 안보이는 경우 x, y 의 순서를 바꿔서 입력해 봅니다. divIcon 사용 12345678910var searchIcon = L.divIcon(&#123; //iconSize: new L.Point(50, 50), iconSize: null, html: &#x27;&lt;span class=&quot;map-point&quot;&gt;A&lt;/span&gt;&#x27;&#125;);for (var i =0; i &lt; items.length; i++)&#123; var item = items[i]; L.marker([item.st_y, item.st_x], &#123;icon: searchIcon&#125;).addTo(layer).bindPopup(item.buld_nm);&#125; divIcon 반환 함수 생성 i 가 0 이면 A, 1이면 B를 반환하도록 함수 생성 123456789101112131415function getSearchIcon(i)&#123; // 0 : A var chr = String.fromCharCode(65 + i) var searchIcon = L.divIcon(&#123; iconSize: null, html: &#x27;&lt;span class=&quot;map-point&quot;&gt;&#x27; + chr + &#x27;&lt;/span&gt;&#x27;, iconAnchor : [ 13, 32 ], popupAnchor : [ 0, -10 ] &#125;); return &#123; icon: searchIcon &#125;&#125; 호출 함수 1234for (var i =0; i &lt; items.length; i++)&#123; var item = items[i]; L.marker([item.st_y, item.st_x], getSearchIcon(i)).bindTooltip(item.buld_nm, tooltipOption).addTo(layer);&#125; 출처 http://leafletjs.com/reference-1.0.3.html#marker http://bl.ocks.org/ismyrnow/6123517 https://gis.stackexchange.com/questions/114956/leaflet-how-do-you-use-removelayer","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"leaflet","slug":"leaflet","permalink":"http://jacegem.github.io/blog/tags/leaflet/"},{"name":"div","slug":"div","permalink":"http://jacegem.github.io/blog/tags/div/"},{"name":"icon","slug":"icon","permalink":"http://jacegem.github.io/blog/tags/icon/"}]},{"title":"Macbook Pro 2016","slug":"2017/macbook_pro_2016","date":"2017-02-19T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/macbook_pro_2016/","link":"","permalink":"http://jacegem.github.io/blog/2017/macbook_pro_2016/","excerpt":"","text":"Macbook Pro # Macbook Pro 2016 애플이 2016.10.27일(현지시간) 미국 캘리포니아 쿠퍼티노에서 얇고 가벼워진 새 맥북프로를 공개했다. 특징 펑션키 위치에 터치바 배치 모든 포트를 USB Type-C 로 통일 무게 가벼워지고, 두께가 줄어듬 가격 오름 가격 비교 (공홈, 리퍼, AOC) | 모델 | 램/SSD | 공홈 | AOC | 리퍼 | |------|------|-----|----| |13&quot; 기본 (2015) | 8/128 | 1,590,000 | 1,401,400 | 1,350,000 | |13&quot; 기본 (2016) | 8/256 | 1,890,000 | 1,756,700 | - | |13&quot; 고급 (2016) 터치바| 8/512 | 2,490,000 | 2,274,800 | - | |15&quot; 기본 (2015) | 16/256 | 2,390,000 | 2,179,100| - | |15&quot; 기본 (2016) 터치바| 16/256 | 2,990,000 | 2,688,400| - | |15&quot; 고급 (2016) 터치바| 16/512 | 3,520,000 | 3,139,400| - |","categories":[{"name":"Product","slug":"Product","permalink":"http://jacegem.github.io/blog/categories/Product/"},{"name":"Notebook","slug":"Product/Notebook","permalink":"http://jacegem.github.io/blog/categories/Product/Notebook/"}],"tags":[{"name":"macbook","slug":"macbook","permalink":"http://jacegem.github.io/blog/tags/macbook/"},{"name":"pro","slug":"pro","permalink":"http://jacegem.github.io/blog/tags/pro/"}]},{"title":"Leaflet 화면 중앙 위치 값 얻기","slug":"2017/leaflet-get-center","date":"2017-02-18T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/leaflet-get-center/","link":"","permalink":"http://jacegem.github.io/blog/2017/leaflet-get-center/","excerpt":"","text":"Leaflet 화면 중앙 위치 값 얻기 1map.getCenter() 123center = map.getCenter();center.x = center.lng;center.y = center.lat;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"leaflet","slug":"leaflet","permalink":"http://jacegem.github.io/blog/tags/leaflet/"}]},{"title":"LATEX","slug":"2017/latex","date":"2017-02-17T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/latex/","link":"","permalink":"http://jacegem.github.io/blog/2017/latex/","excerpt":"","text":"LATEX 설치 TexStudio Beamer 1234567891011121314151617181920212223\\documentclass&#123;beamer&#125;\\usepackage[utf8]&#123;inputenc&#125;\\usepackage[hangul]&#123;kotex&#125;%Information to be included in the title page:\\title&#123;Sample title 한글&#125;\\author&#123;Anonymous&#125;\\institute&#123;ShareLaTeX&#125;\\date&#123;2014&#125;\\begin&#123;document&#125;\\frame&#123;\\titlepage&#125;\\begin&#123;frame&#125;\\frametitle&#123;Sample frame title&#125;This is a text in first frame. This is a text in first frame. This is a text in first frame.\\end&#123;frame&#125;\\end&#123;document&#125; 한글 사용시 \\usepackage[hangul]&#123;kotex&#125; 패키지를 추가한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"ETC","slug":"Programming/ETC","permalink":"http://jacegem.github.io/blog/categories/Programming/ETC/"}],"tags":[{"name":"LATEX","slug":"LATEX","permalink":"http://jacegem.github.io/blog/tags/LATEX/"}]},{"title":"KOYCERA Scan 교세라 복합기 스캔","slug":"2017/KOYCERA-Scan","date":"2017-02-16T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/KOYCERA-Scan/","link":"","permalink":"http://jacegem.github.io/blog/2017/KOYCERA-Scan/","excerpt":"","text":"KOYCERA Scan 교세라 복합기 스캔 Windows 설정에서 장치를 선택합니다. 왼쪽 메뉴중에서 프린터 및 스캐너를 선택합니다. 목록중에서 스캔을 할 장치를 보면 프린터 앱 열기 항목이 있습니다. 프린터 앱 열기 를 클릭하면 아래와 같은 화면을 볼 수 있습니다. 처음 실행하는 경우라면 먼저 장치를 등록해야 합니다. 장치를 선택하고 우측 하단에 있는 추가 버튼을 클릭합니다. 사용하시는 IP 를 입력하고 확인버튼을 누르면 장치가 추가된 것을 확인할 수 있습니다. 스캔 메뉴로 이동 후 스캔 파일을 저장할 곳을 지정합니다. 설정을 모두 마친후 스캔 버튼을 눌러 스캔을 시작합니다.","categories":[{"name":"Product","slug":"Product","permalink":"http://jacegem.github.io/blog/categories/Product/"},{"name":"Printer","slug":"Product/Printer","permalink":"http://jacegem.github.io/blog/categories/Product/Printer/"}],"tags":[{"name":"KOYCERA","slug":"KOYCERA","permalink":"http://jacegem.github.io/blog/tags/KOYCERA/"},{"name":"scan","slug":"scan","permalink":"http://jacegem.github.io/blog/tags/scan/"}]},{"title":"kobo Aura H20 공장초기화","slug":"2017/kobo-aura-h20-factory-reset","date":"2017-02-15T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/kobo-aura-h20-factory-reset/","link":"","permalink":"http://jacegem.github.io/blog/2017/kobo-aura-h20-factory-reset/","excerpt":"","text":"kobo Aura H20 공장초기화 설정 → 내 기기 → 공장 초기화 재부팅후, Wifi 연결, 업데이트 진행됨 (5-10분), 다시 재부팅 (3-5분) 구글 계정 입력, Kobo 계정 입력 PC 와 재연결, Connect 할일 폰트 추가 : http://ggumi.tistory.com/226 Calibre 설치 : https://calibre-ebook.com/ 다운 받은 폰트파일을 fonts 폴더에 모두 복사 calibre KoboTouchExtended 플러그인 설치","categories":[{"name":"Product","slug":"Product","permalink":"http://jacegem.github.io/blog/categories/Product/"},{"name":"Ebook","slug":"Product/Ebook","permalink":"http://jacegem.github.io/blog/categories/Product/Ebook/"}],"tags":[{"name":"kobo","slug":"kobo","permalink":"http://jacegem.github.io/blog/tags/kobo/"},{"name":"aura","slug":"aura","permalink":"http://jacegem.github.io/blog/tags/aura/"},{"name":"h20","slug":"h20","permalink":"http://jacegem.github.io/blog/tags/h20/"},{"name":"공장초기화","slug":"공장초기화","permalink":"http://jacegem.github.io/blog/tags/%EA%B3%B5%EC%9E%A5%EC%B4%88%EA%B8%B0%ED%99%94/"}]},{"title":"JSP list to javascript","slug":"2017/jsp-list-to-javascript","date":"2017-02-14T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/jsp-list-to-javascript/","link":"","permalink":"http://jacegem.github.io/blog/2017/jsp-list-to-javascript/","excerpt":"","text":"JSP list to javascript JSP 로 부터 넘어온 리스트 객체를 자바스크립트 리스트 객체로 변환합니다. 1234567891011var obj_list = [ &lt;c:forEach items=&quot;$&#123;jsp_list&#125;&quot; var=&quot;item&quot; varStatus=&quot;loop&quot;&gt; &#123; &#x27;seq&#x27; : &#x27;$&#123;item.seq&#125;&#x27; , &#x27;type&#x27; : &#x27;$&#123;item.type&#125;&#x27; , &#x27;title&#x27; : &#x27;$&#123;item.title&#125;&#x27; , &#x27;content&#x27; : &#x27;$&#123;item.content&#125;&#x27; , &#x27;lon_x&#x27; : &#x27;$&#123;item.lon_x&#125;&#x27; , &#x27;lat_y&#x27; : &#x27;$&#123;item.lat_y&#125;&#x27; &#125; $&#123;not loop.last ? &#x27;,&#x27; : &#x27;&#x27;&#125; &lt;/c:forEach&gt;]; 리스트를 이용하여 처리합니다. 12345// 이벤트 목록 마커 생성for (var i = 0, len = obj_list.length; i &lt; len; i++) &#123; var item = obj_list[i]; // codes...&#125;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"JSP","slug":"Programming/JSP","permalink":"http://jacegem.github.io/blog/categories/Programming/JSP/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"jsp","slug":"jsp","permalink":"http://jacegem.github.io/blog/tags/jsp/"},{"name":"list","slug":"list","permalink":"http://jacegem.github.io/blog/tags/list/"}]},{"title":"JSP include 사용","slug":"2017/jsp-include","date":"2017-02-13T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/jsp-include/","link":"","permalink":"http://jacegem.github.io/blog/2017/jsp-include/","excerpt":"","text":"JSP include 사용 include 호출 페이지 1234&lt;jsp:include page=&quot;../include/menu.jsp&quot;&gt; &lt;jsp:param name=&quot;type&quot; value=&quot;tag&quot; /&gt; &lt;jsp:param name=&quot;title&quot; value=&quot;&lt;h1 class=&#x27;area-logo&#x27;&gt; ****MY_LOGO**** &lt;/h1&gt;&quot; /&gt;&lt;/jsp:include&gt; title 로 전달하는 종류가 2가지인 경우 type 으로 그 대상을 구분합니다. tag: 전달된 내용을 그대로 출력 text: 텍스트를 일정 태그안에 넣어서 출력 inlucde 페이지 1234&lt;c:choose&gt; &lt;c:when test=&quot;$&#123;param.type == &#x27;tag&#x27;&#125;&quot;&gt;$&#123;param.title&#125;&lt;/c:when&gt; &lt;c:otherwise&gt;&lt;h1 class=&quot;area-tit&quot;&gt;$&#123;param.title&#125;&lt;/h1&gt;&lt;/c:otherwise&gt;&lt;/c:choose&gt; choose JSTL을 사용하여 분기 처리합니다. type 으로 전달된 값을 확인하여 ‘tag’ 텍스트인지 확인합니다. $&#123;param.type == 'tag'&#125; 맞으면 전달된 title을 그대로 출력합니다. 아닐 경우에는 &lt;h1 class=&quot;area-tit&quot;&gt; 태그로 텍스트를 출력합니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"JSP","slug":"Programming/JSP","permalink":"http://jacegem.github.io/blog/categories/Programming/JSP/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://jacegem.github.io/blog/tags/jsp/"},{"name":"include","slug":"include","permalink":"http://jacegem.github.io/blog/tags/include/"}]},{"title":"it21-Recurrent-Neural-Network","slug":"2017/it21-Recurrent-Neural-Network","date":"2017-02-12T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/it21-Recurrent-Neural-Network/","link":"","permalink":"http://jacegem.github.io/blog/2017/it21-Recurrent-Neural-Network/","excerpt":"","text":"it21-Recurrent-Neural-Network 인공지능하면 떠오르는 것들. 얼굴인식, 자연어처리, 경향이 변하고 있다. 머신 러닝 일상의 일을 처리할 수 있는 힘이 생겼다. Seq2Seq 번역 RNN 번역 잘 됨. 작곡, 소설, Image to Caption End to End learning 하나의 프레임, 일상의 문제를 보면, 문제풀이 패턴이 보인다. 머신러닝을 통해 풀 수 있다. 사람은 문제를 정의하고 기계가 문제를 풀도록! Sequence 2 Sequence Learning 기억: 과거의 어떤 것이 현재에 영향을 미치는 것. 다음행위에 영향을 미친다. 시간축 위에 살고 있기 때문에 RNN은 기억과 연관이 있다. Neural Network + Memory = Recurrent Neural Network 튜링 머신/ 기억을 할 수 있는 파워 Feed forward network 멀리 있어서, 중요한 정보가 사라진다. Vanishing Gradient LSTM: 단위 네트워크 게이트 키핑 컨셉 word2bag Sequence Encoding","categories":[{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"ETC","slug":"Conference/ETC","permalink":"http://jacegem.github.io/blog/categories/Conference/ETC/"}],"tags":[{"name":"rnn","slug":"rnn","permalink":"http://jacegem.github.io/blog/tags/rnn/"}]},{"title":"it21-machine-learning","slug":"2017/it21-machine-learning","date":"2017-02-11T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/it21-machine-learning/","link":"","permalink":"http://jacegem.github.io/blog/2017/it21-machine-learning/","excerpt":"","text":"it21-machine-learning Hwanjo Yu / POSTECH http://hwanjoyu.org (웹페이지 안열림) feature, generaliztion 80분/ 슬라이드 교체함 딥러닝, 컴퓨터 비전, 사물 인식, 조명, 각도가 바뀌면 못알아본다. → 문제점 사람이 인식하는 하이레벨 피처를 알아본다. 인간처럼 이미지 인식은 인간보다 더 잘한다. what current systems recoginze in below images 자연어 처리/ Sentiment Analysis 문맥을 본다. Machine Translations 1997: Deep Blue (chess) 2011: IBM Watson (Jeopardy!) 2016: AlphaGo 머신러닝 모델링의 싸움 본능. 사람은 비합리적인 판단을 한다. 본능이 있기 때문에 2가지 공통점 인공지능 과제 AlphaGo NVIDIA Auto Driving Google Translation Big Data + Hardware + Machine Learning Algorithm real-world task → modeling → formal task → algoritms → programs 가중치를 구해주는것이 머신러닝 가중치를 자동으로 학습. 모델링/ 피처를 잘 고르고, 잘 연결 틀을 만든다. weight parameter 는 머신러닝을 통해 얻는다. what do we need to learn? Type of models… Art of Modeling… Developing Algorithms… 어떤 모델들이 있는가 가장 단순한 모델 Reflex Sentiment Analysis cliches 단어가 들어 있는지 확인 하여 분류. 단어 하나로 결정 단어 여러개를 본다. 부정적이면 -10, 긍정적이면 +5, 스코어를 결정한다. 가장 기본이 되는 단위, linear classifier learning parameter, weight Training examples → Learning algorithm → Simple Program with Generalization Reflex 모델 State-based model state : 디자인 후, 옵티멀한 경로를 찾아가는 것 응용되는 곳 Search Problem 스스로 학습 Variable-based Models CSP Constrain Event Scheduling Topic Modeling 확률그래프 모델링, 그래픽컬 모델링, 베이지안 네트워크 Logic High-level Intelligence 모두 Optimization Problems 으로 바뀐다. Optimization Models are optimization problems Discrete optimization (dynamic programming) Continuous optimization (gradient descent) Roadmap loss minimization Features &amp; Neural Network Generalization GAN 데이터를 genrate https://tensorflow.blog/2016/11/24/gan-pixelcnn/ 피처가 왜 중요하나 Linear Prediction redidual 을 최소화 한다. Feature extraction 피처를 어떻게 정의해야 하는가 데이터를 넣어서 얼마나 건강한가 판단 제곱을 디자인할 수도 있다. 새로운 피처 스페이스에서는 넌리니어가 된다. joint learning Neural Network 는 피처를 learning 하는 것이다. 구조화 되지 않은 데이터에 머신러닝이 좋다. 데이터가 많이 필요한 것이 머신러닝의 단점이다. Generalization 어떻게 Generalization을 할 수 있는가 오버피팅을 피하려면 데이터를 많이 모은다. Autoencoder Loss minimization Design lossw ell to reflect what you really want Features &amp; neural Network Design features well to reduce data… Desing NN well to learn high-level features… Generalization Regularize well to generalize Think about generalization when you do all above","categories":[{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"ETC","slug":"Conference/ETC","permalink":"http://jacegem.github.io/blog/categories/Conference/ETC/"}],"tags":[{"name":"machine","slug":"machine","permalink":"http://jacegem.github.io/blog/tags/machine/"},{"name":"learning","slug":"learning","permalink":"http://jacegem.github.io/blog/tags/learning/"}]},{"title":"윈도우에 pyrebase 설치","slug":"2017/install-pyrebae-windows","date":"2017-02-10T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/install-pyrebae-windows/","link":"","permalink":"http://jacegem.github.io/blog/2017/install-pyrebae-windows/","excerpt":"","text":"윈도우에 pyrebase 설치 설치 12345678910Collecting jws&gt;=0.1.3 (from python-jwt==2.0.1-&gt;pyrebase) Using cached jws-0.1.3.tar.gz Complete output from command python setup.py egg_info: Traceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;C:\\Users\\xxx\\AppData\\Local\\Temp\\pip-build-4k32bmcg\\jws\\setup.py&quot;, line 17, in &lt;module&gt; long_description=read(&#x27;README.md&#x27;), File &quot;C:\\Users\\xxx\\AppData\\Local\\Temp\\pip-build-4k32bmcg\\jws\\setup.py&quot;, line 5, in read return open(os.path.join(os.path.dirname(__file__), fname)).read() UnicodeDecodeError: &#x27;cp949&#x27; codec can&#x27;t decode byte 0xe2 in position 500: illegal multibyte sequence setup.py 파일을 찾을 수 없었습니다. 그리하여 jws-0.1.3-py3.4.egg 파일을 다운받아 easy_install로 설치하였지만 동일한 오류 발생. 다운 받은 파일을 압축 풀어 jws-0.1.3-py3.4\\jws 폴더를 파이썬 라이브러리 폴더에 복사 아나콘다의 경우 [Anaconda_PATH]\\Lib\\site-packages 에 복사합니다. pip install pyrebase 를 실행하면 설치 완료 출처 https://pypi.python.org/pypi/jws https://github.com/thisbejim/Pyrebase","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"windows","slug":"windows","permalink":"http://jacegem.github.io/blog/tags/windows/"},{"name":"pyrebase","slug":"pyrebase","permalink":"http://jacegem.github.io/blog/tags/pyrebase/"}]},{"title":"HTTP Content-Type 정리","slug":"2017/http_content-type_c815_b9ac","date":"2017-02-09T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/http_content-type_c815_b9ac/","link":"","permalink":"http://jacegem.github.io/blog/2017/http_content-type_c815_b9ac/","excerpt":"","text":"HTTP Content-Type 정리 출처 : http://hbesthee.tistory.com/45 언어에 따른 선언 방식 언어 방식 ASP &lt;% Response.ContentType = “text/html” %&gt; JSP &lt;%@ page contentType=“text/html” %&gt; PHP Perl print “Content-type: text/html\\n\\n”; #Content-Type 의 종류. Multipart Related MIME 타입 Content-Type: Multipart/related &lt;-- 기본형태 Content-Type: Application/X-FixedRecord XML Media의 타입 Content-Type: text/xml Content-Type: Application/xml Content-Type: Application/xml-external-parsed-entity Content-Type: Application/xml-dtd Content-Type: Application/mathtml+xml Content-Type: Application/xslt+xml Application의 타입 Content-Type: Application/EDI-X12 &lt;-- Defined in RFC 1767 Content-Type: Application/EDIFACT &lt;-- Defined in RFC 1767 Content-Type: Application/javascript &lt;-- Defined in RFC 4329 Content-Type: Application/octet-stream : &lt;-- 디폴트 미디어 타입은 운영체제 종종 실행파일, 다운로드를 의미 Content-Type: Application/ogg &lt;-- Defined in RFC 3534 Content-Type: Application/x-shockwave-flash &lt;-- Adobe Flash files Content-Type: Application/json &lt;-- JavaScript Object Notation JSON; Defined in RFC 4627 Content-Type: Application/x-www-form-urlencode &lt;-- HTML Form 형태 x-www-form-urlencode와 multipart/form-data은 둘다 폼 형태이지만 x-www-form-urlencode은 대용량 바이너리 테이터를 전송하기에 비능률적이기 때문에 대부분 첨부파일은 multipart/form-data를 사용하게 된다. 오디오 타입 Content-Type: audio/mpeg &lt;-- MP3 or other MPEG audio Content-Type: audio/x-ms-wma &lt;-- Windows Media Audio; Content-Type: audio/vnd.rn-realaudio &lt;-- RealAudio; 등등 Multipart 타입 Content-Type: multipart/mixed: MIME E-mail; Content-Type: multipart/alternative: MIME E-mail; Content-Type: multipart/related: MIME E-mail &lt;-- Defined in RFC 2387 and used by MHTML(HTML mail) Content-Type: multipart/formed-data &lt;-- 파일 첨부 TEXT 타입 Content-Type: text/css Content-Type: text/html Content-Type: text/javascript Content-Type: text/plain Content-Type: text/xml 좀더 다양한 포맷에 대해서는 아래의 URL을 참고하기 바랍니다. http://www.iana.org/assignments/media-types/","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Protocol","slug":"Programming/Protocol","permalink":"http://jacegem.github.io/blog/categories/Programming/Protocol/"}],"tags":[{"name":"type","slug":"type","permalink":"http://jacegem.github.io/blog/tags/type/"},{"name":"http","slug":"http","permalink":"http://jacegem.github.io/blog/tags/http/"},{"name":"content","slug":"content","permalink":"http://jacegem.github.io/blog/tags/content/"}]},{"title":"HTML `<input>` checked 속성","slug":"2017/html_input_checked_attribute","date":"2017-02-08T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/html_input_checked_attribute/","link":"","permalink":"http://jacegem.github.io/blog/2017/html_input_checked_attribute/","excerpt":"","text":"HTML &lt;input&gt; checked 속성 http://www.w3schools.com/tags/att_input_checked.asp Example 선택된 체크박스가 포함된 폼의 HTML 코드 12345&lt;form action=&quot;demo_form.asp&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt; I have a bike&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot; checked&gt; I have a car&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt; 정의 및 사용법 checked 속성은 부울 속성입니다. checked 가 존재하면 그것은 페이지가 로드될 때 &lt;input&gt;가 미리 선택된 상태를 나타냅니다. (checked) checked 속성은 &lt;input type=&quot;checkbox&quot;&gt; 와 &lt;input type=&quot;radio&quot;&gt; 로 사용할 수 있습니다. 또한 checked 속성은 자바스크립트를 통해서 페이지가 로드된 후에도 설정할 수 있습니다. 브라우저 지원 표의 수치는 완전히 특성을 지원하는 브라우저 버전을 나타냅니다. Attribute checked 1.0 2.0 1.0 1.0 1.0 HTML 4.01 과 HTML5 에서의 차이점 없음 HTML 과 XHTML 에서의 차이점 XHTML에서는 속성 최소화가 금지되어 있습니다. checked 속성은 &lt;input checked=&quot;checked&quot; /&gt; 와 같이 지정해야 합니다. 문법 &lt;input checked&gt;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"HTML","slug":"Programming/HTML","permalink":"http://jacegem.github.io/blog/categories/Programming/HTML/"}],"tags":[{"name":"input","slug":"input","permalink":"http://jacegem.github.io/blog/tags/input/"},{"name":"html","slug":"html","permalink":"http://jacegem.github.io/blog/tags/html/"},{"name":"checked","slug":"checked","permalink":"http://jacegem.github.io/blog/tags/checked/"}]},{"title":"How TO - Animated Search Form","slug":"2017/how_to_-_animated_search_form","date":"2017-02-07T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/how_to_-_animated_search_form/","link":"","permalink":"http://jacegem.github.io/blog/2017/how_to_-_animated_search_form/","excerpt":"","text":"How TO - Animated Search Form 출처: http://www.w3schools.com/howto/howto_css_animated_search.asp CSS와 애니메이션 검색 폼을 작성하는 방법에 대해 알아봅니다. 애니메이션 검색 폼 생성 1단계 HTML 추가 Example 1&lt;input type=&quot;text&quot; name=&quot;search&quot; placeholder=&quot;Search..&quot;&gt; 2단계 CSS 추가 Example 12345678910.input[type=text] &#123; width: 130px; -webkit-transition: width 0.4s ease-in-out; transition: width 0.4s ease-in-out;&#125;/* When the input field gets focus, change its width to 100% */input[type=text]:focus &#123; width: 100%;&#125; HTML 폼 스타일하는 방법에 대한 자세한 내용 CSS 폼 튜토리얼에서 확인할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"CSS","slug":"Programming/CSS","permalink":"http://jacegem.github.io/blog/categories/Programming/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://jacegem.github.io/blog/tags/css/"},{"name":"animation","slug":"animation","permalink":"http://jacegem.github.io/blog/tags/animation/"},{"name":"search","slug":"search","permalink":"http://jacegem.github.io/blog/tags/search/"},{"name":"form","slug":"form","permalink":"http://jacegem.github.io/blog/tags/form/"}]},{"title":"Gitbook 과 GitHub 연동","slug":"2017/gitbook-integrated-with-github","date":"2017-02-06T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/gitbook-integrated-with-github/","link":"","permalink":"http://jacegem.github.io/blog/2017/gitbook-integrated-with-github/","excerpt":"","text":"Gitbook 과 GitHub 연동 Gitbook 세팅화면에 Github 메뉴가 생겼습니다. Github 저장소와 연결하면, Github에 소스를 올리면 해당 내용이 반영되서, Gitbooks에서 보여지게 됩니다. 문제 발생 Gitbook 에서 유투브 플러그인 사용하는데 이 부분이 문제가 되었습니다. 1&#123;% youtube %&#125;https://www.youtube.com/watch?v=fHyTA-UIcqs&#123;% endyoutube %&#125; 이때 &#123;% youtube %&#125; 를 인식할 수 없어 계속해서 오류가 발생합니다. 1Your site is having problems building: The tag youtube on line 5 in doc/ac1c_bc1c_c790_ac00_ac16_cd94_c5b4_c57c_d560_9_ac0.md is not a recognized Liquid tag. For more information, see https://help.github.com/articles/page-build-failed-unknown-tag-error/. GiHub Pages 사용 중지 프로젝트 → Settings 를 선택합니다. GiHub Pages 설정중에서 Source 를 None 으로 변경합니다. 변경 이후 꼭 Save 버튼을 클릭합니다.","categories":[{"name":"Service","slug":"Service","permalink":"http://jacegem.github.io/blog/categories/Service/"},{"name":"GitBook","slug":"Service/GitBook","permalink":"http://jacegem.github.io/blog/categories/Service/GitBook/"}],"tags":[{"name":"gitbook","slug":"gitbook","permalink":"http://jacegem.github.io/blog/tags/gitbook/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"integration","slug":"integration","permalink":"http://jacegem.github.io/blog/tags/integration/"}]},{"title":"[GeoServer] JSONP 활성화","slug":"2017/geoserver-jsonp-enable","date":"2017-02-04T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/geoserver-jsonp-enable/","link":"","permalink":"http://jacegem.github.io/blog/2017/geoserver-jsonp-enable/","excerpt":"","text":"[GeoServer] JSONP 활성화 web.xml 파일을 수정합니다. 톰캣에 설치한 경우는 아래 경로에 있습니다. /tomcat/webapps/geoserver/WEB-INF/web.xml 1234&lt;context-param&gt; &lt;param-name&gt;ENABLE_JSONP&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt;&lt;/context-param&gt; 위의 내용을 입력한 후 서버를 재시작하여 jsonp 를 활성화 합니다. 출처 https://gis.stackexchange.com/questions/57494/geoserver-2-3-how-to-enable-jsonp","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"GIS","slug":"Application/GIS","permalink":"http://jacegem.github.io/blog/categories/Application/GIS/"}],"tags":[{"name":"geoserver","slug":"geoserver","permalink":"http://jacegem.github.io/blog/tags/geoserver/"},{"name":"jsonp","slug":"jsonp","permalink":"http://jacegem.github.io/blog/tags/jsonp/"}]},{"title":"Geoserver CQL Filter 적용","slug":"2017/geoserver-cql-filter","date":"2017-02-03T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/geoserver-cql-filter/","link":"","permalink":"http://jacegem.github.io/blog/2017/geoserver-cql-filter/","excerpt":"","text":"Geoserver CQL Filter 적용 Geoserver에서 레이어 미리보기 실행 좌측 상단의 Toggle options toolbar 를 선택합니다. 하단 필터에 CQL 필터를 작성합니다. 정상적으로 작동하면, 레이어 설정 하단에 작성합니다.","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"GIS","slug":"Application/GIS","permalink":"http://jacegem.github.io/blog/categories/Application/GIS/"}],"tags":[{"name":"geoserver","slug":"geoserver","permalink":"http://jacegem.github.io/blog/tags/geoserver/"},{"name":"cql","slug":"cql","permalink":"http://jacegem.github.io/blog/tags/cql/"},{"name":"filter","slug":"filter","permalink":"http://jacegem.github.io/blog/tags/filter/"}]},{"title":"[jQuery] file upload","slug":"2017/file-upload","date":"2017-02-02T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/file-upload/","link":"","permalink":"http://jacegem.github.io/blog/2017/file-upload/","excerpt":"","text":"[jQuery] file upload file upload 를 구현한다. DB 에 입력되는 것을 디스크에 저장되도록 수정한다. 글로벌 프로퍼티 설정 12# for JFile propertiessystem.uploadpath = /upload 자바에서 해당 값을 주입합니다. 12@Value(&quot;#&#123;global[&#x27;system.uploadpath&#x27;]&#125;&quot;)private String fileBasePath; Value 어노테이션 사용을 위해 임포트를 추가합니다. 1import org.springframework.beans.factory.annotation.Value; 리퀘스트 맵핑을 등록하고 함수를 구현합니다. 1234@RequestMapping(&quot;/fileUploadDisk.json&quot;)public void fileUploadDisk(RMap rmap, ModelMap model, @RequestParam(&quot;file&quot;) MultipartFile file) throws IOException &#123; //&#125; @RequestParam(“file”)를 통해서 멀티파트파일 정보는 file 변수에 담기게 됩니다. 업로드 대상 URL 정보를 위에서 설정한 주소로 변경합니다. 1url : &quot;/web/common/file/fileUploadDisk.json&quot; jQuery.uploadfile 플러그인을 사용중이므로 아래와 같이 설정합니다. 123456789101112131415161718192021// 파일 업로드upload = $(&quot;#spreadRegistFile&quot;).uploadFile(&#123; url : &quot;/file/fileUploadDisk.json&quot;, fileName : &quot;file&quot;, autoSubmit : false, dragDropStr : &#x27;&#x27;, uploadStr : &#x27;등록&#x27;, showQueueDiv : &#x27;spreadRegistFileQueue&#x27;, dragdropWidth : 150, statusBarWidth : 140, maxFileCount : 5, showError : false, showProgress : false, onSuccess : function(files, data, xhr, pd) &#123; toast.push(Object.toJSON(files)); upload.reset(); &#125;, onError : function(files, status, errMsg, pd) &#123; toast.push(errMsg); &#125;&#125;); controller 구현 service 구현 1234public int insertFileInfo(RMap rmap, ModelMap model) &#123; rmap.put(&quot;user_id&quot;, rmap.getSession().getAttribute(&quot;user_id&quot;)); return dao.insert(&quot;web.common.insertFileInfo&quot;, rmap);&#125; mybatis 구현 insert 태그 추가 1234&lt;insert id=&quot;insertFileInfo&quot;&gt; /* web.common.insertFileInfo */ ...&lt;/insert&gt; 저장할 대상 123456- #&#123;file_seq&#125;- #&#123;file_size&#125;- #&#123;file_type&#125;- #&#123;original_file_name&#125;- #&#123;file_name&#125;- #&#123;file_path&#125; 123456789101112131415161718192021222324252627282930&lt;!-- 파일 등록 --&gt;&lt;insert id=&quot;insertFileInfo&quot;&gt; /* web.common.insertFileInfo */ INSERT INTO FILE_INFO ( FILE_SEQ , FILE_NO , FILE_SIZE , FILE_TYPE , ORIGINAL_FILE_NAME , FILE_NAME , FILE_PATH , REG_USER , REG_DATE , LAST_DATE ) VALUES ( #&#123;file_seq&#125; , (SELECT COALESCE(MAX(FILE_NO),0)+1 FROM FILE_INFO WHERE FILE_SEQ = #&#123;file_seq&#125;) , #&#123;file_size&#125; , #&#123;file_type&#125; , #&#123;original_file_name&#125; , #&#123;file_name&#125; , #&#123;file_path&#125; , #&#123;user_id&#125; , TO_CHAR(NOW(), &#x27;YYYYMMDDHH24MISS&#x27;) , TO_CHAR(NOW(), &#x27;YYYYMMDDHH24MISS&#x27;) ) &lt;/insert&gt; 저장된 것을 확인한다. 파일 불러오기 조회시에, original_file_name을 가져오도록 수정. 화면 출력시에도 이름 변경해야 함. 파일을 선택했을 때, 요청하는 부분을 수정하자. 이미지의 경우 팝업 화면을 보여주고, 동영상의 경우 다운로드 되도록 처리한다. 이미지 1onclick=&quot;wutil.popup(seq, no)&quot; 1url : &quot;/file/attachPop.do&quot;, JSP에서 이미지를 요청한다. 1&lt;img src=&quot;&lt;c:url value=&#x27;/web/common/file/attachImage.do?seq=$&#123;seq&#125;&amp;no=$&#123;no&#125;&#x27;/&gt;&quot; width=&quot;550&quot; /&gt; 1UMap umap = commonService.selectAttachFile(rmap, model); 12345678910111213141516171819@RequestMapping(&quot;/attachImage.do&quot;)public void attachImage(RMap rmap, ModelMap model, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; // 파일 경로를 조회한다. UMap umap = commonService.selectAttachFile(rmap, model); String attach_file_path = (String) umap.get(&quot;attach_file_path&quot;); System.out.println(attach_file_path); // 바이너리를 전송한다. try&#123; Path path = Paths.get(attach_file_path); byte[] data = Files.readAllBytes(path); response.setContentType(&quot;image/jpeg&quot;); response.getOutputStream().write(data); &#125; catch(Exception e) &#123; e.printStackTrace(); logger.debug(&quot;파일 생성중 오류 발생&quot;,e); &#125;&#125; 동영상 1onclick=&quot;wutil.download(seq, no)&quot; 1window.location = &quot;/file/fileDownload.do?seq=&quot; + seq + &quot;&amp;no=&quot; + no;","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"http://jacegem.github.io/blog/tags/jquery/"},{"name":"file","slug":"file","permalink":"http://jacegem.github.io/blog/tags/file/"},{"name":"upload","slug":"upload","permalink":"http://jacegem.github.io/blog/tags/upload/"}]},{"title":"FastCampus 시스템 트레이딩","slug":"2017/fastcampus-system-trading","date":"2017-01-31T15:00:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/fastcampus-system-trading/","link":"","permalink":"http://jacegem.github.io/blog/2017/fastcampus-system-trading/","excerpt":"","text":"FastCampus 시스템 트레이딩 http://www.fastcampus.co.kr/fin_camp_algot/?utm_source=google&amp;utm_medium=cpc&amp;utm_campaign=fin_camp_algot_2&amp;gclid=CPXH3PftwNMCFQJ9vQodmtEDnw http://www.fastcampus.co.kr/fin_camp_pythonstarter/#! https://www.codecademy.com/ko/tracks/python-ko 1 주차 알고리즘 트레이딩의 개요와 시스템 개발을 위한 필수 라이브러리와 환경구축에 대해 배웁니다. [Algorithmic Trading] 알고리즘 트레이딩의 개요 알고리즘 트레이딩의 장단점 및 시스템 구성 금융데이터 분석을 빠른 시간 내에 처리할 수 있는 Pandas 라이브러리에 대해 배웁니다. 아울러 그래프를 쉽게 그려주는 Matplotlib의 사용법을 익힙니다. [Pandas &amp; Matplotlib] Pandas 소개, Pandas Data 구조, Pandas 핵심 기능 Matplotlib 그래프 그리기 [파이썬 개발환경구축] 알고리즘 트레이딩 시스템 개발을 위한 환경 설명 개발환경 구축 2 주차 알고리즘 트레이딩 시스템과 HTS 연동 및 주가 데이터 다운로드 [HTS API 연동 프로그램 개요] HTS 연동 환경 구축 키움증권 API를 이용한 HTS 연동 MySQL을 이용한 주가 데이터 저장 및 활용방법 설명 [실습] 코스닥, 코스피 종목 코드 다운로드 키움증권 API를 이용한 일단위, 분단위 데이터 다운로드 프로그램 개발 대신증권 API를 이용한 일단위, 분단위 데이터 다운로드 프로그램 개발 MySQL을 이용한 주가데이터 액세스 프로그램 개발 3 주차 확률통계를 이용한 종목분석 평균, 분산, 표준편차 등 통계와 확률의 기본 개념을 배운 후, Pandas와 Numpy를 이용해 데이터 분석의 시작인 기초 통계, 상관 관계 등을 파이썬을 이용해 직접 구해봅니다. [Basic Statistics and Probability] 통계 기본 개념 기초 통계 확률 기본 개념 [실습] 통계를 이용한 종목 특성 분석 Skewness, Kurtosis 등의 통계치를 이용한 포트폴리오 선정 4 주차 알고리즘 트레이딩의 중요한 수학적 토대인 시계열 분석을 배웁니다. Random Walk 이론과 Stationarity 등의 시계열 데이터 특성과 ARMA, VAR, GARCH 등을 소개합니다. [Time Series Analysis] Time Series Data 특성 랜덤 과정 정상 시계열 과정 ARMA, VAR, GARCH [실습] ARMA을 이용한 투자 모델 개발 GARCH를 이용한 투자 모델 개발 5 주차 앞서 배운 시계열 분석을 이용한 모델의 평가와 알고리즘 트레이딩에 적용 가능한 종목을 선정하는 방법을 배웁니다. [Backtesting] Backtesting 개요 BackTesting을 위한 개발 환경 구축 모델 성능 평가 방법 ARMA, GARCH 모델 Backtesting 실습 [Portfolio 구성] Random Walk Stationarity Test 종목 선정 6 주차 알고리즘 트레이딩에 있어 기저가 되는 Mean Reversion 모델에 대해 알아보고, 과거 데이터를 이용해 거래에 따른 수익을 테스트해봅니다. [Mean Reversion Model] Mean Reversion Model 개요 Mean Reversion Model 구현 Mean Reversion Model 유의사항 [실습] Mean Reversion Model 개발 7 주차 Mean Reversion의 발전된 모델인 Pairs Trading Model에 대해 설명하고, 이를 직접 구현해 Backtesting을 실시합니다. [Pairs Trading Model] Pairs Trading Model 개요 Cointegration, PCA 그리고 Johansen Test Pairs Trading Model 구현 [실습] Pairs Trading Model 개발 ETF와 주식을 연동한 Pairs Trading Model 개발 8 주차 개발한 모델의 위험관리를 위한 이론적 배경과 활용가능한 모델들을 설명하고, 직접 구현합니다. [Risk Management] GARCH를 이용한 Volatility Modelling VaR (Value at Risk) Risk Management를 위한 적절한 확률분포 선택 [실습] GARCH를 이용한 Volatility Model 개발 VaR,CVaR 개발","categories":[{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"ETC","slug":"Conference/ETC","permalink":"http://jacegem.github.io/blog/categories/Conference/ETC/"}],"tags":[{"name":"system","slug":"system","permalink":"http://jacegem.github.io/blog/tags/system/"},{"name":"trading","slug":"trading","permalink":"http://jacegem.github.io/blog/tags/trading/"}]},{"title":"이클립스 코드정렬에서 span 태그 정렬","slug":"2017/eclipse-formatting-span","date":"2017-01-21T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/eclipse-formatting-span/","link":"","permalink":"http://jacegem.github.io/blog/2017/eclipse-formatting-span/","excerpt":"","text":"이클립스 코드정렬에서 span 태그 정렬 이클립스에서 Ctrl + Shift + f 키를 눌러서 코드 정렬을 실행합니다. 1234&lt;span class=&quot;area-select&quot;&gt; &lt;label for=&quot;count_1&quot; class=&quot;sub-title&quot;&gt;이름&lt;/label&gt; &lt;input type=&quot;text&quot; title=&quot;이름 입력&quot; id=&quot;name&quot; name=&quot;name&quot; class=&quot;sub-box&quot;&gt;&lt;/span&gt; &lt;span class=&quot;area-select&quot;&gt; &lt;label for=&quot;count_2&quot; class=&quot;sub-title&quot;&gt;생년월일&lt;/label&gt; &lt;input type=&quot;text&quot; title=&quot;생년월일 입력&quot; placeholder=&quot;선택하세요&quot; name=&quot;birth&quot; id=&quot;birth&quot; class=&quot;txt-calendar sub-box datepicker2&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn-calendar&quot;&gt;달력&lt;/button&gt;&lt;/span&gt; &lt;span class=&quot;area-select&quot;&gt; &lt;span class=&quot;sub-title&quot;&gt;성별&lt;/span&gt; 위와 같이 span 태그가 구분되지 않고 한줄에 나오는 경우 옵션을 수정합니다. 옵션 수정 메뉴 Window -&gt; Preferences -&gt; Web -&gt; HTML Files -&gt; Editor 를 선택합니다. 우측 Line width 의 값을 999로 수정합니다. (혹은 알맞은 수로 변경합니다. 한줄에 나오는 최대 문자열 수 입니다.) inline Elements 에서 span을 선택한 후 Remove 버튼을 클릭하여 해당 태그를 제거합니다. 이후 Ctrl + Shift + f 키를 눌러서 코드 정렬을 실행합니다. 1234567&lt;span class=&quot;area-select&quot;&gt; &lt;label for=&quot;count_1&quot; class=&quot;sub-title&quot;&gt;이름&lt;/label&gt; &lt;input type=&quot;text&quot; title=&quot;이름 입력&quot; id=&quot;name&quot; name=&quot;name&quot; class=&quot;sub-box&quot;&gt;&lt;/span&gt;&lt;span class=&quot;area-select&quot;&gt; &lt;label for=&quot;count_2&quot; class=&quot;sub-title&quot;&gt;생년월일&lt;/label&gt; &lt;input type=&quot;text&quot; title=&quot;생년월일 입력&quot; placeholder=&quot;선택하세요&quot; name=&quot;birth&quot; id=&quot;birth&quot; class=&quot;txt-calendar sub-box datepicker2&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn-calendar&quot;&gt;달력&lt;/button&gt;&lt;/span&gt; span 태그가 새 줄로 정렬되는 것을 확인 할 수 있습니다. 출처 https://stackoverflow.com/questions/10298024/eclipse-html-editor-each-input-tag-on-the-new-line","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"IDE","slug":"Application/IDE","permalink":"http://jacegem.github.io/blog/categories/Application/IDE/"}],"tags":[{"name":"tag","slug":"tag","permalink":"http://jacegem.github.io/blog/tags/tag/"},{"name":"eclipse","slug":"eclipse","permalink":"http://jacegem.github.io/blog/tags/eclipse/"},{"name":"formatting","slug":"formatting","permalink":"http://jacegem.github.io/blog/tags/formatting/"},{"name":"span","slug":"span","permalink":"http://jacegem.github.io/blog/tags/span/"}]},{"title":"[dokuwiki] - snippet 안보이게 처리","slug":"2017/dokuwiki-snippet","date":"2017-01-20T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/dokuwiki-snippet/","link":"","permalink":"http://jacegem.github.io/blog/2017/dokuwiki-snippet/","excerpt":"","text":"[dokuwiki] - snippet 안보이게 처리 도쿠위키에서 마크다운으로 코드를 작성하면 코드 상단부에 다운로드 링크가 생긴다. 이를 제거하기 위해 \\dokuwiki\\inc\\parser\\xhtml.php 파일을 수정합니다. 615번째 줄 _hightlight 함수 안에 해당 내용을 추가합니다. 1234function _highlight($type, $text, $language = null, $filename = null) &#123; $filename = null; ...&#125; 강제적으로 파라미터로 넘어온 파일명을 null로 변경하여, 화면상에 출력되지 않도록 합니다. 출처 http://doku.ml/open/snippet_안보이게_처리","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Wiki","slug":"Application/Wiki","permalink":"http://jacegem.github.io/blog/categories/Application/Wiki/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"http://jacegem.github.io/blog/tags/wiki/"},{"name":"dokuwiki","slug":"dokuwiki","permalink":"http://jacegem.github.io/blog/tags/dokuwiki/"},{"name":"revealjs","slug":"revealjs","permalink":"http://jacegem.github.io/blog/tags/revealjs/"},{"name":"snippet","slug":"snippet","permalink":"http://jacegem.github.io/blog/tags/snippet/"}]},{"title":"도쿠위키에서 reveal.js 사용하기","slug":"2017/dokuwiki-revealjs","date":"2017-01-19T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/dokuwiki-revealjs/","link":"","permalink":"http://jacegem.github.io/blog/2017/dokuwiki-revealjs/","excerpt":"","text":"도쿠위키에서 reveal.js 사용하기 revealjs 도쿠위키 플러그인을 설치하여 revealjs 를 사용합니다. 마크다운 텍스트를 사용하여 발표화면을 만들 수 있습니다. 문서는 이곳에서 확인 할 수 있습니다. 사용 가능한 테마 (Available themes) Reveal.js 테마를 사용할 수 있습니다. 가능한 값 : black white beige blood league default moon night serif simple sky solarized dokuwiki 기본값은 white 입니다. 컨트롤 (Controls) reveal.js 컨트롤을 표시합니다. 두 값 false true 기본값는 false 입니다. 프로그래스 바 (Progress bar) reveal.js 프로그래스 바를 표시합니다. 두 값 false true 기본값은 false 입니다. 모든 목록 작성 (Build all lists) 한 목록씩 작성할지 여부를 설정합니다. 두 값 false true 기본값은 false 입니다. 전환 (Transition) 슬라이드 전환. 가능한 설정: none fade slide convex concave zoom 기본값은 fade 입니다. 수평 슬라이드 레벨 Horizontal slide level 이 레벨 이상의 헤더는 수평 슬라이드를 시작합니다. 수직 (중첩) 슬라이드 시작 레벨 아래 - 슬라이드에 영향을주지 않으며 대체 슬라이드 표시기 (----&gt; 및 ----&gt;&gt;)로 표시됩니다. 가능한 설정 : 1H1 에서 슬라이드를 구별할지, H2에서 슬라이드를 구별하지를 설정합니다. 1 2 기본값은 2 입니다. 세로 슬라이드 머리글 확대 Enlarge vertical slide headers horizontal_slide_level 아래 슬라이드의 헤더를 확대합니다 - 슬라이드에 영향을주지 않으며 대체 슬라이드 표시 ( ----&gt; 및 ----&gt;&gt;)로 표시됩니다. 부울 false true 기본값은 false 입니다. 이미지 테두리 Image borders 이미지 테두리를 표시합니다 (Reveal.js의 기본값). 부울 : false true 기본값은 false 입니다. 크기 Size 슬라이드의 기본 크기 (픽셀 단위) - 사용 가능한 공간에 맞게 슬라이드가 확대됩니다. 1&lt;width&gt;x&lt;height&gt; 기본값은 960x700 입니다. 지원되는 dokuwiki 구문 헤드 라인, 테이블, 기울임 꼴, 굵은 글씨체와 같은 일반적인 것들을 제외하고 다음과 같은 구문 요소가 지원됩니다. 이미지 정렬 : 왼쪽 또는 오른쪽 또는 가운데 맞춤 dokuwiki plugin wrap의 &lt;wrap lo&gt; &lt;/ wrap&gt; 및 &lt;WRAP lo&gt; &lt;/ WRAP&gt;는 작은 텍스트로 표시됩니다. &lt;WRAP clear&gt;&lt;/WRAP&gt; 추가 구문 Extra syntax 테마 선택 및 프레젠테이션 시작 버튼 페이지 상단에 1~~REVEAL~~ 이 위치에 버튼을 삽입합니다. 이 버튼을 클릭하면 기본 테마로 프레젠테이션이 시작됩니다. 또는 테마를 선택하려면 1~~REVEAL theme_name~~ theme_name에 &quot;사용 가능한 테마&quot;아래에 나열된 reveal.js 테마 중 하나로 대체합니다. 다른 모든 옵션은 URL 쿼리 매개 변수 구문을 사용하여 wiki 페이지에서 덮어 쓸 수 있습니다. 1~~REVEAL theme=sky&amp;transition=convex&amp;controls=1&amp;show_progress_bar=1&amp;build_all_lists=1&amp;show_image_borders=0&amp;horizontal_slide_level=2&amp;enlarge_vertical_slide_headers=0&amp;show_slide_details=1&amp;open_in_new_window=1~~ 부울 값은 숫자 (1 또는 0) 여야합니다. 프리젠테이션이 시작된 후 URL에서 직접 옵션을 변경하려면 페이지 맨 위에 ~~NOCACHE~~를 넣어 DokuWiki의 캐싱을 비활성화해야합니다. 슬라이드 배경 Slide background 플러그인에서 구문을 소개합니다. 1&#123;&#123;background&gt;parameters&#125;&#125; 가능한 모든 매개 변수에 대해서는 아래의 대체 슬라이드 표시기를 참조하십시오. 이렇게 정의된 배경은 다음 슬라이드에 적용됩니다. 배경 태그는 다음 슬라이드를 여는 제목보다 앞에 있어야하며 해당 슬라이드에만 적용됩니다. 예를 들어 12345678&#123;&#123;background&gt;:wiki:dokuwiki-128.png&#125;&#125;===== my heading=====배경이 `있는` 슬라이드===== my second heading=====배경이 `없는` 슬라이드 배경이 있는 슬라이드 하나와 배경이 없는 두 번째 슬라이드를 만듭니다. 대체 슬라이드 표시기 Alternative slide indicators 1234567---- salmon wiki:dokuwiki-128.png 10% repeat bg-slide no-footer ----&gt;&lt;notes&gt;This slide has no content, but therefore a fancy background...&lt;/notes&gt;&lt;---- -----&gt;는 기본 속도로 기본 슬라이드로 새로운 슬라이드를 엽니 다 (열려있는 이전 슬라이드는 암시 적으로 닫힙니다) 전체 예제 - 매개 변수는 CSS와 같이 동적으로 파싱됩니다. 매개 변수 순서는 중요하지 않으며 모든 키워드를 공백으로 분리했기 때문에 공백을 사용할 수 없습니다: ---- orange wiki:dokuwiki-128.png 10% repeat bg-slide zoom-in fade-out slow no-footer ----&gt; 가능한 모든 HTML 색상 및 코드가 지원됩니다: red, #f00, #ff0000, rgb(255,0,0), rgba(255,0,0,0.5), hsl(0,100%,50%), hsla(0,100%,50%,0.5) 배경 이미지는 gif, png, jpg, jpeg, svg 인 경우 대문자와 소문자를 구분하지 않으며 DokuWiki 이미지 식별자 (:wiki:dokuwiki-128.png) 또는 일반적인 이미지 링크(‘http://host.tld/path/to/image.png’)를 사용합니다. 배경 이미지 크기는 후위 %와px 또는auto,contain 및cover 키워드로 인식됩니다. (Reveal.js의 기본값은 cover입니다) 예 :10 %또는250px (일반적으로 백분율 값만 사용하는 것이 좋습니다. 나머지 슬라이드에서는 크기를 조정하고 위키 페이지의 슬라이드 배경 미리보기는 &quot;실제&quot;미리보기를 표시합니다) 배경 이미지의 위치는top,bottom,left,right,center 키워드에 의해 인식됩니다 (Reveal.js의 기본값은 center입니다). xx, y 값은 px 또는 %로 대체됩니다. : 상단 왼쪽, 하단 중앙, 3 %, 5 %, 20px, 5 % (이미지 크기와 위치를 구별하기 위해 쉼표가 필요합니다. 일반적으로 퍼센트 값만 사용하는 것이 좋습니다. 슬라이드의 나머지 부분과 wiki 페이지의 슬라이드 배경 미리보기를 조정하면 &quot;실제&quot;미리보기가 표시됩니다.) 배경 이미지 반복은 키워드repeat에 의해 인식됩니다 (Reveal.js에서는 no-repeat가 기본값 임). 배경 전환 : 접두어 bg-뒤에 none,fade,slide,convex,concave 또는zoom이 옵니다. 슬라이드 전환 : none, fade, slide, convex, concave 또는 zoom 뒤에 -in 또는 -out 를 붙여서 슬라이드에 다른 전환을 설정합니다. 전환 속도 : default, fast, slow ----&gt;&gt;는 수직 (중첩 된) 슬라이드를위한 새로운 슬라이드 컨테이너와 주어진 옵션을 가진 새로운 슬라이드를 엽니 다. 예 :---- red zoom ----&gt;&gt; 다음 ----&gt;&gt;는 암시 적으로 이전 컨테이너(또는 슬라이드)를 닫습니다. 기술적 세부 사항: 렌더링에서 슬라이드 모드가 &quot;headers driven&quot;에서 &quot;special horizontal rule driven&quot;으로 변경됩니다.이 모드에서는 헤더가 더 이상 슬라이드 변경 적용되지 않습니다. 이 대체 슬라이드 표시기로 전체 프리젠테이션을 물론 만들 수 있습니다. 이 슬라이드 모드에서 나가려면 슬라이드 또는 컨테이너를 명시 적으로 닫을 방법이 필요합니다. &lt;&lt;----는 슬라이드 컨테이너를 닫습니다. &lt;----는 슬라이드를 닫습니다 12`-` 네 개가 이어져 있습니다.컨테이너가 슬라이드를 포함하는 관계입니다. 바닥글 Footers 때로는 모든 페이지에 대해 꼬리말을 원할 수도 있습니다. 이 꼬리말에는 회사의 로고 또는 이와 유사한 내용이 포함되어있을 수 있습니다. 꼬리말은 dokuwiki 플러그인 &quot;wrap&quot;을 사용하여 가장 편리하게 추가 할 수 있습니다. 문서 첫 부분 즉 첫 번째 제목 앞에있는 ~~NOCACHE~~ 또는 ~~REVEAL~~ 다음 블록에 각 페이지의 바닥 글을 가져 오려면 1&lt;wrap footer&gt;Footer content here.&lt;/wrap&gt; 이렇게하면 모든 단일 페이지에 바닥 글이 삽입됩니다. 특정 페이지 위치에서 바닥 글을 사라지게 하려는 경우 해당 페이지의 표제 전에 &#123;&#123;no-footer&#125;&#125;를 삽입합니다. 예를 들어 1234567891011121314151617181920212223242526272829&#123;&#123;no-footer&#125;&#125;===== my heading=====바닥글이 없는 슬라이드&#123;&#123;no-footer&#125;&#125;&#123;&#123;background&gt;:images:image1.png&#125;&#125;===== my heading=====Slide without footer and with background&#123;&#123;background&gt;:images:image1.png no-footer&#125;&#125;===== my heading=====no-footer as option in background definition---- no-footer ----&gt;Slide with alternative slide indicator----&gt;Next slide with footer and stop alternativeslide indicator mode&lt;---- 발표자 노트 Speaker notes https://github.com/hakimel/reveal.js#speaker-notes 키워드: (매개 변수 없음) 위키 페이지에서 변경하지 않음 슬라이드 쇼에서 내용은 및 - 보이지 않는 (발표자 노트에만 표시됨 - 단축키 s) 메모의 목록은 목록이 보이지 않고 명백한 효과없이 각 항목에 대해 다음 키를 눌러야하기 때문에 항상 증분이 아닙니다. Example: 1234&lt;notes&gt;- your content- here&lt;/notes&gt; 단편 Fragments https://github.com/hakimel/reveal.js#fragments 인라인 사용을 위한 &lt;fragment&gt; (지원되는 서식 및 대체 만) 모든 Wiki 내용에 대한 &lt;fragment-block&gt; 전역 옵션을 겹쳐 쓰려면 &lt;fragment-list&gt; build_all_lists (false 인 경우) 글로벌 옵션을 덮어 쓰기위한 &lt;no-fragment-list&gt; build_all_lists (true 인 경우) 가능한 경우 스타일 및 색인 지원 - example_presentation.dokuwiki 및 http://lab.hakim.se/reveal-js/#/7/1 참조 Example: 12345&lt;fragment&gt;Hit the next arrow...&lt;/fragment&gt;&lt;fragment&gt;... to step through ...&lt;/fragment&gt;&lt;fragment&gt;... a&lt;/fragment&gt; &lt;fragment&gt;fragmented&lt;/fragment&gt; &lt;fragment&gt;slide.&lt;/fragment&gt; PDF 출력 프레젠테이션을 PDF로 내보낼 수 있습니다. 이렇게하려면 URL에 &amp;print-pdf를 추가하십시오. 페이지를 편집 할 수 있으면 슬라이드 쇼 시작 버튼 아래에 PDF 내보내기 링크가 렌더링됩니다. 예를 들어 DokuWiki reveal.js 프리젠 테이션의 URL이 대개 1http://example-dokuwiki.com/doku.php?do=export_revealjs&amp;id=example:page 브라우저의 주소 표시 줄에서 이를 수동으로 변경 해야합니다. 1http://example-dokuwiki.com/doku.php?do=export_revealjs&amp;id=example:page&amp;print-pdf 그 후 프리젠테이션은 브라우저에서 이상하게 보이지만 브라우저의 인쇄 기능을 통해 인쇄 할 수 있습니다. 공식적으로 Chromium 및 Chrome 만 PDF 내보내기 용으로 지원됩니다. Reveal.js PDF 내보내기 문서도 확인하십시오.","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Wiki","slug":"Application/Wiki","permalink":"http://jacegem.github.io/blog/categories/Application/Wiki/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"http://jacegem.github.io/blog/tags/wiki/"},{"name":"dokuwiki","slug":"dokuwiki","permalink":"http://jacegem.github.io/blog/tags/dokuwiki/"},{"name":"revealjs","slug":"revealjs","permalink":"http://jacegem.github.io/blog/tags/revealjs/"}]},{"title":"도쿠위키 Changes Plugin","slug":"2017/dokuwiki-changes-plugin","date":"2017-01-18T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/dokuwiki-changes-plugin/","link":"","permalink":"http://jacegem.github.io/blog/2017/dokuwiki-changes-plugin/","excerpt":"","text":"도쿠위키 Changes Plugin 플러그인 설치 도쿠위키에서 changes 플러그인을 설치합니다. 도쿠위키 확장플러그인 설치에서 changes 로 검색해도 찾을 수가 없습니다. 플러그인 페이지로 이동하여 zip 파일을 다운 받습니다. 그 후, 수동 설치 메뉴에서 다운 받은 파일을 선택하여 해당 플러그인을 설치합니다. 또는 URL (https://github.com/cosmocode/changes/zipball/master)을 입력하여 설치합니다. 문법 및 사용 1&#123;&#123;changes&gt;&#125;&#125; 이름공간으로 제어 Whitelist/blacklist by namespace 추가대상 12&#123;&#123;changes&gt;foo&#125;&#125;&#123;&#123;changes&gt;ns=foo&#125;&#125; 제외대상 12&#123;&#123;changes&gt;ns = -foo&#125;&#125;&#123;&#123;changes&gt;ns = foo, bar, -bar:baz&#125;&#125; 결과 위와 같이 최근에 수정된 사항이 목록으로 표출됩니다. 출처 http://doku.ml/open/changes_플러그인_사용 https://www.dokuwiki.org/plugin:changes","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Wiki","slug":"Application/Wiki","permalink":"http://jacegem.github.io/blog/categories/Application/Wiki/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"http://jacegem.github.io/blog/tags/wiki/"},{"name":"dokuwiki","slug":"dokuwiki","permalink":"http://jacegem.github.io/blog/tags/dokuwiki/"}]},{"title":"django 프로젝트 생성","slug":"2017/django","date":"2017-01-17T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/django/","link":"","permalink":"http://jacegem.github.io/blog/2017/django/","excerpt":"","text":"django 프로젝트 생성 프로젝트 생성 Google App Engine 에서 Django 사용하기 문자열 반환 URL 추가 1url(r&#x27;^view/&#x27;, view.test), 함수 생성 12def test(request): return HttpResponse(&quot;Hello, world. You&#x27;re at the polls index.&quot;) 템플릿 반환 URL 추가 1url(r&#x27;^index/&#x27;, view.index), 함수 행성 1234def index(request): msg = &#x27;My Message&#x27; return render(request, &#x27;index.html&#x27;, &#123;&#x27;message&#x27;: msg&#125;) /templates/index.html 파일 생성 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;&#123;&#123;message&#125;&#125;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 참고 http://pythonstudy.xyz/python/article/307-Django-템플릿-Template http://i5on9i.blogspot.kr/2016/09/google-app-engine-django.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"django","slug":"django","permalink":"http://jacegem.github.io/blog/tags/django/"}]},{"title":"windows에서 django mysqldb 연결 시 에러","slug":"2017/django-mysqldb","date":"2017-01-16T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/django-mysqldb/","link":"","permalink":"http://jacegem.github.io/blog/2017/django-mysqldb/","excerpt":"","text":"windows에서 django mysqldb 연결 시 에러 1Error loading MySQLdb module: No module named &#x27;MySQLdb&#x27; You can use mysqlclient instead of MySQLdb. MySqLdb is not compatible with Python 3. 1pip install mysqlclient 접속정보 설정 123456789101112# settings.pyDATABASES = &#123; &#x27;default&#x27;:&#123; &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;, &#x27;NAME&#x27;: &#x27;TABLE_NAME&#x27;, &#x27;USER&#x27;: &#x27;USER&#x27;, &#x27;PASSWORD&#x27;: &#x27;PASSOWRD&#x27;, &#x27;HOST&#x27;: &#x27;HOST&#x27;, &#x27;PORT&#x27;: &#x27;PORT&#x27; &#125;&#125; 출처 http://stackoverflow.com/questions/39574813/error-loading-mysqldb-module-no-module-named-mysqldb","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"django","slug":"django","permalink":"http://jacegem.github.io/blog/tags/django/"}]},{"title":"ImportError: cannot import name `update_contenttypes`","slug":"2017/django-import-error-update-contenttypes","date":"2017-01-15T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/django-import-error-update-contenttypes/","link":"","permalink":"http://jacegem.github.io/blog/2017/django-import-error-update-contenttypes/","excerpt":"","text":"ImportError: cannot import name ‘update_contenttypes’ 장고에서 update_contenttypes 임포트 에러 발생시 django.contrib.contenttype.apps.py 를 수정합니다. django 1.11 버전에서 생기는 오류 인것으로 보입니다. 12345from .management import ( inject_rename_contenttypes_operations, # update_contenttypes, create_contenttypes,) 기존의 update_contenttypes 대신 create_contenttypes로 수정합니다. 12345def ready(self): pre_migrate.connect(inject_rename_contenttypes_operations, sender=self) # post_migrate.connect(update_contenttypes) post_migrate.connect(create_contenttypes) checks.register(check_generic_foreign_keys, checks.Tags.models) 마찬가지로, update_contenttypes 대신 create_contenttypes로 수정합니다. 출처 https://code.djangoproject.com/ticket/28092#no1","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"django","slug":"django","permalink":"http://jacegem.github.io/blog/tags/django/"}]},{"title":"장고의 설계 원칙","slug":"2017/django-design-philosophy","date":"2017-01-14T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/django-design-philosophy/","link":"","permalink":"http://jacegem.github.io/blog/2017/django-design-philosophy/","excerpt":"","text":"장고의 설계 원칙 https://docs.djangoproject.com/en/1.7/misc/design-philosophies/ https://docs.djangoproject.com/en/1.11/misc/design-philosophies/ 일반 사항 약한 결합(Loose coupling) 경량 코드(Less code) 신속 개발(Quick development) 반복 방지(DRY, Don’t Repeat Yourself) 암시보다는 명시적으로 표현(Explicit is better than implicit) 일관성(Consistency) 모델 암시보다는 명시적으로 표현(Explicit is better than implicit) 관련 도메인 로직을 모두 포함(Include all relevant domain logic) 데이터베이스 API SQL 효율성(SQL efficiency) 간결하고 강력한 문법(Terse, powerful syntax) 필요 시 쉽게 작성할 수 있는 SQL(Option to drop into raw SQL easily, when needed) URL 설계 약한 결합(Loose coupling) 제약없는 유연설(Infinite flexibility) 베스트 프랙티스 권장(Encourage best practices) 결정적인 URL(Definitive URLs) 템플릿 시스템 표현과 로직의 분리(Separate logic from presentation) 중복 배제(Discourage redundancy) HTML과 분리(Be decoupled from HTML) 템플릿 언어로 XML 금지(XML should not be used for template languages) 디자이너의 능력 가정(Assume designer competence) 여백을 확실하게 처리(Treat whitespace obviously) 프로그래밍 언어를 만들지 말자(Don’t invent a programming language) 안정성과 보안(Safety and security) 확장성(Extensibility) 뷰 간단함(Simplicity) 요청 객체의 사용(Use request objects) 약한 결합(Loose coupling) GET, POST 간 차이(Differentiate between GET and POST) 캐시 시스템 경량 코드(Less code) 일관성(Consistency) 확장성(Extensibility) 링크 http://doku.ml/open/장고의_설계_원칙","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"}]},{"title":"django-celery 장고에 스케쥴 설정","slug":"2017/django-celery","date":"2017-01-13T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/django-celery/","link":"","permalink":"http://jacegem.github.io/blog/2017/django-celery/","excerpt":"","text":"django-celery 장고에 스케쥴 설정 django-celery 설치 1pip install django-celery proj/proj/settings.py 수정 12345INSTALLED_APPS = [ ... &#x27;djcelery&#x27;, &#x27;kombu.transport.django&#x27;,] 데이터베이스 테이블 생성 12python manage.py makemigrationspython manage.py migrate proj/proj/settings.py 수정 12345import djcelerydjcelery.setup_loader()BROKER_URL = &#x27;django://&#x27;CELERYBEAT_SCHEDULER = &#x27;djcelery.schedulers.DatabaseScheduler&#x27; proj/app/tasks.py 파일 생성 123456import datetimeimport celery@celery.decorators.periodic_task(run_every=datetime.timedelta(minutes=1))def myfunc(): print(&#x27;periodic_task&#x27;) 1234567from celery.task import periodic_taskfrom celery.schedules import crontab@periodic_task(run_every=crontab(hour=&quot;*&quot;, minute=&quot;0&quot;, day_of_week=&quot;*&quot;), ignore_result=True)def my_test(): print(&#x27;periodic_task&#x27;, &#x27;my_test&#x27;) 실행 1python manage.py celery worker --loglevel=DEBUG -E -B -c 1 admin 페이지 접속 1http://127.0.0.1:9000/admin/djcelery/ crontab 설정법 http://docs.celeryproject.org/en/latest/userguide/periodic-tasks.html","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"django","slug":"django","permalink":"http://jacegem.github.io/blog/tags/django/"},{"name":"celery","slug":"celery","permalink":"http://jacegem.github.io/blog/tags/celery/"},{"name":"schedule","slug":"schedule","permalink":"http://jacegem.github.io/blog/tags/schedule/"}]},{"title":"ConoHa 커스텀 이미지 올리기","slug":"2017/conoha-custom-image","date":"2017-01-12T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/conoha-custom-image/","link":"","permalink":"http://jacegem.github.io/blog/2017/conoha-custom-image/","excerpt":"","text":"ConoHa 커스텀 이미지 올리기 conoha 콘솔 Ubuntu 64비트로 설치 하였습니다. root 접속 Login incorrect 발생시, 텍스트 전송을 통해서 암호를 입력합니다. vsftpd 패키지 설치 1apt-get install vsftpd 사용자 추가 1adduser ftpuser conf 수정 1nano /etc/vsftpd.conf write_enable=YES 부분의 주석을 삭제한다. 서비스 재시작 1service vsftpd restart 파일 전송 FileZilla 등 프로그램을 통해서 ftp 접속 ISO 파일을 전송한다. web server 설치 update &amp; upgrade 12apt-get updateapt-get upgrade Apache2 설치 1apt-get install apache2 아이피로 접속해서 웹 페이지가 정상적으로 나오는지 확인합니다. 전송한 ISO 파일을 이동한다. 1mv Windows.ISO /var/www/html iso 파일의 권한을 변경한다 1chmod o+r Windows.iso conoha-iso 다운로드 기본 정보들은 모두 환경 변수에 저장해 놓는다. 123conoha-iso.exe download -i http://domain/Windows.isotime=&quot;2017-04-20T23:45:24+09:00&quot; level=info msg=&quot;Download request was accepted.&quot; VPS 종료 후, 이미지 삽입 1conoha-iso insert 출처 http://goproprada.tistory.com/189 https://blog.lael.be/post/73 https://github.com/hironobu-s/conoha-iso http://badspell.tistory.com/13","categories":[{"name":"Service","slug":"Service","permalink":"http://jacegem.github.io/blog/categories/Service/"},{"name":"Cloud","slug":"Service/Cloud","permalink":"http://jacegem.github.io/blog/categories/Service/Cloud/"}],"tags":[{"name":"conoha","slug":"conoha","permalink":"http://jacegem.github.io/blog/tags/conoha/"},{"name":"vps","slug":"vps","permalink":"http://jacegem.github.io/blog/tags/vps/"},{"name":"cloud","slug":"cloud","permalink":"http://jacegem.github.io/blog/tags/cloud/"}]},{"title":"ConEmu 다운로드 및 설정","slug":"2017/conemu_download_setting","date":"2017-01-11T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/conemu_download_setting/","link":"","permalink":"http://jacegem.github.io/blog/2017/conemu_download_setting/","excerpt":"","text":"ConEmu 다운로드 및 설정 다운로드 홈페이지 : https://conemu.github.io/ 다운로드 : https://www.fosshub.com/ConEmu.html 다운받아서 설치를 진행하시면 됩니다. Split 홈페이지의 이미지처럼 나누기 위해서 splite 단축키를 사용할 수 있습니다. Setting 화면으로 들어가서, split으로 검색을 합니다. Ctrl+Shift+O : 수직으로 절반 나눠서 창을 복사합니다. Ctrl+Shift+E : 수평으로 절반 나눠서 창을 복사합니다. 만약 단축키가 실행되지 않는다면, 다른 프로그램에 할당된 것은 아닌지 확인해 봐야 합니다. 저는 ShareX 프로그램에서 사용하고 있어서 실행되지 않았었습니다. 설정 타이틀바에서 마우스 우클릭을 하면 팝업 메뉴를 볼 수 있습니다. Scheme 변경 설정 메뉴에서 → Features → Colors → Schemes 를 변경합니다. 텍스트 색 변경 react-native-cli 실행시에, 텍스트가 안보인다면, 설정 메뉴에서 → Features → Colors 메뉴에서 0번의 색을 흰색으로 변경합니다. 투명도 변경 설정 메뉴에서 → Features → Transparency 메뉴에서 Active window transparency를 선택합니다. 슬라이드를 움직여 투명도를 조절합니다. 배경이미지 변경 https://wallpapersafari.com/kali-linux-wallpaper-hd/ 에서 kali 월페이퍼를 다운로드 합니다. 설정 메뉴에서 → Main → Background 메뉴에서 Background image를 선택합니다. 프롬프트 변경 1set PROMPT=$E[32m$E]9;8;&quot;USERNAME&quot;$E\\@$E]9;8;&quot;COMPUTERNAME&quot;$E\\$S$E[92m$P$E[90m$_$E[33m$T$E[37;1m$G$S$E[m PROMPT 환경변수를 추가하여 프롬프트를 변경할 수 있습니다.","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Console","slug":"Application/Console","permalink":"http://jacegem.github.io/blog/categories/Application/Console/"}],"tags":[{"name":"console","slug":"console","permalink":"http://jacegem.github.io/blog/tags/console/"},{"name":"conemu","slug":"conemu","permalink":"http://jacegem.github.io/blog/tags/conemu/"}]},{"title":"책.특이점이 온다","slug":"2017/특이점이-온다","date":"2017-01-10T10:13:45.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2017/특이점이-온다/","link":"","permalink":"http://jacegem.github.io/blog/2017/%ED%8A%B9%EC%9D%B4%EC%A0%90%EC%9D%B4-%EC%98%A8%EB%8B%A4/","excerpt":"","text":"책.특이점이 온다. 진화의 여섯 시기 제1기 물리학과 화학 정보가 원자 구조에 있다. DNA가 진화한다. 제2기 생물학 정보가 DNA에 있다. 뇌가 진화한다. 제3기 뇌 정보가 신경 패턴에 있다. 기술이 진화한다 제4기 기술 정보가 하드웨어와 소프트웨어 설계에 있다. 기술이 생물(인간 지능을 포함해서)의 방법론을 터특한다. 제5기 기술과 인간 지능의 융합 생물(인간 지능을 포함한)의 방법론이 인간 기술 기반(기하급수적으로 확장되는)과 융합된다. 무한히 확장된 인간 지능(주로 비생물학적임)이 우주로 퍼진다. 제6기 우주가 잠에서 깨어난다 우주의 물질과 에너지의 패턴이 지적과정과 지식으로 가득 찬다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"ETC","slug":"Programming/ETC","permalink":"http://jacegem.github.io/blog/categories/Programming/ETC/"}],"tags":[{"name":"특이점","slug":"특이점","permalink":"http://jacegem.github.io/blog/tags/%ED%8A%B9%EC%9D%B4%EC%A0%90/"}]},{"title":"AXISJ GRID PageNo","slug":"2017/axisj_grid_pageno","date":"2017-01-09T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/axisj_grid_pageno/","link":"","permalink":"http://jacegem.github.io/blog/2017/axisj_grid_pageno/","excerpt":"","text":"AXISJ GRID PageNo 목적 : 그리드에서 변경한 페이지 정보 유지 그리드 생성 HTML 코드 1&lt;div class=&quot;ez-AXGrid ax-grid&quot; id=&quot;axGrid&quot; data-options=&quot;axGridConfig&quot;&gt;&lt;/div&gt; 그리드 기본 설정 12345678910111213141516171819202122232425262728$(&quot;.ez-AXGrid&quot;).each(function(t, a) &#123; var n = $(a), i = n.attr(&quot;id&quot;), o = n.data(&quot;options&quot;) || &quot;&#123;&#125;&quot;, r = new AXGrid, d = &#123; targetID: i, mediaQuery: e, page: &#123; paging: !0, pageSize: 20 &#125;, height: 600, colHead: &#123; onclick: function() &#123; if (r.ajaxInfo) &#123; if (r.ajaxInfo.ajaxPars) &#123; var e = $.extend(r.ajaxInfo.ajaxPars.queryToObject(), r.getSortParam(&quot;one&quot;).queryToObject()); r.ajaxInfo.ajaxPars = axdom.param(e, !0) &#125; else r.ajaxInfo.ajaxPars = r.getSortParam(&quot;one&quot;); r.reloadList() &#125; &#125; &#125;, colHeadAlign: &quot;center&quot; &#125;; return $.extend(d, o.object()), &quot;colGroup&quot; in d == 0 ? void trace(&quot;AXJ.easy.js .ez-AXGrid [ERROR] colGroup 옵션을 반드시 설정해야 합니다.&quot;) : (r.setConfig(d), window[i] = r, gv &amp;&amp; gv.axGrids &amp;&amp; gv.axGrids.push(r), void trace(&#x27;AXJ.easy.js .ez-AXGrid [id=&quot;&#x27; + i + &#x27;&quot;]&#x27;)) &#125;) axGrid.page.pageNo 에서 현재 페이지 정보를 얻을 수 있다. 현재 페이지 정보를 view 페이지로 넘어갈때에 정보를 가지고 간다. 1234567var config = &#123; body: &#123; onclick: function()&#123; // 페이지 정보를 파라미터로 넘긴다. &#125; &#125;&#125; c:url 태그는 서버에서 해석되는 jstl(JavaServer Pages Standard Tag Library) 구문임. 클라이언트에서 해당 태그는 보이지 않는다. 클라이언트에서는 변환된 문자열이 보일 뿐 이다. 클릭시에, 현재 페이지 정보를 받아서, 파라미터로 넘기기 위해 동적인 URL 을 생성해서 서버로 전송해야 한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"axisj","slug":"axisj","permalink":"http://jacegem.github.io/blog/tags/axisj/"}]},{"title":"Android 사진 동영상 불러오기","slug":"2017/Android-사진-동영상-불러오기","date":"2017-01-07T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/Android-사진-동영상-불러오기/","link":"","permalink":"http://jacegem.github.io/blog/2017/Android-%EC%82%AC%EC%A7%84-%EB%8F%99%EC%98%81%EC%83%81-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0/","excerpt":"","text":"Android 사진 동영상 불러오기 웹앱 사용 12import android.webkit.JavascriptInterface;mWebView.addJavascriptInterface(new AndroidBridge(this), &quot;androidJS&quot;); 클래스 생성 12345678//웹뷰 서버 자바스크립트 연동private class AndroidBridge &#123; Context context = null; public AndroidBridge(Context context) &#123; this.context = context; &#125;&#125; 갤러리 이미지 호출 123456//갤러리 이미지 호출Uri uri = Uri.parse(&quot;content://media/external/images/media&quot;);Intent intent = new Intent(Intent.ACTION_VIEW, uri);intent.setAction(Intent.ACTION_GET_CONTENT);intent.setType(&quot;image/*&quot;);startActivityForResult(intent, IMAGEFILE_REQUEST); 썸네일 Base64 생성 1234567891011121314151617181920// 이미지, 동영상의 썸네일의 base64를 반환한다.private String getBase64(String file_path) &#123; // http://lookintoandroid.blogspot.kr/2015/11/getting-camera-captured-image-in.html int width = 400; int height = 300; String ext = FilenameUtils.getExtension(file_path); Bitmap resized = null; if (ext.equals(&quot;jpg&quot;))&#123; resized = ThumbnailUtils.extractThumbnail(BitmapFactory.decodeFile(file_path), width, height); &#125; else if (ext.equals(&quot;mp4&quot;))&#123; // http://stackoverflow.com/questions/20208007/difference-between-micro-kind-and-mini-kind-in-mediastore-in-android resized = ThumbnailUtils.createVideoThumbnail(file_path, MediaStore.Images.Thumbnails.MINI_KIND); &#125; ByteArrayOutputStream baos = new ByteArrayOutputStream(); resized.compress(Bitmap.CompressFormat.PNG, 100, baos); //bm is the bitmap object byte[] byteArrayImage = baos.toByteArray(); return Base64.encodeToString(byteArrayImage, Base64.DEFAULT);&#125; 갤러리 동영상 호출 123456//갤러리 동영상 호출Uri uri = Uri.parse(&quot;content://media/external/images/media&quot;);Intent intent = new Intent(Intent.ACTION_VIEW, uri);intent.setAction(Intent.ACTION_GET_CONTENT);intent.setType(&quot;video/*&quot;);startActivityForResult(intent, VIDEOFILE_REQUEST); 사진 촬영 12Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);startActivityForResult(intent, CAMERA_IMAGE_REQUEST); onActivityResult 사진 촬영의 경우 intent.getData() 를 통해 데이터를 얻지 못하므로, intent.getExtras().get(“data”) 를 사용합니다. 데이터를 받아서, 저장한 후 해당파일을 사용하여 처리합니다. 12345678910111213if (resultCode == Activity.RESULT_OK) &#123; final Bitmap bitmap = (Bitmap) intent.getExtras().get(&quot;data&quot;); String root = Environment.getExternalStorageDirectory().getAbsolutePath(); File myDir = new File(root + &quot;/saved_images&quot;); myDir.mkdirs(); String time = String.valueOf(System.currentTimeMillis()); String saved_file_name = &quot;Image-&quot;+ time +&quot;.jpg&quot;; File file = new File (myDir, saved_file_name); FileOutputStream out = new FileOutputStream(file); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out); out.flush(); out.close();&#125; 동영상 촬영 12Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);startActivityForResult(intent, CAMERA_VIDEO_REQUEST);","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Android","slug":"Programming/Android","permalink":"http://jacegem.github.io/blog/categories/Programming/Android/"}],"tags":[{"name":"android","slug":"android","permalink":"http://jacegem.github.io/blog/tags/android/"}]},{"title":"[Autohotkey] xmind 입력 모드로 변경하기","slug":"2017/autohotkey-xmind","date":"2017-01-05T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/autohotkey-xmind/","link":"","permalink":"http://jacegem.github.io/blog/2017/autohotkey-xmind/","excerpt":"","text":"[Autohotkey] xmind 입력 모드로 변경하기 윈도우에서 xmind 사용시 한글 입력에 약간(?)의 불편함이 있습니다. 이처럼 입력모드가 아닌 상태에서 한글이 입력된다. 입력 도중 스페이스바가 눌리면 그때, 입력모드로 변경되면서, 스페이스바는 무시가 되는 상태가 되어 버립니다. 이를 방지하고자, 새로운 노드 생성시, 스페이스바를 자동으로 입력하게 하여 입력모드로 변경하는 AHK 스크립트를 작성합니다. 123456789101112131415161718192021#ifWinActive ahk_exe XMind.exeglobal input_state := False; tab 또는 enter 를 누르면, 입력 모드로 변경한다.TAB:: changeState() return ENTER:: changeState() return changeState()&#123; Send &#123;%A_ThisHotkey%&#125; if (input_state != 1)&#123; Send &#123;F2&#125; &#125; input_state := !input_state &#125;#IfWinActive 전체 스크립트는 https://github.com/jacegem/ahk_script 에서 받을 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Autohotkey","slug":"Programming/Autohotkey","permalink":"http://jacegem.github.io/blog/categories/Programming/Autohotkey/"}],"tags":[{"name":"autohotkey","slug":"autohotkey","permalink":"http://jacegem.github.io/blog/tags/autohotkey/"}]},{"title":"책.유니티 게임 제작 입문","slug":"2017/유니티-게임-제작-입문","date":"2017-01-05T10:13:45.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2017/유니티-게임-제작-입문/","link":"","permalink":"http://jacegem.github.io/blog/2017/%EC%9C%A0%EB%8B%88%ED%8B%B0-%EA%B2%8C%EC%9E%84-%EC%A0%9C%EC%9E%91-%EC%9E%85%EB%AC%B8/","excerpt":"","text":"책.유니티 게임 제작 입문 BlockControl 클래스의 새로운 메서드 beginFall(): 낙하 시작 처리를 한다. beginRespawn(): 색을 바꿔 낙하 상태로 하고 지정한 위치에 재배치한다. isVacant(): 블록이 비표시(그리드상의 위치가 텅 빔)로 되어 있다면 true를 반환한다. isSlide(): 교체 중(슬라이드 중)이라면 true를 반환한다. BlockRoot 스크립트의 새로운 메서드 fallBlock(): 낙하했을 때 위아래 블록을 교체한다. is_has_sliding_block_in_column(): 지정된 그리드 좌표의 열(세로 줄)에 슬라이드 중인 블록이 하나라도 있으면 true를 반환한다. ScoreCounter 클래스의 기능별 메서드 print_value(): 지정된 두 개의 데이터를 두 행으로 나누어 표시한다. addIgniteCount(): 연쇄 횟수를 가산한다. clearIgniteCount(): 연쇄 횟수를 리셋한다. updateScore(): 더해야 할 점수를 계산한다. updateTotalScore(): 합계 점수를 갱신한다. isGameClear(): 게임을 클리어했는지 판정한다.(SceneControl에서 사용) SceneControl 클래스의 Update() 메서드 상태 변화 대기 시 처리: 플레이 중(PLAY)인 경우 isGameClear()를 사용해 클리어했는지 검사하고 클리어했다면 CLEAR 상태로 이행한다. 상태가 변했을 때의 처리: CLEAR 상태라면 block_root의 움직임을 정지시키고 클리어 시간을 표시하기 위해서 현재 시간을 저장한다. LevelControl 클래스 level_datas: 각 레벨의 레벨 데이터를 저장하는 List 값 select_level: 선택된 레벨을 저장하는 int값 initialize(): 초기화 처리를 한다.(level_datas를 초기화할 뿐) loadLevelData(): 텍스트 데이터를 읽어와서 그 내용을 해석하고 데이터를 보관한다. selectLevel(): 몇 개의 레벨 패턴에서 지금 사용할 패턴을 선택한다. getCurrentLevelData(): 선택되어 있는 레벨 패턴의 레벨 데이터를 반환한다. getVanishingTime(): 선택되어 있는 레벨 패턴의 연소 시간을 반환한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Unity","slug":"Programming/Unity","permalink":"http://jacegem.github.io/blog/categories/Programming/Unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"http://jacegem.github.io/blog/tags/unity/"},{"name":"book","slug":"book","permalink":"http://jacegem.github.io/blog/tags/book/"}]},{"title":"브루스 테이트의 세븐 랭귀지","slug":"2017/브루스-테이트의-세븐-랭귀지","date":"2017-01-04T15:00:00.000Z","updated":"2023-10-24T11:29:12.997Z","comments":true,"path":"2017/브루스-테이트의-세븐-랭귀지/","link":"","permalink":"http://jacegem.github.io/blog/2017/%EB%B8%8C%EB%A3%A8%EC%8A%A4-%ED%85%8C%EC%9D%B4%ED%8A%B8%EC%9D%98-%EC%84%B8%EB%B8%90-%EB%9E%AD%EA%B7%80%EC%A7%80/","excerpt":"","text":"브루스 테이트의 세븐 랭귀지 언어 논리 중심 프로그래밍 언어 : 프롤로그 객체지향 언어 : 루비, 스칼라, 파이썬 함수형 언어 : 스칼라, 얼랭, 클로저, 하스켈 프로토타입 언어 : Io, 자바스크리트, 루아 스칼라 : 복수 패러다임 언어 스칼라 스칼라 언어의 한쪽 끝이 자바라면, 다른 쪽의 끝은 하스켈이다. 자바와의 관련성 스칼라는 자바 가상 머신 위에서 동작한다. 따라서 스칼라는 이미 존재하는 코드다. 나란히 실행될 수 있다. 스칼라는 자바 라이브러리를 직접 사용할 수 있다. 따라서 개발자들은 이미 존재하는 프레임워크와 레거시 코드를 활용할 수 있다. 스칼라는 자바와 마찬가지로 정적 타이핑을 사용한다. 따라서 두 언어는 철학적 기반을 공유한다. 스칼라의 문법은 자바와 가깝기 때문에 개발자들이 쉽게 배울 수 있다. 스칼라는 객체지향과 함수 프로그래밍 패러다임을 모두 지원한다. 따라서 개발자들은 자신의 코드에 함수 프로그래밍 개념을 단계별로 조금씩 적용할 수 있다. 자바와의 차이점 스칼라는 가능한 모든 곳에서 변수의 자료형을 컴파일러가 유추한다. 스칼라는 자바 안에 중요한 함수 개념을 도입했다. 스칼라는 변수가 불변인지 아닌지 미리 결정하도록 강제한다. 스칼라 관련 최고의 베스트셀러 : Programming in Scala 함수 언어의 성격 함수 프로그램은 함수로 이루어져 있다. 함수는 항상 어떤 값을 리턴한다. 동일한 입력이 주어지면 함수는 언제나 동일한 결과를 리턴한다. 함수 프로그램은 상태를 변경하거나 데이터를 변경하는 것을 피한다. 하나의 값을 설정했으면, 그 값을 끝까지 유지한다. 트레이트 모든 객체지향 언어는 하나의 객체가 여러 개의 역할을 담당할 수 있어야 한다. 하나의 객체는 영원히 나열할 수 있는 나무를 품은 관목 숲과 같다. C++는 다중 상속을 이용하고, 자바는 인터페이스를 이용하고, 루비는 믹스인을 이용하고, 스칼라는 트레이트를 이용한다. var로 선언된 값은 변경이 가능하다. val은 불변이다. 고계함수 고계함수는 다른 함수를 생산하거나 소비하는 함수를 의미한다. 더 엄밀하게 말하면 고계함수란 다른 함수를 입력 매개변수로 받아들이거나 다른 함수를 리턴하는 함수다. 핵심 강점 스칼라의 장점은 대부분 자바 환경과 잘 통합된다는 사실과 잘 설계된 기능을 중심으로 존재한다. 특히 액터, 패턴 매칭, XML의 통합은 매우 중요하며 훌륭하게 설계되어 있다. 동시성 스칼라가 동시성을 다루는 방식은 동시성 프로그래밍에서 이루어지고 있는 주요한 발전을 반영한다. 액터 모델과 스레드 풀은 환영할 만한 발전이며, 변경 가능한 상태를 배제한 상태에서 애플리케이션을 만들 수 있도록 한 부분은 엄청난 발전이다. 낡은 자바의 진환 스칼라 애플리케이션은 자바 라이브러리를 직접 사용할 수 있고, 필요하면 프록시 객체 코드를 생성함으로써 그렇게 할 수도 있다. 스칼라와 자바의 호환성interoperability은 탁월하다. DSL 스칼라가 가진 유연한 문법과 연산자 오버로딩은 루비 스타일의 도메인 언어를 개발하는 데 적합하다. 루비 DSL(domain-specific language 도메인 언어)은 어떤 언어를 특정한 도메인용으로 가다듬을 수 있도록 해준다. 루비에서 가장 널리 알려진 예로, 액티브레코드 프레임워크는 클래스를 데이터베이스 테이블에 매핑하기 위해 도메인 언어를 사용한다. 루비는 객체를 단일하고 일관성 있는 방식으로 다루도록 해주는 순수한 객체지향 언어다. 루비는 환상적인 스크립트 언어다. 두 개의 애플리케이션을 서로 붙이는 접착제 코드를 작성하거나, 주식 시세나 책의 가격 등을 파악하기 위해서 부지런히 웹 페이지를 읽어때는 스파이더 코드를 작성하거나, 로컬 빌드 환경이나 자동화된 테스트 코드를 작성할 때 루비는 탁월한 선택이다. nil과 false를 제외한 다른 모든 것은 true로 평가된다. C와 C++ 프로그램들은 0조차 true 라는 사실을 잘 기억하기 바란다. Io Io는 루아나 자바스크립트처럼 프로토타입 언어인데, 그것은 모든 객체가 다른 객체의 클론이라는 사실을 의미한다. Io 에서는 클래스와 객체를 구별하기 위해 노력할 필요가 없다. 모든 것이 객체이며, 필요하면 그들을 복제할 수 있다. 이렇게 복제물을 양산하는 객체를 프로토타입이라고 부른다. 인터프리터: http://iolanguage.com 정리 다른 객체를 복제함으로써 객체를 만든다. 객체는 슬롯의 컬렉션이다. 메시지를 보냄으로써 슬롯에 담긴 값을 받아볼 수 있다. 기초적인 규칙 모든 것이 객체다 모든 상호작용은 객체에 메시지를 보내는 방식으로 이루어진다. 클래스를 이용해서 인스턴스를 만들지 않는다. 프로토타입이라는 객체를 복제함으로써 만든다. 객체는 자신의 프로토타입을 기억한다. 객체는 슬롯을 갖는다. 슬롯은 객체를 담는다. 메서드 객체도 포함된다. 메시지는 슬롯에 담긴 값을 리턴하거나 그 안에 있는 메서드를 호출한다. 객체가 자신에게 전달된 메시지에 응답할 수 없다면, 자신의 프로토타입 메시지를 전송한다. Io 장점 프로토타입 언어는 일반적으로 상당히 유연하다. Io의 메모리 사용량 footprint 은 적다 프롤로그 프롤로그는 선언형declarative 언어다. 사실과 추론inference을 프롤로그에게 던지고, 생각reasoning또 프롤로그가 하게 한다. 데이터를 구성하는 빌딩 블록 사실: 사실fact은 세계의 어떤 측면에 대한 기본적인 선언assertion이다. (베이브는 돼지다. 돼지는 진흙을 좋아 한다.) 규칙: 규칙rule은 해당 세계 안에 존재하는 사실에 대한 추론이다. (그 동물이 돼지라면 진흙을 좋아할 것이다.) 질의: 질의query는 세계에 대한 질문이다. (베이브는 진흙을 좋아하는가?) 프롤로그에서 첫글자가 소문자로 시작하면 그것은 루비의 심벌처럼 고정된 값은 의미하는 원자atom다. 만약 첫글자가 대문자나 밑줄이면 변수variable다. 변수 값은 변할 수 있다. 원자는 변하지 않는다. 얼랭 얼랭은 어려운 일을 쉽게 만들고, 동시에 쉬운 일을 어렵게 만든다. 클라우드 컴퓨팅과 관련해서 인기를 끌고 있는 데이터베이스 카우치디비와 심플디비를 구현하는 데 사용된 언어이기도 한다. 프로그램이 전적으로 함수로 구성되며, 객체는 어디에도 없다. 이러한 함수들은 대개 입력이 같으면 언제나 동일한 내용을 리턴한다. 이러한 함수들은 대개 부수효과가 없다. 즉, 프로그램의 상태를 변경하지 않는다. 변수에 값을 오직 한 차레만 할당할 수 있다. 함수 언어에서는 기호symbol가 다른 언어에서보다 중요하다. 기호는 가장 기초적인 데이터 요소이며 프로그래머가 원하는 어떤 내용이라도 나타낼 수 있다. 리스트 컴프리핸션은 [표현||클로즈1, 클로즈2, ..., 클로즈N] 형태를 갖는다. 리스트 컴프리핸션은 임의의 수의 클로즈를 포함할 수 있다. 클로즈는 생성자generator나 필터를 가질 수 있다. 필터는 불리언 표현이나 불리언을 리턴하는 함수일 수 있다. 매칭 &lt;- 리스트의 형태를 갖는 생성자는 왼쪽에 있는 패턴을 오른쪽에 있는 리스트의 요소에 매치한다. 핵심 강점 얼랭은 모든 며에서 동시성과 에러 방지에 대한 언어라고 볼 수 있다. 얼랭은 무엇보다도 안정성을 위해서 만들어진 언어다. 클로저 클로저는 JVM 위에서 동작하는 리스프 언어다. 혼란스럽고 강력한 리스프는 최초로 개발된 언어임과 동시에 가장 최근에 사용되는 언어이기도 하다. 많은 면에서 클로저는 사려 깊은 쿵푸 마스터, 언덕 위의 오라클, 혹은 신비로운 제다이 훈련교관이다. 모든 것은 리스프로부터 리스프라는 이름은 리스트 처리^Listt Processing^에서 따온 말이다. 리스프는 리스트를 위한 언어다. 함수 호출은 리스트의 첫 번째 인수를 함수로, 나머지를 인수로 사용한다. 리스프는 코드를 표현하기 위해 고유한 자료구조를 사용한다. 리스프를 사용하는 사람들은 이것을 코드로서의 데이터^data as code^ 라고 부른다. 이 두 가지 아이디어를 결합하면, 메타프로그래밍에 적합한 언어를 얻게 된다. 리스트, 맵, 집합, 벡터 다른 함수 언어에서와 마찬가지로 리스트와 튜플 같은 자료구조가 핵심적인 기능을 담당한다. 클로저에서 가장 중요한 세 가지 구조를 꼽으면 리스트, 맵, 벡터다. 리스트는 순서가 있는 요소들을 저장하는 컬렉션이다. 백터는 리스트와 마찬가지로 요소들을 순서를 고려해서 담는 컬렉션이다. 집합은 순서가 없는 요소들을 저장하는 컬렉션이다. 맵은 키-값 짝이다. 시퀀스 클로저 생태계에서 시퀀스는 다양한 컨테이너의 주위를, 구현되는 내용으로부터 독립된 방식으로 추상화해주는 기능이다. 시퀀스는 클로저의 컬렉션(집합, 맵, 백터 등), 문자열, 그리고 심지어 파일시스템 구조(스트림, 디렉토리 등)를 감싼다. 자바 컬렉션, 배열, 문자열 같은 자바 컨테이너를 위한 공통의 추상도 제공한다. 핵심 강점 좋은 리스프 프로그래밍 언어의 전문가이며 파워블로거인 팀 브레이는 '클러저를 위한 11개의 대제’에서 클로저를 좋은 리스프라고 불렀다. 사실 그는 클로저를 '역사상 최고의 리스프’라고 불렀다. 나는 클로저가 아주 좋은 리스프라는 의견에 동의한다. 대폭 줄어든 괄호: 클로저는 백터에 대괄호를 사용하고, 맵에 중괄호를 사용하고, 집합에 문자의 조합을 사용하는 등, 문법을 다소 수정함으로써 가독성을 향상시켰다. 생태계: 리스프의 변종들은 대개 하나의 언어를 위한 지원 및 라이브러리라는 막힌 길을 밟아나갔다. 역설적이게도 새로운 변종 하나가 등장하면 그러한 문제가 해결되었다. 클로저는 JVM 위에서 동작을 수행함으로써 엄청난 양의 라이브러리를 사용하는 자바 프로그래머와 동일한 수준의 혜택을 누릴 수 있게 해주었다. 제한: 읽기 매크로를 피하기 위해 클로저의 문법을 제한하는 방법을 채택함으로써 히키는 클로저의 기능을 실질적으로 제한했지만, 엉뚱한 변종이 등장해서 발전이 저해되는 상홛오 피할 수 있었다. 동시성 STM 은 너무나 새로운 개념이기 때문에 그것을 이용하는 프로그래머들에게 거추장스럽게 느껴지기도 하지만, 상태를 변경하는 동작이 적절하게 작성된 함수에 의해 수행되는지 여부를 자동으로 검출함으로써 프로그래머들이 동시성 문제로 고통받지 않아도 되게끔 만들었다. 자바와의 통합 클로저는 자바와 훌륭하게 통합된다. 하지만 클로저는 자바보다 JVM과의 통합이라는 측면에서 더 빛을 발한다. 게이른 평가 클로저는 매우 강력한 게으른 평가 기능을 포함한다. 게이른 평가는 문제를 단순화해준다. 코드로서의 데이터 프로그램은 리스트로 이루어진다. 리스프와 마찬가지로 데이터를 코드로 표현할 수 있다. 약점 전위 표기법: 코드를 리스트의 형태로 표현하는 것은 리스프 언어가 가지고 있는 가장 강력한 기능의 하나인데, 거기에는 전위 표기법이라는 비용도 수반된다. 가독성: 데이터를 코드로 표현하는 데 따르는 비용의 하나는 압도당할 정도로 많은 괄호다. 학습 과정의 어려움: 클로저는 기능이 풍부한 언어이며, 따라서 학습 과정이 쉽지 않다. 리스프가 제대로 사용되도록 하기 위해서는 극도로 뛰어난 재능과 경험을 가진 팀이 필요하다. 게으른 시퀀스, 함수 프로그래밍, 매크로 확장, 트랜잭션 메모리, 그 밖의 다른 정교한 기능들은 완전히 익힐 때까지 많은 시간을 요구하는 강력한 개념들이다. 제한된 리스프: 모든 타협에는 비용이 수반된다. JVM 위에서 동작하기로 결정했기 때문에 클로저는 꼬리 재귀 최적화를 제한적으로 밖에 지원하지 못한다. 접근성: 클로저는 개발자에게 엄청난 수준의 노력을 요구한다. 프로그래머의 두뇌를 압도할 정도로 많은 추사 도구와 개념이 포함되어 있다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"ETC","slug":"Programming/ETC","permalink":"http://jacegem.github.io/blog/categories/Programming/ETC/"}],"tags":[{"name":"book","slug":"book","permalink":"http://jacegem.github.io/blog/tags/book/"},{"name":"language","slug":"language","permalink":"http://jacegem.github.io/blog/tags/language/"}]},{"title":"Elm 시작하기","slug":"2017/elm-start","date":"2017-01-04T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/elm-start/","link":"","permalink":"http://jacegem.github.io/blog/2017/elm-start/","excerpt":"","text":"Elm 시작하기 홈페이지 : http://elm-lang.org/ 문서(Gitbook) : https://guide.elm-lang.org/ Elm 튜토리얼(한국어) : https://www.elm-tutorial.org/ko/ JavaScript 개발자를 위한 Elm Example of how to integrate Elm with HTML and JS Awesome Elm","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Elm","slug":"Programming/Elm","permalink":"http://jacegem.github.io/blog/categories/Programming/Elm/"}],"tags":[{"name":"elm","slug":"elm","permalink":"http://jacegem.github.io/blog/tags/elm/"}]},{"title":"Gitbook Plugin","slug":"2017/gitbook_plugin","date":"2017-01-04T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/gitbook_plugin/","link":"","permalink":"http://jacegem.github.io/blog/2017/gitbook_plugin/","excerpt":"","text":"Gitbook Plugin https://github.com/GitbookIO ad adsense puml plantUML echart chart 플러그인","categories":[{"name":"Service","slug":"Service","permalink":"http://jacegem.github.io/blog/categories/Service/"},{"name":"GitBook","slug":"Service/GitBook","permalink":"http://jacegem.github.io/blog/categories/Service/GitBook/"}],"tags":[{"name":"plugin","slug":"plugin","permalink":"http://jacegem.github.io/blog/tags/plugin/"},{"name":"gitbook","slug":"gitbook","permalink":"http://jacegem.github.io/blog/tags/gitbook/"}]},{"title":"2017 IT 21 Conference","slug":"2017/it21-6-1","date":"2017-01-04T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/it21-6-1/","link":"","permalink":"http://jacegem.github.io/blog/2017/it21-6-1/","excerpt":"","text":"2017 IT 21 Conference ICT 디바이스 현황 및 전망 다양한 디바이스가 나옴 → 다양한 서비스에 활용 주변환경과 사용자 연동 → 공간 연동 초기시장 형성 중 ICT 디바이스 인공지능 자율 주행차 VR/AR 사물 인터넷 ICT 디바이스 국내외 현황 (CES 2017) CES 거물들의 경쟁 숨은 승자는 ‘아마존’ ‘알렉사(Alexa)’ : 아마존의 인공지능 음성 인식 비서 전기차자율차…IT+자동차 트렌드 가속화 퀀텀닷 vs. OLED 차세대 TV 경쟁 연결 연결 연결… 가시화 된 스마트홈 친구 같은 로봇, 사람 태우고 나는 드론 참고: http://www.zdnet.co.kr/news/news_view.asp?artice_id=20170108020629 ICT 디바이스 국내외 현황 (MWC 2017) 코앞에 다가온 5G, 활용은 아직, 실시간 통신은 OK 완성 단계 접어든 LTE 스마트폰 단말기 시장의 흐름 변화, ‘실속’ 자동차를 바라보는 시각 차이 참고: http://slownews.kr/62727 Machine Learning Recurrent Neural Network Visualization 웹에서는 d3.js 사용 빅데이터를 위한 딥러닝 응용 사례 패션 이미지 검색기술 SK플래닛 11번가 커머스, 광고 마케팅 인공지능 기술개발 필요성 모바일 신용카드 인식기술 숫자 위치 검출 / 특징 추출 / 숫자 분류 SVM DBN, RNN, CNN Neural Machine Translation, NMT Word2vec 으로 V차원 벡터화 LSTM Long Short-Term Memory : 정보의 유지, 갱신, 전달 수행 패션 이미지 검색 기술 Attention Multi-object detection Deep feature extraction Multi-object detection Faster RCNN 적용 (오픈소스) Deep feature extraction googlenet 빅데이터 분석 플랫폼 brightics RL 함수 / B2B 회사에서는 마케팅 추천 함수 / 여러 가지 프로모션 방법 / 시뮬레이션 / 개인화 Q-learning 스파크 함수 구현 장비에서 나오는 센서 데이터 데이터 수집 많은 정형 데이터는 RDB에 있다. 빨리 가져오기 위해서 병렬로 가져온다. Sqoop,사용 병렬이 빠를거라 생각하지만, single이 더 빠른 경우가 있다. UI 설계가 중요. 고객은 제품을 고려할 때 UI를 본다. 빅데이터 플랫폼을 이용하여 데이터를 관리한다. 데이터 싸이클 관리.","categories":[{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"ETC","slug":"Conference/ETC","permalink":"http://jacegem.github.io/blog/categories/Conference/ETC/"}],"tags":[{"name":"conference","slug":"conference","permalink":"http://jacegem.github.io/blog/tags/conference/"}]},{"title":"무료 글꼴","slug":"2017/무료-글꼴","date":"2017-01-04T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/무료-글꼴/","link":"","permalink":"http://jacegem.github.io/blog/2017/%EB%AC%B4%EB%A3%8C-%EA%B8%80%EA%BC%B4/","excerpt":"","text":"무료 글꼴 http://font.cox.kr 고도몰 폰트고도체 더페이스샵 폰트잉크립퀴드체 다음 카카오 폰트미생체 스포카 폰트스포카 한 산스 윤디자인고문서체 대한체 한둥근체 독도체 법청제 밝은체 야놀자야놀자체 123rf123rf체 비비트리 서체비비트리체 오픈애즈체 123RF 무료서체 롯데마트 통큰 서체행복체 드림체 KT&amp;G 상상체상상 제목체 상상 본문체 아모레퍼시픽 아리따 글꼴아리따 돋움체 아리따 부리체 한컴함초롬체? 한마음체한마음 고딕체 한마음 명조체 청소년체청소년체 KoPub 폰트KoPub 돋움체 KoPub 바탕체 아시아폰트폰트통 디컴즈 폰트김제시체 전라북도체 빙그레체빙그레체 한겨레 폰트한겨레 한결체 부산바다체부산바다체 어비폰트어비 미미체 어비 슬기로운 생활체 어비 이부손체 어비 미니도리체 어비 여니체 어비 소윤체 무료폰트2 Han Sans Korean 구글 Noto 네이버 나눔폰트 우아한형제들 티몬 폰트 가비아 폰트 옥션 인터파크 Adobe 본명조 Adobe 본고딕 유료 폰트 폰트바다 윤디자인 산돌네오 폰트 검색 typekit 구글 폰트 무료 폰트 공공기관 부산시청 폰트부산체 서울시 서체서울남산체 서울한강체 성동구청 폰트성동명조 성동고딕 제주서체제주한라산 제주명조 중소기업중앙회KBIZ한마음 고딕체 KBIZ한마음명조체 한국청소년활동진흥원청소년서체 아산시 폰트이순신체 &amp; 이순신 돋움체 포천 오성과 한음체포천시 막걸리체 &amp; 오성과 한음체 고양체고양시청 고양체 국방부 블로그 : 네이버 블로그국방부가 6월 호국 보훈의 달을 맞아 배포한 호국체.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"ETC","slug":"Programming/ETC","permalink":"http://jacegem.github.io/blog/categories/Programming/ETC/"}],"tags":[{"name":"asset","slug":"asset","permalink":"http://jacegem.github.io/blog/tags/asset/"}]},{"title":"교재:데이터베이스 성능 향상을 위한 데이터 모델링 실무","slug":"2017/데이터베이스-성능-향상을-위한-데이터-모델링-실무","date":"2017-01-03T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/데이터베이스-성능-향상을-위한-데이터-모델링-실무/","link":"","permalink":"http://jacegem.github.io/blog/2017/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EC%8B%A4%EB%AC%B4/","excerpt":"","text":"교재:데이터베이스 성능 향상을 위한 데이터 모델링 실무 개념 데이터 모델링 주제영역 정의하기 핵심개체 정의하기 핵심관계 정의하기 개념 ERD 작성하기 개념 데이터 모델 품질 검증하기 논리 데이터베이스 설계 개체 상세화하기 관계 상셍화하기 논리 ERD 작성하기 데이터베이스 정규화하기 바커 표기법(Baker Notation) * (Mandatory) - 어떤 값을 반드시 저장 0 (Optional) - 존재하지 않을 수도 있는 경우 엔터티와 엔터티간 상관 관제의 조건 필수조건 필수 사항은 실전으로 표시 엔터티가 반드시 존재할 경우 표시 선택 조건 선택 사항은 점선으로 표시 엔터티가 존재하지 않을 수도 있는 경우 표시 주어부 관계비 목적부 선택사양 각각의 사원은 단 하나의 부서를 반드시 가져야 한다 각각의 부서는 하나 이상의 사원을 가질 수도 있다 I/E 표기법(Information Engineering Notation) 개념 데이터 모델 정의 개념적 데이터 모델이란 건물로 말하면 철제빔으로 건물의 골격을 세워 놓는 형태와 유사하다. 건물의 골격이 주요 골조 자재로 구성되어 있듯이 개념 데이터 모델도 주요 핵심 엔터티들로 구성된다. 1234핵심 엔터티란행위의 주체나 목적물이 되는 개체 집합에 해당하는 엔터티를 의미부모가 존재하지 않는 창조된 집합이어서 다른 집합의 존재 유무에 상관없이 독립적으로 존재여러 가지 하위의 행위 엔터티를 탄생시킴 개념 데이터 모델 의의 개념 데이터 모델은 단지 대상을 주요 핵심 엔터티로 한정한다는 것일 뿐이지 모델링 기법은 논리적 모델링과 비슷하다 주제 영역 개념 주제 영역(Subject Area)은 기업이 사용하는 데이터의 최상위 집합이다. 예를 들어, 제조 업체의 경우 인사, 생산, 자재, 판매 등의 주제 영역이 있을 수 있다. 하나의 주제 영역으로 정의되는 데이터간의 관계는 밀접하고, 다른 주제 영역에 포함되는 데이터 간의 상호작용은 최소화 할 수 있도록 정의한다. 데이터 중복 최소화 동일한 기능을 하는 자원(지역 및 정보)이 중복 정의되어 낭비되지 않도록 체계적인 분류 작업이 필요 데이터 확장성 보장 가까운 미래에 추가되어지는 정보에 대해 최대한의 확장성을 고려하여 분류 체계 설계 데이터 관련성 및 편의성 확보 타 자원(정보 및 지역)과의 인접성을 고려한 설계 고객 편의(정보 요건)를 고려한 자원 내의 핵심적인 데이터 집합에 대한 것을 명시 핵심 관계에 대한 명시 필요에 따라서 표준화된 타 영역의 설계(참조 모델)도 참조하여 데이터 분류 생성 주제 영역 명명 실 업무에서 보편적으로 사용하는 업무 용어를 부여 유일한 단수형 명사를 사용 데이터의 그룹을 의미하는 이름을 부여 주제영역 분류 방법 1차 분류 : 주요 데이터 집합의 유형 정의 2차 분류 : Biz 활동에 필요한 데이터 분류 3차 분류 : 2차 영역의 세부 주제 영역 분류 주제 영역 도출 업무에서 사용하는 데이터의 명사형 도출 (정보 수집 소스로부터 명사형 찾기) 업무 기능의 이름으로부터 도출 (데이터와 업무 활동의 상호 보완 관계) 하향식(Top-down) 접근 방법 (주제 영역에서 출발하여 엔터티 타입으로 전개) 상향식(Bottom-up) 접근 방법 (엔터티 타입을 그룹핑하여 주제 영역 도출) 분석 단계에서의 도출 (아키텍처 모델(Architecture Model)을 정련하는 과정에서 도출, 데이터 모델을 상세화하는 과정에서 도출) 주제 영역 목록 레벨 : 주제 영역의 계층 수준(1차, 2차, … 단위) 주제 영역명 설명(단위 주제 영역의 경우) 대표 엔터티 : 해당 주제 영역 내에서 대표적인 엔터티를 기술한다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Database","slug":"Programming/Database","permalink":"http://jacegem.github.io/blog/categories/Programming/Database/"}],"tags":[{"name":"database","slug":"database","permalink":"http://jacegem.github.io/blog/tags/database/"}]},{"title":"개발자가 갖추어야 할 9가지 기술","slug":"2017/개발자가-갖추어야-할-9가지-기술","date":"2017-01-02T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/개발자가-갖추어야-할-9가지-기술/","link":"","permalink":"http://jacegem.github.io/blog/2017/%EA%B0%9C%EB%B0%9C%EC%9E%90%EA%B0%80-%EA%B0%96%EC%B6%94%EC%96%B4%EC%95%BC-%ED%95%A0-9%EA%B0%80%EC%A7%80-%EA%B8%B0%EC%88%A0/","excerpt":"","text":"개발자가 갖추어야 할 9가지 기술 https://www.youtube.com/watch?v=fHyTA-UIcqs 개발자가 갖추어야 할 9가지 기술 Hard Skill Basic Knowledge (C++, OS) / 기초 지식들 Understanding for product / 제품에 대한 이해 Development Cycle / 개발 싸이클 1231-5 years of development- Associate Software Engineer / 초급 개발자- Software Engineer / 중급 개발자 Basic Knowledge (C++, OS) Learn from school, workplace, by yourself / 학교, 직장에서 스스로 배워라. Mathematics, Physics / 수학, 물리 Programming Language (C++, C#, Python) / 프로그래밍 언어 Algorithm, Data Structure, Design Patterns / 알고리즘, 자료 구조, 디자인 패턴 Graphics, Database, Networking, AI / 그래픽, 데이터베이스, 네트워크, 인공지능 Game Engines (Unity) / 게임 엔진 OS (Windows, Mac, iOS, Android) / 운영체제 Tools (Source control, Visual Studio) / 도구들 Understanding for product Product Anaylysis / 제품 분석 Power of Blizzard / 블리자드의 힘 Everyone loves game / 모두가 게임을 사랑한다. Three types of restaurants / 3가지 식당 Going for porfit / 돈을 벌기 위해 Try to make customer happy / 고객을 행복하게 하기 위해 Love cooking / 음색 만드는 것이 좋아서 Development Cycle Requirements &amp; Analysis / 요구사항 분석 Design &amp; Modeling / 디자인 &amp; 모델링 Implementation / 구현 Test/Release / 테스트, 배포 Feedback/Update / 피드백, 업데이트 Soft Skills Project Management / 프로젝트 관리 Team Management / 팀 관리 Process (Agile, Zero-Bug) / 프로세스 1236-10 years of development- Software Engineer / 중급 개발자- Senior Software Engineer / 고급 개발자 Project Management Why, What, How / 왜, 무엇을, 어떻게 Triple Constrains / 3가지 제약사항 Cost (Resources) / 비용 (자원) Time (Schedule) / 시간 (일정) Scope (Quality) / 범위 (질) Team Management Froming, Storming, Norming, Performing Roles around the Team Product owner Producer, Artists, Designers, Engineers Engineering Team Lead Project lead, Technical lead, People Manager Clear role definition. Proper delegation Process Better way to do it, Optimal way / 더 잘하는 방식, 최고의 방식 Detect failure, Prevent failure / 실패 탐지, 실패 방지 Project Management Process Waterfall, Agile/Scrum Development Process Developement Cycles, Code Review The Joel Test: 12 Steps Your Own Evolving Process / 나만의 프로세스 발전시키기 Process - PMMM Project Management Maturity Model Initial = Common Language Repeatable = Common Process Defined = Singular Methodology Managed = Benchmarking Optimized = Continuous Improvement Business Skills HR System / 인사 시스템 Business Management / 사업 관리 Vision/Goals/Culture / 비전/목표/문화 12310+ years of development- Lead Software Engineer- Techinical Director, VP of Technology, CTO, CEO HR System Hiring / 채용 Performance Reviews / 평가 Titles (Engineering) / 승진 Rewards / 보상 Education / 교육 Benefits / 복지 Attract → Develop → Engage(결합) HR System - Performance Review Example : Software Engineer Productivity / 생산성 Professionalism (Reliability) / 책임감 Teamwork (Communication) / 협업 Knowledge / 지식 Functionality (No Defect) / 결함은 없는가 Implementation (Good Code) / 코드는 깨끗한가 Design &amp; Architecture / 디자인 &amp; 구조 롤 모델을 찾아서 비교한다. HR System - Education Example : Learning &amp; Development Books, Conferences / 책, 컨퍼런스 Internal seminars, EDGs / 세미나 College Programs, Tuition Side Projects, Mentoring Individual Development Plan Studio Summit, Lunch Groups Internal mobility (Hiring cross-teams) / 내부 인사 이동 Business Management Leading People, Manage Business / 사람을 이끈다 Making money a certain way doing things you are comfortable doing and contributing to society / 사회에 도움이 된다. ROI (Return over Investment) Capability, Strategy, Tatics, Finance, Economics, Marketing, Sales, CS, Operations, Change Balanced Scorecard Financial Perspective Customer Perspective Internal Process Perspective Learning and Growth Perspective Customer The company’s customers The leadership The employees Vision, Goals, and Culture Vision and Goals for the company Vision and Goals for the team vision and Goals for you Exampel: Blizzard Mission Statement “Dedicated to creating the most epci entertainment experiences…ever.” Example: Blizzard Core Values Gameplay first Commit to quality Play nice; Play fair Embrace your inner geek Every voice matters Think globally Lead responsibly Learn &amp; Grow Software Development Hard Skill: Learn by Studying Basic Knowledge (C++, OS) / 기초 지식들 Understanding for product / 제품에 대한 이해 Development Cycle / 개발 싸이클 Soft Skill: Learn by Experience Project Management / 프로젝트 관리 Team Management / 팀 관리 Process (Agile, Zero-Bug) / 프로세스 Business Skill: Learn from People HR System / 인사 시스템 Business Management / 사업 관리 Vision/Goals/Culture / 비전/목표/문화 Q&amp;A Hard Skills What to study: Everything Growth: Performance review, Endless curiosity / 조금이라도 발전, 끊임없는 호기심 Soft Skills Successfult DeveloperL Talent, Practive, Chance How is it working in Blizzard: Experts &amp; Collaborations Good Developer: Three stages(A, A+, B) / 시키는 일을 한다. 신뢰를 쌓는다. Business Skils How to learn business: Simulation &amp; Communication Attitude to become CEO: Responsible for everything Base Skills Smart, Diligent, Good Will Communication Skill: Listen more, Win less I don’t divide the world into the weak and the strong, or the successes and the failures, those who make it or those who don’t. I divide the world into learners and non-learners. Benjamin R. Barber 성장하고 있는 것이 중요하다. 참고 http://d2startup.com/programs/3292 https://www.youtube.com/watch?v=fHyTA-UIcqs","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"General","slug":"Programming/General","permalink":"http://jacegem.github.io/blog/categories/Programming/General/"}],"tags":[{"name":"development","slug":"development","permalink":"http://jacegem.github.io/blog/tags/development/"}]},{"title":"[javascript] Map.prototype.forEach()","slug":"2017/[javascript]_mapprototypeforeach","date":"2017-01-01T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/[javascript]_mapprototypeforeach/","link":"","permalink":"http://jacegem.github.io/blog/2017/[javascript]_mapprototypeforeach/","excerpt":"","text":"[javascript] Map.prototype.forEach() forEach() 함수는 입력한 순서에 따라 맵 오브젝트안에 있는 각각 키/값 쌍을 제공하는 기능을 실행합니다. 문법 1myMap.forEach(callback[, thisArg]) 파라미터 callback 각 요소들을 실행할 함수 thisArg 콜백함수를 실행할 때 사용할 값 Return value undefined. 설명 forEach 함수는 맵에 실제로 존재하는 각 키 마다 제공된 콜백에 의해 실행된다. 지워진 키에 대해서는 호출되지 않는다. 그러나 값은 존재하고 undefined 인 경우에도 실해된다. 콜백은 세가지 파라미터와 함께 호출된다. 요소 값 요소 키 전달된 맵 객체 If a thisArg parameter is provided to forEach, it will be passed to callback when invoked, for use as its this value. Otherwise, the value undefined will be passed for use as its this value. The this value ultimately observable by callback is determined according to the usual rules for determining the this seen by a function. Each value is visited once, except in the case when it was deleted and re-added before forEach has finished. callback is not invoked for values deleted before being visited. New values added before forEach has finished will be visited. forEach executes the callback function once for each element in the Map object; it does not return a value. Examples Printing the contents of a Map object The following code logs a line for each element in an Map object: 12345678function logMapElements(value, key, map) &#123; console.log(&quot;m[&quot; + key + &quot;] = &quot; + value);&#125;new Map([[&quot;foo&quot;, 3], [&quot;bar&quot;, &#123;&#125;], [&quot;baz&quot;, undefined]]).forEach(logMapElements);// logs:// &quot;m[foo] = 3&quot;// &quot;m[bar] = [object Object]&quot;// &quot;m[baz] = undefined&quot; Specifications Specification Status Comment ECMAScript 2015 (6th Edition, ECMA-262) The definition of ‘Map.prototype.forEach’ in that specification. Standard Initial definition. ECMAScript 2017 Draft (ECMA-262) The definition of ‘Map.prototype.forEach’ in that specification. Draft Browser compatibility Desktop Mobile Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari Basic support 38 25.0 (25.0) 11 25 7.1 See also Array.prototype.forEach() Set.prototype.forEach()","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"}]},{"title":"[Unity] Tutorials - Roll-a-Ball","slug":"2017/[unity]_tutorials_-_roll-a-ball","date":"2017-01-01T10:13:45.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2017/[unity]_tutorials_-_roll-a-ball/","link":"","permalink":"http://jacegem.github.io/blog/2017/[unity]_tutorials_-_roll-a-ball/","excerpt":"","text":"[Unity] Tutorials - Roll-a-Ball http://unity3d.com/learn/tutorials/modules/ 사이트에 접속합니다. PROJECTS 들이 여러개 보이는데요. 그중에서 Beginner 난이도인 Roll-a-Ball을 보도록 하겠습니다. 기본 마우스 기능 오브젝트를 선택할 경우에는 Shift + 좌클릭 화면을 회전할 경우에는 Alt + 좌클릭 평행이동을 하고 싶을 경우에는 마우스 중클릭 을 해야 합니다. Hierarchy Scene Hierachy 설명 Ground 바닥, 배경 Player 움직이는 공 Fill light 아래에서 비추는 빛 Main light 위에서 비추는 빛 Walls 동서남북 벽 PickUps 회전하는 정육면체 Win Text 승리 메시지 Count Text 점수 GUI Text 튜토리얼과 같이 GUI Text를 생성할 수 없습니다. Create Empty Object 후에 Component → Rendering → GUIText 를 추가해야 합니다 Assets Prefabs PickUp : pickup들에 공통적으로 스크립트를 적용합니다. Scenes MiniGame : 메인 화면 Scripts CameraController 1234567891011121314151617using UnityEngine;using System.Collections;public class CameraController : MonoBehaviour &#123; public GameObject player; private Vector3 offset; // Use this for initialization void Start () &#123; offset = transform.position; &#125; // Update is called once per frame void LateUpdate () &#123; transform.position = player.transform.position + offset; &#125;&#125; PlayerController 123456789101112131415161718192021222324252627282930313233343536373839404142using UnityEngine;using System.Collections;public class PlayerController : MonoBehaviour &#123; public float speed; public GUIText countText; public GUIText winText; private int count; void Start()&#123; count = 0; SetCountText(); winText.text = &quot;&quot;; &#125; void FixedUpdate()&#123; float moveHorizontal = Input.GetAxis (&quot;Horizontal&quot;); float moveVertical = Input.GetAxis (&quot;Vertical&quot;); Vector3 movement = new Vector3 (moveHorizontal, 0.0f, moveVertical); rigidbody.AddForce (movement * speed * Time.deltaTime); &#125; void OnTriggerEnter(Collider other) &#123; if (other.gameObject.tag == &quot;PickUp&quot;) &#123; other.gameObject.SetActive(false); count++; SetCountText(); &#125; &#125; void SetCountText()&#123; countText.text = &quot;Count : &quot; + count; if (count &gt;= 12) &#123; winText.text = &quot;You WIN!&quot;; &#125; &#125;&#125; Rotate 1234567891011121314using UnityEngine;using System.Collections;public class Rotate : MonoBehaviour &#123; // Use this for initialization void Start () &#123; &#125; // Update is called once per frame void Update () &#123; transform.Rotate (new Vector3 (15, 30, 45) * Time.deltaTime); &#125;&#125; Build Android File → Build Settings → Player Settings'' 에서 ''Bundle Indentifier를 변경해야 합니다. SDK 경로 변경은 Edit → Preferences → External Tools 에서 할 수 있습니다.","categories":[{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"Unity","slug":"Programming/Unity","permalink":"http://jacegem.github.io/blog/categories/Programming/Unity/"}],"tags":[{"name":"unity","slug":"unity","permalink":"http://jacegem.github.io/blog/tags/unity/"}]},{"title":"UbuntuOpenStack","slug":"2016/UbuntuOpenStack","date":"2016-12-27T05:33:00.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/UbuntuOpenStack/","link":"","permalink":"http://jacegem.github.io/blog/2016/UbuntuOpenStack/","excerpt":"","text":"우분투 홈페이지에서 ISO 파일 다운로드 VirtualBox 로 설치 instal-guide-ubuntu https://www.ubuntu.com/download/cloud#instructions Installation instructions Set up your hardware ----------------------- Install Ubuntu Server 14.04 LTS on the machine designated to be the MAAS server. You need to setup a private network with all machines plugged in and enough IP addresses available for all physical and virtual machines you plan to run. This network must not have a DHCP server: MAAS will fill in that role. For the simplest topology, connect the second NIC of the dual-nic machines(s) to the same network Add required repositories ---------------------------- 123sudo apt-get install python-software-propertiessudo add-apt-repository ppa:cloud-installer/stablesudo apt-get update","categories":[],"tags":[]},{"title":"[하스스톤] 선술집 - 나를 따르라","slug":"2016/하스스톤-선술집-나를-따르라","date":"2016-02-19T02:10:37.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/하스스톤-선술집-나를-따르라/","link":"","permalink":"http://jacegem.github.io/blog/2016/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4-%EC%84%A0%EC%88%A0%EC%A7%91-%EB%82%98%EB%A5%BC-%EB%94%B0%EB%A5%B4%EB%9D%BC/","excerpt":"","text":"[하스스톤] 선술집 - 나를 따르라 하수인 뒤에서 숨어있는 자를 어찌 영웅이라 할 수 있겠습니까! 하수인들을 지키세요! 이번 난투에서는 내 영웅예게 도발 능력이 부여됩니다. 게임을 시작하면 영웅에게 방어 10이 추가되고, 도발 능력이 부여됩니다. 마법사 전략 단 하나의 카드로 인해 이번 선술집에서 최고의 영웅이 되었습니다. 그래서 마법사 대 마법사의 게임이 자주 발생하게 됩니다. 이번 선술집의 진정한 히어로 입니다. 영웅의 도발 뒤에 숨어서, 영웅의 피해를 1로 고정합니다. 살아 움직이는 갑옷을 골랐으면, 나머지는 마법사 카드들을 선택하면 됩니다. 마법을 위주로 사용하기에 필수 카드인 불꽃꼬리 전사를 선택합니다. 마법 법사라면 공격력 높고, 주문을 얻을 수 있기 때문에 이 카드도 유용합니다. 살아 움직이는 갑옷 과 세트로 사용합니다. 상대방이 영웅의 피해가 1로 고정되는 것을 피하기 위해서 살아 움직이는 갑옷을 먼저 처치하려고 할 것입니다. 2의 피해를 줄 수 있기 때문에, 적 하수인을 처치할 때 유용합니다. 비밀을 사용한다면 꼭 넣어줍니다. 얼음 방패와 비전술사는 최고의 콤비 입니다. 주술사 전략 그냥 1마나로 사용하기 좋습니다. 땅굴 트로그와 콤비로 다니는 카드 입니다. 2마나 카드이며 과부하가 있기에 땅굴 트로그에 공격력 +1 을 부여합니다. 이번 선술집에서 주술사의 핵심카드 입니다. 지속적으로 양옆 하수인들에게 공격력 +2 를 부여합니다. 영웅의 도발 능력으로 상대방이 이 카드를 처치하기 쉽지 않습니다. 두 개의 불꽃의 토템을 놓이면 총 공격력 +8의 효과를 얻게 됩니다. 영웅의 도발로 인해 하수인 처리가 어려워지므로, 하수인 수를 늘리기 쉽습니다. 이때 피의 욕망을 부르면 한번에 상대방의 피를 모두 깍을 수 있습니다. 기본공격력에, 불꽃토템 +8, 피의욕망 +12. 게임이 종료되었습니다. 전사 전략 하수인을 모으고, 방어도를 높이면서 게임을 진행할 수 있습니다. 이번 선술집에서 활용도가 큰 카드입니다. 기본으로 주어지는 10 방어도를 그대로 활용할 수 있습니다. 1마나만 사용하여 초반부터 10의 피해가 가능합니다. 이 무기는 공격력보다는 죽음의 메아리를 활용하는 것이 관건입니다. 파괴될 때, 모든 하수인들에게 피해를 주므로 방어구 제작자가 있다면 높은 방어력을 얻을 수 있습니다. 한번에 방어도 8을 얻었습니다. 사냥꾼 전략 야수들에게 돌진을 부여하는 툰드라 코뿔소로 시작합니다. 이때 부터는 모든 야수들은 등장하자마자 공격이 가능해지기 때문에 딜에 좋습니다. 일반 카드 상대방의 하수인에 늘어나기 쉬우므로 정신 지배 기술자를 사용하여 상대방의 하수인을 가져옵니다.","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/%EC%84%A0%EC%88%A0%EC%A7%91/"}]},{"title":"일러스트레이터 - 단축키","slug":"2016/일러스트레이터-단축키","date":"2016-02-10T12:31:54.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-단축키/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%8B%A8%EC%B6%95%ED%82%A4/","excerpt":"","text":"단축키 요약 Alt 키가 반대의 역할을 한다. Alt 키가 사용중이면 Shift 가 반대의 역할을 한다. 숫자키 조합 단축키가 유용하다. 이동시에, Shift 를 누르면 더 크게 움직인다. 파일 단축키 설명 Ctrl + N 새 파일 만들기 Ctrl + Shift + N 템플릿 불러오기 Ctrl + O 파일 불러오기 Ctrl + Alt + O 어도비 브릿지로 불러오기 Ctrl + W 파일 닫기 Ctrl + Alt + W 열린 파일 모두 닫기 Ctrl + S 파일 저장하기 Ctrl + Shift + S 다른 이름으로 저장하기 Ctrl + Alt + S 복사본 저장하기 Ctrl + Shift + Alt + S 웹용 파일로 저장하기 Ctrl + Alt + P 도큐먼트 셋업하기 Ctrl + P 프린트하기 Ctrl + Q 일러스트러에터 종료하기 오브젝트 단축키 설명 Ctrl + D 변형 작업 반복하기 Ctrl + G 선택한 오브젝트를 그룹으로 묶기 Ctrl + Shift + G 묶인 그룹 풀어주기 Ctrl + ], Ctrl + [ 선택한 오브젝트의 배열을 위·아래로 Ctrl + Shift + ], Ctrl + Shift + [ 선택한 오브젝트의 배열을 최상위·최하위로 Ctrl + 2 선택한 오브젝트 잠그기 Ctrl + Alt + 2 잠긴 오브젝트 풀어주기 Ctrl + 3 선택한 오브젝트 보이지 않게 숨기기 Ctrl + Alt + 3 감춘 오브젝트 보이게 하기 Ctrl + Shift + Alt + 3 선택한 오브젝트만 남기고 모두 숨기기 Ctrl + J 떨어져 있는 패스 기준점 이어주기 Ctrl + Alt + X 라이브 페인트 환경 만들기 Ctrl + 7 클리핑 마스크 만들기 Ctrl + Alt + 7 클리핑 마스크 해제하기 Ctrl + 8 컴파운드 패스 만들기 Ctrl + Alt + B 블렌드 만들기 Ctrl + Shift + Alt + B 블렌드 없애기 Ctrl + Shift + Alt + W 와프로 둘러싸서 왜곡하기 Ctrl + Alt + W 메시로 둘러싸서 왜곡하기 Ctrl + Alt + C 상위 오브젝트로 둘러싸서 왜곡하기 Ctrl + Alt + X 라이브 페인트 환경 만들기 편집 단축키 설명 Ctrl + Z 실행 취소 (작업 순서를 전단계로 되돌리기) Ctrl + Shift + Z 다시 실행 (최근 작업 순서로 돌아오기) Ctrl + X 잘라내기 Ctrl + C 복사하기 Ctrl + V 붙여 넣기 Ctrl + F 제자리 위에 붙여 넣기 Ctrl + B 제자리 뒤에 붙여 넣기 Ctrl + Shift + V 현재 아트보드에 붙여 넣기 Ctrl + Shift + Alt + V 모든 아트보드에 붙여 넣기 Ctrl + I 맞춤법 검사하기 보기 단축키 설명 Ctrl + +, Ctrl + Space + 드래그(or 클릭) 도큐먼트 확대 Ctrl + -, Ctrl + Space + Alt + 클릭 도큐먼트 축소 Ctrl + 0 도큐먼트를 화면에 딱 맞게 보기 Ctrl + 1 실 사이즈(100%)로 보기 Space + 드래그 화면 옮기기 Ctrl + Y 아웃라인 보기/숨기기 Ctrl + H 패스 보기/숨기기 Ctrl + R 눈금자 보기/숨기기 Ctrl + Shift + B 바운딩 박스 보기/숨기기 Ctrl + Shift + D 도큐먼트를 투명으로 보기/흰색으로 보기 Ctrl + ; 안내선 보기/숨기기 Ctrl + Alt + ; 안내선 잠그기/풀기 Ctrl + 5 선택한 패스를 안내선으로 만들기 Ctrl + ’ 격자 보기/숨기기 Ctrl + Shift + I 원근감 격자 보기/숨기기 글자 단축키 설명 Ctrl + Shift + O 글자 속성을 버리고 아웃라인 만들기 Ctrl + → 단어 끝 부분으로 커서 옮기기 Ctrl + ← 단어 첫 부분으로 커서 옮기기 Ctrl + Shift + ↑, ↓ 행 단위로 블록 선택 Ctrl + Shift + →, ← 단어 단위로 블록 선택 Ctrl + Shift + R 오른쪽 정렬 Ctrl + Shift + L 왼쪽 정렬 Ctrl + Shift + C 가운데 정렬 Ctrl + Shift + &gt;, &lt; 글자 크기 키우기, 줄이기 Alt + ↑, ↓ 행간 넓히기, 좁히기 Alt + →, ← 자간 넓히기, 좁히기 Shift + Alt + ↑, ↓ 기준선 올리기, 내리기 툴 단축키 툴 단축키 설명 선택 툴 V 오브젝트 선택 직접 선택 툴 A 오브젝트 기준점이나 패스를 선택 마술봉 툴 Y 비슷한 속성 오브젝트를 모두 선택 올가미 툴 Q 드래그 영역 오브젝트 선택 펜 툴 P 직선, 곡선, 도형 같은 오브젝트를 그리는 툴 글자 툴 T 글자 입력이나 수정 선 툴 \\ 직선, 곡선, 나선, 격자, 원형 격자를 그리는 툴 도형 툴 M 사각형, 원형, 다각형, 별, 광선을 그리는 툴 브러시 툴 B 일반적 패스에 다양한 선 모양이나 붓 터치 느낌을 더하는 툴 연필 툴 N 자유롭게 드래그하여 선을 그리는 툴 블럽 브러시 툴 SHIFT+B 면으로 그림을 그리는 툴 지우개 툴 SHIFT+E 벡터 오브젝트를 지우는 툴 가위 툴 C 패스를 자르는 툴 → 열린 패스가 됨 칼 툴 → 닫힌 패스가 됨 회전 툴 R 오브젝트를 회전하거나 반전 스케일 툴 S 오브젝트 크기를 조절하거나 기울임 폭 툴 SHIFT+W 선 폭을 조절하여 구불구불한 형태로 만듦 자유 변형 툴 E 바운딩 박스의 기준점을 조절하여 크기, 기울기, 회전 정도를 조절 도형 구성 툴 SHIFT+M 선택한 여러 오브젝트를 드래그로 연결해서 한 덩어리로 만듦 라이브 페인트 버킷 툴 K 일반 오브젝트 또는 라이브 트레이스를 이용해 만든 오브젝트에 지정한 색이나 속성을 클릭 한 번으로 적용. 속성이 적용될 때에는 식별하기 쉽도록 붉고 굵은 색이 나타남 라이브 페인트 선택 툴 SHIFT+L 라이브 페인트 버킷 툴로 색을 채운 오브젝트만 선택 원근감 격자 툴 SHIFT+P 원근감 있는 일러스트를 그릴 수 있도록 원근감 격자를 만듦 원근감 선택 툴 SHIFT+V 오브젝트, 텍스트, 심벌을 원근감 격자로 드래그해서 입체적으로 적용함 메시 툴 U 오브젝트 내면에 그물망 모양의 기준점을 추가하여 자연스러운 그레이디언트 효과를 만듦. 사진처럼 정교한 일러스트를 그릴 때 사용함 그레이디언트 툴 G 오브젝트에 그레이디언트 효과를 적용 스포이트 툴 I 오브젝트 속성 복제 블렌드 툴 W 서로 다른 속성을 가진 오브젝트를 자연스럽게 연결하고, 변화 단계를 자동으로 만듦 심벌 툴 SHIFT+S 심벌을 만들고 수정할 수 있음. 심벌 뿌리기 툴로 심벌 오브젝트를 만든 뒤 다른 심벌 툴을 이용해서 밀도, 색상, 위치, 크기, 회전, 투명도, 스타일을 바꿀 수 있음 그래프 툴 J 수치만 입력해서 다양한 그래프를 만듦 아트보드 툴 SHIFT+O 아트보드를 추가, 이동, 복사하고 크기를 조절 슬라이스 툴 SHIFT+K 작업 영역을 웹 이미지별로 나누거나 선택 손 툴 H 작업 화면을 드래그해서 원하는 곳으로 옮김 spacebar를 누르면 손 툴 상태가 됨 돋보기 툴 Z 클릭하거나 드래그해서 화면을 확대. Alt와 함께 사용하면 축소. 더불륵릭하면 작업 화면 크기가 100%로 맞춰짐 초기화 버튼 D 선택한 오브젝트 또는 툴 패널의 컬러 속성을 초기화. 면은 흰색, 선 굵기는 1px, 선 색은 검은색. 스타일이나 브러시가 적용되어 있는 오브젝트는 해당 속성이 사라짐 바꾸기 버튼 SHIFT+X 선택한 오브젝트 또는 툴 패널의 선 색과 면 색을 서로 맞바꿉니다. 면(Fill)과 선(Stroke) X 선택한 오브젝트의 면 색과 선 색을 표시함. 투명은 붉은색 사선으로 나타냄 그리기 모드 SHIFT+D Draw Normal, Draw Behind, Draw Inside 화면 모드 F Normal Screen Mode, Full Screen Mode with Menu Bar, Full Screen Mode 단축키를 다른 정렬로 모음 숫자키 조합 단축키 설명 Ctrl + 2 선택한 오브젝트 잠그기 Ctrl + Alt + 2 잠긴 오브젝트 풀어주기 Ctrl + 3 선택한 오브젝트 보이지 않게 숨기기 Ctrl + Alt + 3 감춘 오브젝트 보이게 하기 Ctrl + Shift + Alt + 3 선택한 오브젝트만 남기고 모두 숨기기 Ctrl + 7 클리핑 마스크 만들기 Ctrl + Alt + 7 클리핑 마스크 해제하기 Ctrl + 8 컴파운드 패스 만들기 Ctrl + 0 도큐먼트를 화면에 딱 맞게 보기 Ctrl + 1 실 사이즈(100%)로 보기 Ctrl + 5 선택한 패스를 안내선으로 만들기 토글 단축키 단축키 설명 Ctrl + Y 아웃라인 보기/숨기기 Ctrl + H 패스 보기/숨기기 Ctrl + R 눈금자 보기/숨기기 Ctrl + Shift + B 바운딩 박스 보기/숨기기 Ctrl + Shift + D 도큐먼트를 투명으로 보기/흰색으로 보기 Ctrl + ; 안내선 보기/숨기기 Ctrl + Alt + ; 안내선 잠그기/풀기 Ctrl + ’ 격자 보기/숨기기 Ctrl + Shift + I 원근감 격자 보기/숨기기 마우스 조합 단축키 설명 Ctrl + 휠 도큐먼트 좌우 이동 Alt + 휠 도큐먼트 확대 축소 Space + 드래그 화면 옮기기 명칭 패스 명칭 기준점(Anchor Point) : 패스를 고정하는 기준이 되는 점 세그먼트(Segment) : 기준점 사이의 선 방향점(Direction Point) : 방향선을 움직여 곡선 형태를 조정 방향선(Direction Line) : 세그먼트의 기울기와 굴곡을 조정 패스(Path) : 이어져 있는 기준점과 세그먼트 전체","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"단축키","slug":"단축키","permalink":"http://jacegem.github.io/blog/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"name":"파일","slug":"파일","permalink":"http://jacegem.github.io/blog/tags/%ED%8C%8C%EC%9D%BC/"},{"name":"오브젝트","slug":"오브젝트","permalink":"http://jacegem.github.io/blog/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"},{"name":"편집","slug":"편집","permalink":"http://jacegem.github.io/blog/tags/%ED%8E%B8%EC%A7%91/"},{"name":"보기","slug":"보기","permalink":"http://jacegem.github.io/blog/tags/%EB%B3%B4%EA%B8%B0/"},{"name":"글자","slug":"글자","permalink":"http://jacegem.github.io/blog/tags/%EA%B8%80%EC%9E%90/"},{"name":"숫자키","slug":"숫자키","permalink":"http://jacegem.github.io/blog/tags/%EC%88%AB%EC%9E%90%ED%82%A4/"}]},{"title":"일러스트레이터 - Select","slug":"2016/일러스트레이터-Select","date":"2016-02-10T11:11:07.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-Select/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-Select/","excerpt":"","text":"Select Same [Select]-[Same] 메뉴를 이용하면 선택한 오브젝트와 속성이 같은 오브젝트를 한 번에 선택할 수 있다. Appearance : 모양이 같은 오브젝트를 모두 선택한다. Appearance Attribute : 모양 속성이 같은 오브젝트를 모두 선택한다. Blending Mode : 블렌딩 모드가 같은 오브젝트를 모두 선택한다. Fill &amp; Stroke : 면과 선 속성이 같은 오브젝트를 모두 선택한다. Fill Color : 면 색이 같은 오브젝트를 모두 선택한다. Opacity : 불투명도가 같은 오브젝트를 모두 선택한다. Stroke Color : 선 색이 같은 오브젝트를 모두 선택한다. Graphic Style : 그래픽 스타일이 같은 오브젝트를 모두 선택한다. Symbol Instance : 심벌 속성이 같은 오브젝트를 모두 선택한다. Link Block Series : 같은 블록으로 연결된 텍스트 박스를 선택한다. Select Object [Select]-[Object] 메뉴를 이용하면 원하는 오브젝트를 한 번에 선택할 수 있다. All on Same Layers : 같은 레이어에 있는 오브젝트를 모두 선택한다. Direction Handles : 선택한 오브젝트의 방향선을 모두 본다. Not Aligned to Pixel Grid : 픽셀 그리드에 정렬되지 않은 오브젝트를 모두 선택한다. Bristle Brush Strokes : 강모 브러시가 적용된 오브젝트를 모두 선택한다 Brush Strokes : 브러시가 적용된 오브젝트를 모두 선택한다. Clipping Masks : 클리핑 마스크를 모두 선택한다. (오브젝트는 제외하고 마스크 영역만 선택) Stray Points : 패스가 작성되지 않은 기준점(클릭만 한 상태)을 모두 선택한다. Text Objects : 텍스트 오브젝트(글자 툴로 쓰인 것)를 선택한다. Flash Dynamic Text : 플래시 다이내믹 텍스트를 선택한다. Flash Input Text : 플래시 인풋 텍스트를 선택한다.","categories":[],"tags":[]},{"title":"일러스트레이터 - Extrude&Bevel","slug":"2016/일러스트레이터-Extrude-Bevel","date":"2016-02-10T04:11:50.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-Extrude-Bevel/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-Extrude-Bevel/","excerpt":"","text":"Extrude &amp; Bevel [Effect]-[3D]-[Extrude&amp;Bevel] Position : 3D 오브젝트의 방향을 선택한다 Perspective : 원근법을 적용한다. Extrude Depth : 입체 기둥의 두께를 정한다. Cap : 오브젝트 면을 표시하거나 없앤다. Bevel : Bevel 모양을 선택한다. Height : Bevel 두께를 정한다 Bevel 을 오브젝트 바깥쪽 또는 안쪽으로 표현한다. Revolve [Effect]-[3D]-[Revolve] Position : 3D 오브젝트의 방향을 선택한다. 드래그해서 위치를 정한다. 수치를 입력해서 위치를 정한다. Perspective : 원근법을 적용한다 Angle : 회전각을 정한다 Cap : 오브젝트 면을 표시하거나 없앤다. Offset : 회전축에 공간을 준다. From : 회전축 위치를 설정한다. Surface : 표면 광택을 외곽선, 단색, 무광, 유광으로 표현한다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"Extrude","slug":"Extrude","permalink":"http://jacegem.github.io/blog/tags/Extrude/"},{"name":"Bevel","slug":"Bevel","permalink":"http://jacegem.github.io/blog/tags/Bevel/"},{"name":"3D","slug":"3D","permalink":"http://jacegem.github.io/blog/tags/3D/"}]},{"title":"일러스트레이터 - Scribble","slug":"2016/일러스트레이터-Scribble","date":"2016-02-10T02:57:26.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-Scribble/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-Scribble/","excerpt":"","text":"일러스트레이터 - Scribble [Effect]-[Stylize]-[Scribble] Settings : 미리 설정된 낙서 스타일을 선택할 수 있다. Angle : 선 각도를 설정한다. Path Overlap : 선이 오브젝트를 벗어나는 정도를 설정한다. Variation 값으로 뒤틀린 선들의 길이 차이를 설정한다. Stroke Width : 선 두께를 설정한다. Curviness : 선이 구부러지는 정도를 설정한다. Variation 값으로 뒤틀린 선들의 곡선 차이를 설정한다. Spacing : 선이 접힌 간격을 설정한다. Variation 값으로 뒤틀린 선의 간격 차이를 설정한다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"scribble","slug":"scribble","permalink":"http://jacegem.github.io/blog/tags/scribble/"},{"name":"effect","slug":"effect","permalink":"http://jacegem.github.io/blog/tags/effect/"},{"name":"stylize","slug":"stylize","permalink":"http://jacegem.github.io/blog/tags/stylize/"}]},{"title":"일러스트레이터 - 투명도 병합 옵션","slug":"2016/일러스트레이터-투명도-병합-옵션","date":"2016-02-09T10:42:41.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-투명도-병합-옵션/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%88%AC%EB%AA%85%EB%8F%84-%EB%B3%91%ED%95%A9-%EC%98%B5%EC%85%98/","excerpt":"","text":"투명도 병합 옵션 Raster/Vector Balance : 벡터와 비트맵 비율을 정합니다. 수치가 높을 수록 벡터 상태를 많이 유지 하고, 낮을수록 래스터(비트맵)화 된다. 50%로 설정하면 간단한 영역은 벡터로 유지되고 복잡한 영역은 래스터화된다. Line Art and Text Resolution : 오브젝트를 지정한 해상도로 래스터화한다. 작은 글자나 얇은 선은 600~1200 으로 지정한다. Gradient and Mesh Resolution : 그레이디언트된 오브젝트 해상도를 설정한다. 그레이디언트, 메시, 그림자 등은 수치가 높아도 결과가 차이가 없으므로 150~300으로 지정한다. Convert All Text to Outlines : 모든 문자 오브젝트를 아웃라인 처리한다. Convert All Strokes to Outlines : 모든 선을 아웃라인 처리해서 면으로 만든다. 가는 선은 약간 두껍게 나타날 수 있다. 벡터로 처리할 때 패스가 늘어나기 때문에 속도가 느려질 수 있다. Clip Complex Regions : 벡터와 비트맵의 경계를 자연스럽게 표시하는 옵션이다. 경우에 따라 복잡한 패스가 만들어져 속도가 느려질 수 있다. Preserve Alpha Transparency : 알파 투명도를 지원하는 형식으로 저장할 때 체크한다. Preserve Overprints and Spot Colors : 오버프린트와 별색을 보존하는 옵션이다. 문서에 별색과 오버프린트가 설정되어 있으면 분판으로 인쇄할 때 선택한다 (편집 프로그램만 쓸 때는 체킄하지 않는다)","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"투명도","slug":"투명도","permalink":"http://jacegem.github.io/blog/tags/%ED%88%AC%EB%AA%85%EB%8F%84/"},{"name":"옵션","slug":"옵션","permalink":"http://jacegem.github.io/blog/tags/%EC%98%B5%EC%85%98/"}]},{"title":"일러스트레이터 - 타이포그래픽","slug":"2016/일러스트레이터-타이포그래픽","date":"2016-02-09T05:25:40.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-타이포그래픽/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9D%B4%ED%8F%AC%EA%B7%B8%EB%9E%98%ED%94%BD/","excerpt":"","text":"추천 무료 폰트 사이트 폰트클럽 : http://www.fontclub.co.kr 윤디자인연구소 : http://yoonfont.co.kr 폰트릭스 : http://www.fontrix.co.kr 좋은글자 : http://www.goodfont.kr 아시아 폰트 : http://www.asiafont.com 헤움 : http://www.heumm.com 폰트나비 : http://www.fontnavi.com 직지소프트 : http://www.smfont.com 무료 영문 폰트 사이트 : http://www.dafont.com 네이버 나눔 폰트 : http://www.hangeul.naver.com 다음 서체 : http://info.daum.net/Daum/info/introduceOfCl.do 서울 서체 : http://design.seoul.go.kr KT&amp;G 상상체 : http://www.kfng.com/kr/company/sangsang.jsp 글자 툴과 글자 패널 Type Tool : 기본 글자 툴. 다른 툴이 선택되어 있어도 써 둔 글자를 더블클릭하면 글자를 다시 입력하거사 수정할 수 있다. 패스 위에서는 패스 글자 툴, 닫힌 패스 위에서는 패스 영역 속에 글자를 입력할 수 있도록 바뀐다. Area Type Tool : 닫힌 패스 속에 글자를 쓴다. Type on a Path Tool : 패스를 따라 글자를 쓴다. Vertical Type Tool : 세로쓰기를 한다. Vertical Area Type Tool : 닫힌 패스 속에서 세로쓰기를 한다. Vertical Type on a Path Tool : 패스를 따라 세로쓰기를 한다. Type on a Path Rainbow : 글자가 기준선 직각 방향으로 나열된다. Skew : 글자가 기준선 모양대로 비스듬해진다. 3D Ribbon : 글자가 기준선을 따라 입체적인 모양으로 변형된다. Stair Step : 글자 방향은 그대로 유지한 채 위치만 기준선을 따른다. Gravity : 글자가 무게 중심점 방향으로 왜곡된다. Erase로 지우고 나서 Gradient 이미지를 불러와서 image trace pathfinder 에서 minus font 처리 gradient 텍스트를 선택하고 Ctrl+8 로 외각선만 남김 배경화 함께 선택 후 Ctrl+7 왜곡 툴로 변형 후 Gradient [Windows]-[Graphic Style Libraries] 적용 [Object]-[Envelope Distort]-[Make with Top Object]","categories":[],"tags":[{"name":"illustratro","slug":"illustratro","permalink":"http://jacegem.github.io/blog/tags/illustratro/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"}]},{"title":"일러스트레이터 - 원근감 격자","slug":"2016/일러스트레이터-원근감-격자","date":"2016-02-09T03:18:08.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-원근감-격자/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%9B%90%EA%B7%BC%EA%B0%90-%EA%B2%A9%EC%9E%90/","excerpt":"","text":"원근감 격자 Perspective Grid Hide Grid : 원근감 격자를 보이지 않게 한다 Show Rulers : 실측 줄자를 표시한다 Snap to Grid : 오브젝트를 그리거나 옮길 때 격자에 스냅이 건다 Lock Grid : 원근감 격자가 움직이지 않게 고정한다. Lock Station Point : 소실점 하나를 옮기면 다른 소실점이 영향을 받아 함께 움직인다. Defind Grid : 원근감 격자를 설정한다. One, Two, Three Point Perspective : 1,2,3점 투시 격자를 만든다. Save Grid as Preset : 설정한 격자를 저장한다. Define Perspective Grid Perspective Grid Settings Perspective Grid Settings : 격자 모양을 1점, 2점, 3점 투시 중 선택할 수 있다. 격자 단위(Units), 실측 비율(Scale), 격자 간격(Gridline every)을 설정한다. 시선의 좌우 각도(Viewing Angle)와 관찰자와의 거리(Viewing Distance)와 눈높이(Horizon Height), 3점 투시가 선택된 경우 세번째 소실점의 좌표 값(Third Vanishing Point)을 설정한다. Grid Color &amp; Opacity Grid Color &amp; Opacity : 격자 색과 전체적인 투명도를 설정한다. 격자 색은 평면 전환 위젯의 면 색을 나타낸다. 따라 그리기","categories":[],"tags":[{"name":"illustrator","slug":"illustrator","permalink":"http://jacegem.github.io/blog/tags/illustrator/"},{"name":"perspective","slug":"perspective","permalink":"http://jacegem.github.io/blog/tags/perspective/"},{"name":"grid","slug":"grid","permalink":"http://jacegem.github.io/blog/tags/grid/"},{"name":"preset","slug":"preset","permalink":"http://jacegem.github.io/blog/tags/preset/"}]},{"title":"[안드로이드] 원더택티스","slug":"2016/안드로이드-원더택티스","date":"2016-02-08T11:38:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/안드로이드-원더택티스/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%9B%90%EB%8D%94%ED%83%9D%ED%8B%B0%EC%8A%A4/","excerpt":"","text":"[안드로이드] 원더택티스 시작하면 파일을 다운로드 합니다. TIPS 영웅 강화 : 영웅 강화 성공 시 기본 능력치가 상승해요! 영웅진화 : 영웅 진화는 랜덤/고정 진화 중 선택할 수 있어요! 영웅초월 : 초월은 5회까지 가능하고, 영웅의 최대 레벨이 상승해요. 영웅 마스터 : 영웅 30레벨을 달성할 때마다 마스터 보상을 준답니다. 특성 활성화 : 조건에 맞는 장비와 보석 장착 시 특성이 활성화돼요. 보석 강화 : 보석 강화를 하면 옵션의 수치가 올라가요. 강화 보너스 : 장비 강화 2단계마다 보너스가 있어요! 장비 강화 : 장비 강화 성공 시 주 옵션의 수치가 올라가요. 비밀 던전 속성 : 비밀 던전의 속성은 매일 변경됩니다. 보물의 탑 보상 : 보물의 탑 층마다 다양한 보상을 얻을 수 있어요. 다승 보상 : 대전 상대를 7번, 10번 이기면 추가 보상이 있답니다. 고대의 성채 보상 : 고대의 성채 지하에서 높은 등급의 장비를 얻을 수 있어요. 오래된 폐광 보상 : 오래된 폐광 지하에서 높은 레벨의 보석을 얻을 수 있어요. 시련의 둥지 보상 : 보스 최종 레벨에 따라 보상 상자의 종류가 달라져요. 전설 보석 : 6레벨 강화 시 일정 확률로 전설 보석이 되며, 특별한 옵션이 붙습니다. 나무, 불, 물, 빛, 어둠 SKILL AUTO는 스킬을 선택해야 시작된다. 스테이지를 클리어한 이후에는 FULL AUTO 사용이 가능하다. 6성 영웅 스킬 플레이 화면 하단에 스킬이 표시된다. 9개의 칸에 칠한 색으로 스킬의 범위와 효과를 표시한다. 빨간색은 공격 스킬, 녹색은 아군용 스킬이다. 연속된 줄로 표시된 것은, 행 또는 열에 효과가 적용되는 스킬이다. 하나의 점은 하나의 대상에 적용되는 스킬이다. 두개 이상의 점이 서로 떨어져 있다면 행, 열과 상관없이 그 수만큼 효과가 적용되는 스킬이다. 9개의 칸에 모두 색이 칠해져 있다면 전역 스킬이다. 캐릭터당 스킬을 2개씩 표현하다보니, 5 캐릭터가 화면을 모두 차지한다. 이것때문에 파티에 참가할 수 있는 최대 영웅수가 5개로 제한된것인가… 스킬을 시전하면 다음 시전까지 기다려야 하는 턴 수가 우측 하단에 표시된다.","categories":[],"tags":[{"name":"안드로이드","slug":"안드로이드","permalink":"http://jacegem.github.io/blog/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"게임","slug":"게임","permalink":"http://jacegem.github.io/blog/tags/%EA%B2%8C%EC%9E%84/"}]},{"title":"일러스트레이터 - 따라하기 사진, 배경","slug":"2016/일러스트레이터-따라하기-사진","date":"2016-02-08T07:40:21.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-따라하기-사진/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%94%B0%EB%9D%BC%ED%95%98%EA%B8%B0-%EC%82%AC%EC%A7%84/","excerpt":"","text":"[Effect] - [Distort &amp; Transform] - [Zig Zag] 로 배경 생성. Rotate 로 복제 후 색 변경. 3 Color 로 만들고, 마술봉으로 색 변환처리 Mesh 를 사용하여 변형 왜곡 사각형 생성 Mesh 툴로 5군데 분할 후 색 지정 가운데 흰색 선 여러개 생성 [Effect]-[Stylize]-[Outer Glow] 지정 Transparency - Overlay Create Gradient Mesh 브러쉬 사용하기","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"사진","slug":"사진","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EC%A7%84/"},{"name":"배경","slug":"배경","permalink":"http://jacegem.github.io/blog/tags/%EB%B0%B0%EA%B2%BD/"}]},{"title":"따라그리기 - 캐릭터","slug":"2016/따라그리기-캐릭터","date":"2016-02-08T03:15:24.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/따라그리기-캐릭터/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EB%94%B0%EB%9D%BC%EA%B7%B8%EB%A6%AC%EA%B8%B0-%EC%BA%90%EB%A6%AD%ED%84%B0/","excerpt":"","text":"따라그리기 - 캐릭터","categories":[],"tags":[{"name":"캐릭터","slug":"캐릭터","permalink":"http://jacegem.github.io/blog/tags/%EC%BA%90%EB%A6%AD%ED%84%B0/"}]},{"title":"일러스트레이터 - 라이브 트레이싱","slug":"2016/일러스트레이터-라이브-트레이싱","date":"2016-02-08T03:10:57.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-라이브-트레이싱/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%9D%BC%EC%9D%B4%EB%B8%8C-%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8B%B1/","excerpt":"","text":"일러스트레이터 - 라이브 트레이싱 Preset : 원하는 라이브 트레이스 스타일을 선택 Simple Trace : Default 와 같은 스타일로 어두운 명암 부분이 검은색 패스로 추출 Color 6과 Color 16 : 색을 6단계와 16단계로 나누어 표현. 스케치보다 명암 단계가 뚜렷하게 구분되는 사진 이미지에 적용 Photo Low와 High Fidelity : 저품질과 고품질 사진 이미지로 표현. High Fidelity로 바꾸면 사진 이미지와 흡사한 디테일 일러스트를 만들 수 있음 Grayscale : 이미지를 흑백 명암으로 구분해서 표현 Hand Drawn Sketch : 펜으로 그린 이미지를 선으로 추출 Detailed Illustration : 명함을 원본과 가장 흡사하게 표현하는 스타일. 어두운 명암 부분이 검은색 패스로 추출 Comic Art : 만화처럼 필압이 느껴지도록 표현. 굵기가 일정한 펜으로 그린 스케치 이미지라고 해도 Comic Art 스타일로 바꾸면 선에 강약이 표현되어 역동적인 느낌을 낼 수 있음. 검은색과 흰색 패스로 추출 Technical Drawing : 명암의 경계선을 둘러싼 형태로 선을 표현. Black and White Logo : 검은색과 흰색 로고 스타일로 표현 One Color Logo : 한 가지 색 로고를 표현하는 것으로 어두운 명암 부분이 검은색 패스로 추출 Inked Drawing : 잉크로 그린 효과 Lattering : 레터링 펜으로 그린 효과 Expand : 트레이싱 이미지를 벡터로 전환합니다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"라이브","slug":"라이브","permalink":"http://jacegem.github.io/blog/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C/"},{"name":"트레이싱","slug":"트레이싱","permalink":"http://jacegem.github.io/blog/tags/%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8B%B1/"}]},{"title":"일러스트레이터 - 패스파인더 패널","slug":"2016/일러스트레이터-패스파인터-패널","date":"2016-02-08T03:09:32.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-패스파인터-패널/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%8C%A8%EC%8A%A4%ED%8C%8C%EC%9D%B8%ED%84%B0-%ED%8C%A8%EB%84%90/","excerpt":"","text":"일러스트레이터 - 패스파인더 패널 Shape Modes : 여러 오브젝트를 하나로 합칩니다. 합친 오브젝트는 맨 위에 있는 오브젝트 속성을 따릅니다. Expand : Alt 를 누른 채로 Shape Mode 버튼을 클릭하면 Expand 버튼을 누르기 전까지는 직접 선택 툴을 이용해서 수정할 수 있습니다. Pathfinders : 선택한 오브젝트에서 겹쳐지는 패스를 이용하여 오브젝트를 나눕니다. 나눈 다음 그룹을 풀면 오브젝트별로 나눠집니다. Shape Modes 버튼 합치기 : 선택한 오브젝트를 하나로 합칩니다. 위쪽 지우기 : 위쪽 오브젝트 영역을 지웁니다. 겹친 부분 남기기 : 선택한 오브젝트가 모두 겹쳐지는 부분만 남기고, 나머지 영역은 지웁니다. 겹친 부분 지우기 : 겹친 부분만 지웁니다. Pathfinders 버튼 면 나누기 : 오브젝트를 겹쳐진 패스 모양대로 나눕니다. 분리하기 : 오브젝트를 눈에 보이는 모양대로 나눕니다. 병합하기 : 오브젝트 색이 모두 따르면 분리하기와 같지만, 색이 같은 오브젝트는 같은 색끼리 묶어서 나눕니다. 윗면으로 자르기 : 맨 위에 있는 오브젝트와 겹치는 아래 부분만 남깁니다. 윤곽선 나누기 : 패스가 교차되는 곳을 모두 잘라 선으로만 표현합니다. 면 색이 선 색으로 바뀝니다. 뒷면 지우기 : 맨 윗면만 남기고 겹치거나 뒤에 위치한 오브젝트는 모두 지웁니다. 쉐이프 빌더 툴 쉐이프 빌더 툴을 사용하면 오브젝트를 합치거나, 필요 없는 부분을 클릭으로 없앨 수 있다. 면과 선 속성을 가진 오브젝트 두 개가 겹쳐 있을 때 쉐이프 빌더 툴로 오브젝트를 드래그 하면 해당 영역이 한 덩어리로 합쳐진다. Alt를 누르면 마우스 포인터가 바뀌고 클릭하거나 드래그 한 곳은 지워진다.","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"패스파인더","slug":"패스파인더","permalink":"http://jacegem.github.io/blog/tags/%ED%8C%A8%EC%8A%A4%ED%8C%8C%EC%9D%B8%EB%8D%94/"},{"name":"pathfinder","slug":"pathfinder","permalink":"http://jacegem.github.io/blog/tags/pathfinder/"}]},{"title":"일러스트레이터 - 툴 단축키","slug":"2016/일러스트레이터-툴-단축키","date":"2016-02-08T02:57:54.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-툴-단축키/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%ED%88%B4-%EB%8B%A8%EC%B6%95%ED%82%A4/","excerpt":"","text":"일러스트레이터 - 툴 단축키 툴 단축키 툴 단축키 설명 선택 툴 V 오브젝트 선택 직접 선택 툴 A 오브젝트 기준점이나 패스를 선택 마술봉 툴 Y 비슷한 속성 오브젝트를 모두 선택 올가미 툴 Q 드래그 영역 오브젝트 선택 펜 툴 P 직선, 곡선, 도형 같은 오브젝트를 그리는 툴 글자 툴 T 글자 입력이나 수정 선 툴 \\ 직선, 곡선, 나선, 격자, 원형 격자를 그리는 툴 도형 툴 M 사각형, 원형, 다각형, 별, 광선을 그리는 툴 브러시 툴 B 일반적 패스에 다양한 선 모양이나 붓 터치 느낌을 더하는 툴 연필 툴 N 자유롭게 드래그하여 선을 그리는 툴 블럽 브러시 툴 SHIFT+B 면으로 그림을 그리는 툴 지우개 툴 SHIFT+E 벡터 오브젝트를 지우는 툴 가위 툴 C 패스를 자르는 툴 → 열린 패스가 됨 칼 툴 → 닫힌 패스가 됨 회전 툴 R 오브젝트를 회전하거나 반전 스케일 툴 S 오브젝트 크기를 조절하거나 기울임 폭 툴 SHIFT+W 선 폭을 조절하여 구불구불한 형태로 만듦 자유 변형 툴 E 바운딩 박스의 기준점을 조절하여 크기, 기울기, 회전 정도를 조절 도형 구성 툴 SHIFT+M 선택한 여러 오브젝트를 드래그로 연결해서 한 덩어리로 만듦 라이브 페인트 버킷 툴 K 일반 오브젝트 또는 라이브 트레이스를 이용해 만든 오브젝트에 지정한 색이나 속성을 클릭 한 번으로 적용. 속성이 적용될 때에는 식별하기 쉽도록 붉고 굵은 색이 나타남 라이브 페인트 선택 툴 SHIFT+L 라이브 페인트 버킷 툴로 색을 채운 오브젝트만 선택 원근감 격자 툴 SHIFT+P 원근감 있는 일러스트를 그릴 수 있도록 원근감 격자를 만듦 원근감 선택 툴 SHIFT+V 오브젝트, 텍스트, 심벌을 원근감 격자로 드래그해서 입체적으로 적용함 메시 툴 U 오브젝트 내면에 그물망 모양의 기준점을 추가하여 자연스러운 그레이디언트 효과를 만듦. 사진처럼 정교한 일러스트를 그릴 때 사용함 그레이디언트 툴 G 오브젝트에 그레이디언트 효과를 적용 스포이트 툴 I 오브젝트 속성 복제 블렌드 툴 W 서로 다른 속성을 가진 오브젝트를 자연스럽게 연결하고, 변화 단계를 자동으로 만듦 심벌 툴 SHIFT+S 심벌을 만들고 수정할 수 있음. 심벌 뿌리기 툴로 심벌 오브젝트를 만든 뒤 다른 심벌 툴을 이용해서 밀도, 색상, 위치, 크기, 회전, 투명도, 스타일을 바꿀 수 있음 그래프 툴 J 수치만 입력해서 다양한 그래프를 만듦 아트보드 툴 SHIFT+O 아트보드를 추가, 이동, 복사하고 크기를 조절 슬라이스 툴 SHIFT+K 작업 영역을 웹 이미지별로 나누거나 선택 손 툴 H 작업 화면을 드래그해서 원하는 곳으로 옮김 spacebar를 누르면 손 툴 상태가 됨 돋보기 툴 Z 클릭하거나 드래그해서 화면을 확대. Alt와 함께 사용하면 축소. 더불륵릭하면 작업 화면 크기가 100%로 맞춰짐 초기화 버튼 D 선택한 오브젝트 또는 툴 패널의 컬러 속성을 초기화. 면은 흰색, 선 굵기는 1px, 선 색은 검은색. 스타일이나 브러시가 적용되어 있는 오브젝트는 해당 속성이 사라짐 바꾸기 버튼 SHIFT+X 선택한 오브젝트 또는 툴 패널의 선 색과 면 색을 서로 맞바꿉니다. 면(Fill)과 선(Stroke) X 선택한 오브젝트의 면 색과 선 색을 표시함. 투명은 붉은색 사선으로 나타냄 그리기 모드 SHIFT+D Draw Normal, Draw Behind, Draw Inside 화면 모드 F Normal Screen Mode, Full Screen Mode with Menu Bar, Full Screen Mode","categories":[],"tags":[{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"단축키","slug":"단축키","permalink":"http://jacegem.github.io/blog/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"name":"툴","slug":"툴","permalink":"http://jacegem.github.io/blog/tags/%ED%88%B4/"}]},{"title":"일러스트레이터 - 참고 사이트","slug":"2016/일러스트레이터-참고-사이트","date":"2016-02-07T13:18:55.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/일러스트레이터-참고-사이트/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%B0%B8%EA%B3%A0-%EC%82%AC%EC%9D%B4%ED%8A%B8/","excerpt":"","text":"일러스트레이터 - 참고 사이트 일러스트 실무 아카데미 일러스트 연구원 (http://illustin.com) 입필 미래그림연구소 (http://www.ippil.com) 일러스트 아카데미 (http://www.illustacademy.com) 디자인 실무 아카데미 아카데미 정글 (http://www.ejungle.co.kr) 디자인 나스 (http://www.designnas.com) SBS 컴퓨터아트학원 (http://www.sbsart.com) 캘리그래피 전문가 과정 필묵 아카데미 (http://www.philmuk.co.kr) 강병인 캘리그래피 연구소 (http://www.sooltong.co.kr) 캘리디자인 (http://www.callidesign.co.kr) 추천 사이트 디자인넷 (http://www.designnet.co.kr) 디자인 (http://mdesign.design.co.kr) 디자인정글 (http://jungle.co.kr) 디자인플럭스 (www.designflux.co.kr) 컴퓨터아트 (http://www.computerarts.co.uk) 굿디자인 (http://www.goodesign.or.kr) 디자인 클러스터 (http://www.dcluster.seoul.kr) 디자인DB (http://www.designdb.com) 한국디자인진흥원 (http://www.kidp.or.kr) 전시회 서울디자인페스티벌 (http://www.designfestival.co.kr) 서울리빙디자인페어 (http://www.livingdesignfair.co.kr) 서울캐릭터라이선싱페어 (http://characterfair.kr) 디자인 &amp; 아트 페어 (http://www.designartfair.com) TOKYO DESIGNERS WEEK (http://www.tdwa.com) 동경디자인페스타 (http://www.designfesta.com) 런던 100% 디자인 박람회 (http://www.100percentdesign.co.uk) 촬영하고 스크랩하고 기록하기 카메라로 자료가 될만한 것은 모두 찍기 휴대폰이나 수첩에 아이디어 스케치 하기 스크랩북을 만들거나 블로그에 정리하기 추천 이미지 라이브러리 무료 사이트 Stock_XCHNG (http://www.sxc.hu) 모그파일 (http://www.morguefile.com) 쉐어이미지 (http://www.shareimage.com) 추천 이미지 라이브러리 유료 사이트 아사달 정액숍 (http://www.period.assadal.com) 오픈애즈 (http://www.openas.com) 클립아트 코리아 (http://www.clipartkorea.co.kr) 출처 회사에서 바로 통하는 일러스트레이터 CS5 - 박혜진 지음 (한빛미디어)","categories":[],"tags":[{"name":"참고","slug":"참고","permalink":"http://jacegem.github.io/blog/tags/%EC%B0%B8%EA%B3%A0/"},{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"사이트","slug":"사이트","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EC%9D%B4%ED%8A%B8/"}]},{"title":"철수랑 영희랑 고양이랑","slug":"2016/철수랑-영희랑-고양이랑","date":"2016-02-07T06:40:17.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/철수랑-영희랑-고양이랑/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%B2%A0%EC%88%98%EB%9E%91-%EC%98%81%ED%9D%AC%EB%9E%91-%EA%B3%A0%EC%96%91%EC%9D%B4%EB%9E%91/","excerpt":"","text":"철수랑 영희랑 고양이랑 배경과 패턴은 나중에 추가하는 걸로 한다. 각 오브젝트의 경계선이 따로 있어서, 하나를 움직이면 뒷배경이 흰색으로 남는다. 오브젝트들이 연속적으로 이어지게 하려면 어떻게 해야 할까.","categories":[],"tags":[]},{"title":"커피베이에서","slug":"2016/커피베이에서","date":"2016-02-07T02:17:33.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/커피베이에서/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%BB%A4%ED%94%BC%EB%B2%A0%EC%9D%B4%EC%97%90%EC%84%9C/","excerpt":"","text":"2013.09 커피베이에서","categories":[],"tags":[{"name":"커피","slug":"커피","permalink":"http://jacegem.github.io/blog/tags/%EC%BB%A4%ED%94%BC/"},{"name":"커피베이","slug":"커피베이","permalink":"http://jacegem.github.io/blog/tags/%EC%BB%A4%ED%94%BC%EB%B2%A0%EC%9D%B4/"}]},{"title":"임실치즈테마파크 언덕에서","slug":"2016/임실치즈테마파크-언덕에서","date":"2016-02-07T02:10:44.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/임실치즈테마파크-언덕에서/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%9E%84%EC%8B%A4%EC%B9%98%EC%A6%88%ED%85%8C%EB%A7%88%ED%8C%8C%ED%81%AC-%EC%96%B8%EB%8D%95%EC%97%90%EC%84%9C/","excerpt":"","text":"2013.11 임실치즈테마파크 언덕에서","categories":[],"tags":[{"name":"임실","slug":"임실","permalink":"http://jacegem.github.io/blog/tags/%EC%9E%84%EC%8B%A4/"},{"name":"치즈","slug":"치즈","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%98%EC%A6%88/"},{"name":"테마파크","slug":"테마파크","permalink":"http://jacegem.github.io/blog/tags/%ED%85%8C%EB%A7%88%ED%8C%8C%ED%81%AC/"},{"name":"언덕","slug":"언덕","permalink":"http://jacegem.github.io/blog/tags/%EC%96%B8%EB%8D%95/"}]},{"title":"15분 의지","slug":"2016/15분-의지","date":"2016-02-06T13:53:30.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/15분-의지/","link":"","permalink":"http://jacegem.github.io/blog/2016/15%EB%B6%84-%EC%9D%98%EC%A7%80/","excerpt":"","text":"노트를 정리하며, 내용을 옮긴다. 아무리 바빠도, 15분 정도의 시간은 만들려고 한다면 충분히 만들 수 있다. 중요한 것은 15분이라는 시간을 만들 의지가 자신에게 있는가 없는가이다. 당신은 진심으로 어떤 일을 하고 싶은가? 재미있는 일? 오늘 하는 일의 대가는 2년 후에 받을 수 있으리라 생각해야 한다. 무엇인가를 성취하고 싶다면 시간을 들여 스스로 알아나가고 이해해라. 진심으로 열정을 느끼는 일을 찾아라. 잘 들었지? 네가 무슨 일을 하드, 사람들은 항상 트집을 잡고 험담을 할 게다. 그러니 사람들 말에 귀를 기울여서는 안 된단다. – 나스레딘의 아들, 지하드 다르비슈 다들 아는 진리를 깨달았어요. 세상에 쉬운 일은 하나도 없다는 걸. 오히려 쉽다고 생각해서 더 고생한 것 같아요. 그래서 그 다음부터는 그런 기대일랑은 깨끗하게 접었습니다. 편해 보이는 길과 힘들어 보이는 길이 있으면 무조건 힘들어 보이는 길을 택했습니다. 뭐, 고민할 게 없어서 좋더군요. – 우리가 보낸 순간 : 소설 삶은 언제나 나에게 질문을 한다. 쉬운거 할래, 어려운거 할래. 그 질문에 대해서 인간은 언제나 익숙한 것을 선택한다. 상황에 맞는 가면. 그 가면들을 몇 개쯤은 누구나 가지고 살아가지요. 내가 아는 사실을 자연스럽고 자세하게 풀어서 설명하면 좋은 글이 된다. 평범한 진리를 세부적으로 꼼꼼히 묘사하면 문학이 된다. 넓은 줄만 알았던 골목길이 좁아 보이기 시작하면서 우리는 어른이 된다. 어른에게만 시간이 빠르게 느껴지는 이유는 어린아이처럼 많이 걷고 달리지 않기 때문이다. 어떤 문제를 낳게 한 것과 동일한 사고방식으로는 그 문제를 해결할 수 없다. – 알버트 아인슈타인 자신을 통제하는 것보다 더 작은 통제도, 더 큰 통제도 없다. 그것이 가장 작은 통제인 것은 자기 자신조차 통제하지 못하면서 자기 이외의 다른 것을 통제할 수는 없기 때문이며, 그것이 가장 위대한 통제인 것은 자신을 완전히 통제하는 것은 정말 어려운 일이기에 그걸 해내는 것이야말로 다른 어떤 일보다 큰일이기 때문이다. – 레오나르도 다빈치 어떤 외부적인 요인 때문에 괴로워하고 있다면 고통은 그 자체 때문이 아니라 그것에 대한 우리의 생각 때문이다. 그리고 우리는 어느 때든 그 생각을 철회할 힘을 갖고 있다. – 마르쿠스 아우렐리우스","categories":[],"tags":[{"name":"15분","slug":"15분","permalink":"http://jacegem.github.io/blog/tags/15%EB%B6%84/"},{"name":"의지","slug":"의지","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%98%EC%A7%80/"}]},{"title":"밑그림 드로잉 노하우","slug":"2016/밑그림-드로잉-노하우","date":"2016-02-06T13:37:55.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/밑그림-드로잉-노하우/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EB%B0%91%EA%B7%B8%EB%A6%BC-%EB%93%9C%EB%A1%9C%EC%9E%89-%EB%85%B8%ED%95%98%EC%9A%B0/","excerpt":"","text":"노트를 정리하며, 메모한 내용을 옮깁니다. 밑그림 드로잉의 네 가지 노하우 앞에 있는 대상을 먼저 그립니다. 직선은 최대한 반듯하게 한 번에 긋습니다. 마무리에 가까울 수록 연필의 심을 뽀죡하게 깎습니다. 스케치북의 가장 자리는 여백으로 남겨 둡니다.","categories":[],"tags":[{"name":"노하우","slug":"노하우","permalink":"http://jacegem.github.io/blog/tags/%EB%85%B8%ED%95%98%EC%9A%B0/"},{"name":"드로잉","slug":"드로잉","permalink":"http://jacegem.github.io/blog/tags/%EB%93%9C%EB%A1%9C%EC%9E%89/"}]},{"title":"[words] Muscle Organization in Individuals with and without Pair and Joint Dysfunction","slug":"2016/words-Muscle-Organization-in-Individuals-with-and-without-Pair-and-Joint-Dysfunction","date":"2016-02-06T12:56:15.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/words-Muscle-Organization-in-Individuals-with-and-without-Pair-and-Joint-Dysfunction/","link":"","permalink":"http://jacegem.github.io/blog/2016/words-Muscle-Organization-in-Individuals-with-and-without-Pair-and-Joint-Dysfunction/","excerpt":"","text":"단어 dysfunction : [의학] 기능 장애, 고장 masticatory : 저작의, 저작에 쓰는 bilateral : 쌍방의, 좌우 대칭의 electromyography : (의학) 근전도 검사 [기록] (법) incisor : [치과] 앞니 molar : 어금니, 구치 neuromuscular : [생리·생물] 신경과 근육의[에 관한], 신경근의 regression : 후퇴, 쇠퇴, 퇴화 약어 TMD : temporomandibular disorders TMJ : temporomandibular Joint DD : disc displacement MJL : minimization of Joint loads MME : minimization of muscle effort ANOVA : analysis of variance 단어 synovial : [생리] 활액의(을 분비하는) craniormadibular : 두개하악 apparatus : [생리] 기관 indeterminate : 확실하지 않은, 정역학 이론으로는 완전히 분석[결정] 할 수 없는 mastication : 씹음, 저작 apportionment : 분배, 할당 biomechanics : 생체[생물] 역학; 생물의 역학적 연구 effectively : 효과적으로, 유효하게 invasive : [의학] (치료가) 몸에 칼을 대는때 외과적인 electromyographic (EMG) : (의학) 근전도 검사[기록] (법) 의 constrain : 강요하다, 제약을 가하다. numerical : 수의[에 관한]; 수를 나타내는 consistent : 일치하는, 일관된 mandibular : (아래) 턱의, (아랫) 부리의 musculature : 근육 조직 eminence : [해부] (특히 뼈의 표면의) 융기, 돌출 to date : 최신 primarily : 본질적으로, 처음에는 objective : 목적, 객관적인 [의학]&lt;증상이&gt; 타각성의 masseter : [의학] 교근, 저작근 temporalis : 측두근","categories":[],"tags":[{"name":"words","slug":"words","permalink":"http://jacegem.github.io/blog/tags/words/"},{"name":"muscle","slug":"muscle","permalink":"http://jacegem.github.io/blog/tags/muscle/"},{"name":"dysfunction","slug":"dysfunction","permalink":"http://jacegem.github.io/blog/tags/dysfunction/"}]},{"title":"[메모] 노트 사용법","slug":"2016/메모-노트-사용법","date":"2016-02-06T12:04:43.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/메모-노트-사용법/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EB%A9%94%EB%AA%A8-%EB%85%B8%ED%8A%B8-%EC%82%AC%EC%9A%A9%EB%B2%95/","excerpt":"","text":"노트를 이렇게 사용하면 괜찮을 듯싶어서 적는 내용이다. 책에 나온 내용을 정리한다. 하나의 내용은 한 페이지를 모두 사용한다. 페이지가 비었다고 해서 다른 내용을 적지 않는다. 온전히 한 페이지 안에서는 같은 주제를 가지고 있어야 한다. 페이지에 다른 내용을 적는 이유는 단 하나, 남는 여백이 아깝다는 이유일 것이다. 한 페이지 안에 여러 주제가 섞이게 되면 주제가 혼탁해지고, 추가로 적고 싶은 내용이 생겨도 여백이 없어서 적지 못 하는 사태가 발생한다. 뒤에서 시작해도 된다. 앞에서부터 시작해도 되고, 뒤에서부터 시작해도 된다. 계속해서 이어지는 연속성만 있으면 된다. 뒤에서 시작해도 되는 것은 또 다른 주제에 대해서 모으는 길을 만드는 것이다. 앞에서부터는 생각을 모으고, 뒤에서부터는 할 일을 모을 수도 있다. 몇 페이지를 건너뛰고 중간부터 시작하면 나중에 다른 페이지가 채워졌을 때 흐름이 깨질 수 있으므로, 앞·뒤 두 군데에서만 시작해 보자. 예약하자. 만약 여러 페이지를 사용할 예정이라면, 그냥 붕~ 띄우지 말고, 예약 이라는 표시를 남기자. 다른 주제를 메모할 때에는 예약 표시가 없는 부분부터 시작한다. 표시함으로써 기억에 남게 되고, 그 주제에 대해 생각하게 된다. (빈 페이지를 채워야 하는 압박감도 생긴다) 마크다운을 사용하자. 노트에 펜으로 적을 때도 마크다운을 사용한다. 컴퓨터로 내용을 옮길 때에 편하고, 작성할 경우에도 이것이 제목인지, 강조 내용인지 표시할 수 있으므로 더욱 형식화된 문서를 작성할 수 있다. 책에서 옮긴 내용 메모를 재활용하라 예전의 메모를 다시 읽어보는 습관부터 기른다. 메모한 것들을 날짜별 혹은 주제별로 정리한다. 정리된 메모를 문서보관 상자에 보관한다. 다시 읽을 때는 느낀 점이나 아이디어를 다른 색 펜으로 적어둔다. 메모한 것을 다시 읽기 위해서는 메모를 한 곳에 하는 습관이 필요하다. 매번 새로운 곳에 메모하면 이전의 것은 찾기 힘들어진다. 한 곳에 메모하고, 메모가 끝나면 앞 장을 들춰보는 습관을 가진다. 메모한 것을 다시 읽을 때 새로운 생각이나 느낌이 들었다면 그곳에 다시 메모한다. 생각에 생각을 더하는 방식으로 진행한다. 느낀 점을 적기 위해서는 메모한 곳에 충분한 여백이 있어야 한다. 나중에 추가 메모를 위해서 여백을 고려하여 메모한다. 왼쪽에 줄이 그어져 있는 노트를 활용해도 되고, 글을 쓸 때 좌우 여백을 충분히 남기면서 글을 쓰는 습관을 지녀도 괜찮다. 주머니에 휴대할 수 있을 정도의 수첩을 준비한다. 즉시 꺼낼 수 있는 필기도구를 준비한다. (바깥 주머니 등에서 즉시 꺼낼 수 있도록) 상황별 메모 도구 집에서 쉴 때 : A4 용지 크기의 복사용지를 적당히 잘라 상자에 넣은 후 집안 여기저기에 놓고, 그 위에 펜을 올려놓는다. 잘 때 : 머리맡에 노트를 준비해둔다. 잘라 놓은 종이를 활용하려면, 그 종이를 모을 곳이 필요하다. 메일에서 사용하는 보관함 같은 것이 필요하다. 메모를 하고 모으는 상자에 담는다. 따라서 잘라놓은 종이를 사용하기보다는 적당한 크기의 노트를 놓고, 그 위에 펜을 올려놓는 것이 메모를 모으는데 더 편리하다. 잘 때는 빛이 없어서 메모하기에 불편하다. 메모 하기 위해 불을 켜는 것은 수면을 방해하기 때문에 좋지 않다. 빛이 나오는 라이트펜을 사용하는 방법을 고려할 만하다. 수첩 사용 시 주의점 백업작업 : 1년에 한두 번은 메모 내용이나 주소록 등 자료 전체를 복사하여 보관 백업을 할 때는 디지털을 활용하자. 에버노트로 사진을 찍어서 보관하는 방법도 좋다. 무료로 이용해도 한 달에 60MB를 저장할 수 있다. 명함에 주인을 알 수 있도록 메모하라. 명함 교환 시 상대방의 특징을 명함에 메모하라. 메모 습관을 만들기 위한 원포인트 레슨 노트는 비싼 거로 고르자 - 몰스킨 예쁘게 쓰기보다 많이 쓰자 - 여러 곳에서 메모할 수 있도록 환경을 만들자 들고 다니기 편한 게 최고다. 편과 종이의 맛을 살리자 - 노트는 몰스킨, 펜은 기호에 따라 좋은 것으로 고르자. 생각을 검열하지 말자 - 그냥 생각나는 데로 적어보자. 몰스킨 Moleskine 표지가 단단하다. 펼치면 활짝 펼쳐져서 편리하다. 크기가 여러 가지이다. 그림을 그릴 수 있다. &lt;네버랜드를 찾아서&gt; 영화에서 조니 뎁이 이런 말을 했다고 한다. 위대한 생각을 담으려면 최고급 노트가 필요한 법이지!","categories":[],"tags":[{"name":"메모","slug":"메모","permalink":"http://jacegem.github.io/blog/tags/%EB%A9%94%EB%AA%A8/"},{"name":"노트","slug":"노트","permalink":"http://jacegem.github.io/blog/tags/%EB%85%B8%ED%8A%B8/"},{"name":"사용법","slug":"사용법","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"name":"마크다운","slug":"마크다운","permalink":"http://jacegem.github.io/blog/tags/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4/"},{"name":"예약","slug":"예약","permalink":"http://jacegem.github.io/blog/tags/%EC%98%88%EC%95%BD/"},{"name":"주제","slug":"주제","permalink":"http://jacegem.github.io/blog/tags/%EC%A3%BC%EC%A0%9C/"}]},{"title":"[autohotkey] PPT 작성을 위한 AutoHotkey 스크립트","slug":"2016/autohotkey-PPT-작성을-위한-AutoHotkey-스크립트","date":"2016-01-24T11:44:02.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/autohotkey-PPT-작성을-위한-AutoHotkey-스크립트/","link":"","permalink":"http://jacegem.github.io/blog/2016/autohotkey-PPT-%EC%9E%91%EC%84%B1%EC%9D%84-%EC%9C%84%ED%95%9C-AutoHotkey-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/","excerpt":"","text":"WASD 키를 방향키로 변경하기 스크립트를 실행하면, fnOn의 값은 false이기때문에 정상적으로 키입력이 됩니다. 왼손으로 방향키 입력이 필요한 경우에 Capslock + TAB 키를 눌러서 fnOn의 값을 true변경합니다. 이때부터 WASD는 방향키로 동작하게 됩니다. 전체소스는 아래와 같습니다. 12345678fnOn == false~Capslock &amp; TAB::fnOn:=!fnOn#If fnOn a::Send &#123;Left&#125; s::Send &#123;Down&#125; d::Send &#123;Right&#125; w::Send &#123;Up&#125;#If 다른 키들도 변경하기 wasd 가 변경되어서 이미 일반 키보드로써의 기능은 잃어버렸습니다. 다른 키들도 변경되도록 하겠습니다. 동일한 형식으로 작성하여 원하는 키로 변경하면 됩니다. 텐키리스 키보드를 사용중일 때 유용할 수 있도록, 상태변경으로 키패드 입력이 되도록 하겠습니다. 12345678 m::Send 0 j::Send 1 k::Send 2 l::Send 3 u::Send 4 i::Send 5 o::Send 6```language mjkluio 의 키 입력을 각각 0123456으로 변경합니다. 789은 원래의 숫자키를 사용하므로 변경하지 않습니다. PPT 작성중에 복사하기 &amp; 붙여넣기 신공도 많이 사용하게 됩니다. 이것도 추가합니다. 1234c::Send ^cv::Send ^vx::Send ^xz::Send ^z 펑션키도 활용합니다. PPT에서 페이지 단위로 이동할 경우를 고려한 키입력을 추가합니다. 1234F1::Send &#123;Left&#125;F2::Send &#123;WheelUp 2&#125;F3::Send &#123;WheelDown 2&#125;F4::Send &#123;Right&#125; 이렇게 사용하면 장담할수 없지만 작업효율이 0.000001% 정도 올라갈 것으로 예측되옵니다. 전체소스는 아래와 같습니다. 123456789101112131415161718192021222324252627282930313233fnOn == false~Capslock &amp; TAB::fnOn:=!fnOn#If fnOn ;;; function keys F1::Send &#123;Left&#125; F2::Send &#123;WheelUp 2&#125; F3::Send &#123;WheelDown 2&#125; F4::Send &#123;Right&#125; ;;; numbers m::Send 0 j::Send 1 k::Send 2 l::Send 3 u::Send 4 i::Send 5 o::Send 6 ;;; cursor keys a::Send &#123;Left&#125; s::Send &#123;Down&#125; d::Send &#123;Right&#125; w::Send &#123;Up&#125; q::Send &#123;BS&#125; ;e::Send &#123;Delete&#125; e::Send &#123;Enter&#125; r::Send &#123;Enter&#125; c::Send ^c v::Send ^v x::Send ^x z::Send ^z#If 에피소드 #If를 몰랐을때에는 if 로 모든것을 비교했었습니다. 1234567$w::if (fnOn = true) &#123; Send &#123;Blind&#125;&#123;up&#125;&#125; else &#123; Send &#123;Blind&#125;w&#125; return 이렇게요. 하나씩 키 입력을 지정 하려 하다 보니, 중복되는 코드가 너무 많아서 관리가 안되었습니다. 예전소스가 해당 파일에 주석으로 남아있어서 올렸습니다. 결론은… #If를 사용합니다.","categories":[],"tags":[{"name":"ahk","slug":"ahk","permalink":"http://jacegem.github.io/blog/tags/ahk/"},{"name":"autohotkey","slug":"autohotkey","permalink":"http://jacegem.github.io/blog/tags/autohotkey/"},{"name":"ppt","slug":"ppt","permalink":"http://jacegem.github.io/blog/tags/ppt/"},{"name":"script","slug":"script","permalink":"http://jacegem.github.io/blog/tags/script/"}]},{"title":"[jquery] jquery를 사용한 input, select 읽기전용으로 변경","slug":"2016/jquery를-사용한-input-select-읽기전용으로-변경","date":"2016-01-24T11:39:06.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/jquery를-사용한-input-select-읽기전용으로-변경/","link":"","permalink":"http://jacegem.github.io/blog/2016/jquery%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-input-select-%EC%9D%BD%EA%B8%B0%EC%A0%84%EC%9A%A9%EC%9C%BC%EB%A1%9C-%EB%B3%80%EA%B2%BD/","excerpt":"","text":"jquery를 사용한 input 읽기전용 속성 변경 input 태그에 readonly 속성을 추가하여 읽기 전용으로 변경합니다. 123$(function()&#123; $(&#x27;input&#x27;).prop(&#x27;readonly&#x27;, true); // 모든 input 태그를 readonly로 변경함.&#125;); 페이지 onload 이벤트시에 모든 input태그를 읽기전용으로 변경합니다. jquery를 사용한 option 비활성화 select에는 readonly가 없으므로 option에 diabled를 설정해야 합니다. 각 option에 disabled를 설정하여 변경이 안되도록 할 수 있습니다. 123$(function()&#123; $(&#x27;option&#x27;).attr(&#x27;disabled&#x27;, true); // option 태그를 모두 disabled 로 변경함.&#125;); 페이지 onload 이벤트시에 모든 option태그를 비활성화 시킵니다. 참고 http://stackoverflow.com/questions/4610652/jquery-select-option-disabled-if-selected-in-other-select","categories":[],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://jacegem.github.io/blog/tags/jquery/"},{"name":"input","slug":"input","permalink":"http://jacegem.github.io/blog/tags/input/"},{"name":"select","slug":"select","permalink":"http://jacegem.github.io/blog/tags/select/"},{"name":"selector","slug":"selector","permalink":"http://jacegem.github.io/blog/tags/selector/"}]},{"title":"[toad] Script 정보에서 커멘트 정보 얻는 정규표현식","slug":"2016/toad-Script-정보에서-커멘트-정보-얻는-정규표현식","date":"2016-01-24T11:31:04.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/toad-Script-정보에서-커멘트-정보-얻는-정규표현식/","link":"","permalink":"http://jacegem.github.io/blog/2016/toad-Script-%EC%A0%95%EB%B3%B4%EC%97%90%EC%84%9C-%EC%BB%A4%EB%A9%98%ED%8A%B8-%EC%A0%95%EB%B3%B4-%EC%96%BB%EB%8A%94-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/","excerpt":"","text":"Comment from TOAD script ... COMMENT ON TABLE SCHEMA.TABLE IS '테이블명'; COMMENT ON COLUMN SCHEMA.TABLE.COL_YYMM IS '컬럼년월'; COMMENT ON COLUMN SCHEMA.TABLE.COL_NO IS '컬럼번호'; COMMENT ON COLUMN SCHEMA.TABLE.COL_CODE IS '컬럼코드'; ... toad 에서 테이블 script 정보를 확인하면 위와 같은 형식으로 되어 있는 스크립트를 확인할 수 있습니다. ERD 확인이 어려운 경우에 스크립트에 있는 Comment정보로 한글명을 확인합니다. Regular expression 엑셀에 넣기 위해 각 항목을 탭으로 구분되도록 변경합니다. 1COMMENT ON (TABLE|COLUMN) \\w+?\\.(\\w+)\\.?(\\w+)? IS &#x27;(\\w+)&#x27;;\\s* 모두 시작은 COMMENT ON으로 시작하므로 문자열 그대로 사용합니다. COMMENT ON 그 다음 TABLE 또는 COLUMN 문자열이 올수 있으므로 그룹으로 지정합니다. (TABLE|COLUMN) 그 다음 첫번째 점(.) 이전에는 스키마정보가 있습니다만 필요 없으므로 이부분은 그룹핑에서 제외합니다. \\w+?\\. 그 다음 테이블명이 옵니다. 그룹핑을 합니다. 그 뒤에 테이블인 경우에는 아무것도 없지만 컬럼명인 경우에는 점(.)이 따라옵니다. (\\w+)\\.? 그 다음 컬럼명이 옵니다. 그룹핑을 하지만 테이블인 경우에는 해당 내용이 없으므로 ?를 사용합니다. (\\w+)? 그 다음 IS 문자열이 옵니다. 그대로 적습니다. IS 그 다음 한글로 된 커멘트가 옵니다. 커멘트는 작은따옴표로 감싸여 있습니다. '(\\w+)' 그 다음 세미콜론(;)이 오고 줄바꿈기호가 있습니다. ;\\s* 그룹핑한 정보들만으로 치환하여 원하는 값을 추출합니다. 1$1\\t$2\\t$3\\t$4\\n 그룹핑된 정보들을 탭 구분으로 변경합니다. 맨 마지막에는 줄바꿈을 포함합니다. $1에는 TABLE 또는 COLUMN 문자열이 매칭되어 있습니다. $2에는 테이블명이 매칭되어 있습니다. $3에는 컬럼명이 매칭되어 있습니다. 테이블 커멘트에서는 아무것도 매칭되어 있지 않습니다. $4에는 한글설명이 매칭되어 있습니다. Notepad++ 를 이용한 치환 [notepad++]에서 치환한 모습입니다. 12찾을내용: COMMENT ON (TABLE|COLUMN) \\w+?\\.(\\w+)\\.?(\\w+)? IS &#x27;(\\w+)&#x27;;\\s*바꿀내용: $1\\t$2\\t$3\\t$4\\n","categories":[],"tags":[{"name":"script","slug":"script","permalink":"http://jacegem.github.io/blog/tags/script/"},{"name":"toad","slug":"toad","permalink":"http://jacegem.github.io/blog/tags/toad/"},{"name":"regex","slug":"regex","permalink":"http://jacegem.github.io/blog/tags/regex/"},{"name":"comment","slug":"comment","permalink":"http://jacegem.github.io/blog/tags/comment/"}]},{"title":"[jstl] callback 함수명 전달하기","slug":"2016/jstl-callback-함수명-전달하기","date":"2016-01-24T11:26:07.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/jstl-callback-함수명-전달하기/","link":"","permalink":"http://jacegem.github.io/blog/2016/jstl-callback-%ED%95%A8%EC%88%98%EB%AA%85-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0/","excerpt":"","text":"JSTL을 사용하여 child window에서 부모창 함수를 호출합니다. 팝업창 생성시에 부모창의 함수명을 서버로 전달하고, 해당 함수명을 받아서 호출할 수 있도록 합니다. JSTL : JavaServer Pages Standard Tag Library 파라미터로 전달한 함수명을 이용하여 함수를 호출합니다. 1234&lt;%@ page import=&quot;org.apache.commons.lang3.StringUtils&quot;%&gt;function callback() &#123; parent.&lt;%=!StringUtils.defaultString(request.getParameter(&quot;callback&quot;)).equals(&quot;&quot;) ? request.getParameter(&quot;callback&quot;) : &quot;defaultCallback&quot;%&gt;();&#125; !(not) 을 제거하고 삼항연산자의 순서를 변경합니다. 1parent.&lt;%=StringUtils.defaultString(request.getParameter(&quot;callback&quot;)).equals(&quot;&quot;) ? &quot;defaultCallback&quot; : request.getParameter(&quot;callback&quot;) %&gt;(); 다른 방법으로는 서버로 전달하지 않고, 부모창에서 바로 자식창에 호출받을 callback 함수를 지정할 수도 있습니다. 또는 eval() 함수를 이용하여 서버로 전달된 함수명을 통해서 호출할 수도 있습니다.","categories":[],"tags":[{"name":"jstl","slug":"jstl","permalink":"http://jacegem.github.io/blog/tags/jstl/"},{"name":"callback","slug":"callback","permalink":"http://jacegem.github.io/blog/tags/callback/"},{"name":"function","slug":"function","permalink":"http://jacegem.github.io/blog/tags/function/"}]},{"title":"[IFTTT] IF THIS THEN THAT","slug":"2016/android-IF-THIS-THEN-THAT-IFTTT","date":"2016-01-22T12:53:48.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/android-IF-THIS-THEN-THAT-IFTTT/","link":"","permalink":"http://jacegem.github.io/blog/2016/android-IF-THIS-THEN-THAT-IFTTT/","excerpt":"","text":"15 Best New Writing Apps You’ve Never Heard of를 통해서 IFTTT를 알게되었습니다. Tasker와 비슷하지만 다양한 서비스와 쉽게 연동할 수 있는 장점이 있습니다. 지정한 이벤트가 발생하면 정해진 동작이 실행되도록 설정할 수 있는 서비스입니다. Recipes 다양한 Recipes 조리법들이 제공되고 있습니다. 로그인하여 접속하면 3가지의 텝 메뉴를 볼 수 있습니다. Remmemded 탭에서 이용자들이 많이 사용하고 있는 Recipes를 확인할 수 있습니다. 추천 항목은 접속할 때마다 변경됩니다. 천천히 어떤 조리법들이 있는지 확인해 보고 필요한 조리법을 사용하면 됩니다. Recipes는 두가지로 분류됩니다. Do Recipes와 IF Recipes 입니다. DO Recipes Do Recipes는 사용자가 어플에 설치한 버튼을 클릭하면 발생하는 것입니다. 다양한 서비스들이 제공되고 있습니다. Do Camera, Do Note, Do Button 이렇게 3가지로 분류가 있습니다. Do Camera는 카메라로 사진을 촬영했을때에, Do Note 는 새로운 문서(글)을 작성 했을때에, Do Button은 버튼을 터치 했을때에, 실행될 동작을 지정하는 서비스입니다. 각 Do Recipes 에서 사용중인 것을 하나씩만 설명하면 아래와 같습니다. Do Camera 에 Email yourself this photo 를 추가했습니다. 사진을 찍으면 그 사진이 이메일로 전송되도록 해줍니다. 사진 백업용으로 사용할 수 있습니다. DO Note 에 Save notes on the fly 를 추가했습니다. Do Note를 실행하고, 입력하고 싶은 내용을 적은 다음에 하단에 있는 버튼을 클릭하면 바로 에버노트에 새로운 문서로 추가되는 서비스 입니다. Do Button에 Track your journey를 추가했습니다. Do Button을 터치하면 나의 위치정보와 시간정보, 지도이미지가 구글 스프레드시트에 한 줄씩 저장 되는 서비스입니다. IF Recipes If Recipes는 미리 조건을 설정해 놓고, 해당 조건에 맞으면 실행이 되는 서비스입니다. 사용중인 IF Recipes 입니다. Save new texts you receive in a Google Spreadsheet 새로운 문자가 오면 구글 드라이브의 스프레드 시트에 한줄씩 기록하는 서비스입니다. 휴대전화와 별로도 내 문자를 보관할 수 있도록 도와줍니다. Create - 나만의 조리법 생성 먼저 this 를 설정합니다. 발생 조건을 설정하는 부분입니다. 발생 조건으로 새로운 문자 메시지를 받는 경우로 설정하였습니다. 그리고 해당 조건이 발생하면 실행될 동작을 설정합니다. 새로운 문자 메시지를 받으면 구글 캘린더에 추가하도록 설정한 모습입니다. Twitter, Facebook, instagram 등 설정할 수 있는 다양한 서비스 연동을 제공하고 있으므로, 필요에 따라 알맞은 조리법을 만들면 됩니다. Android DO Recipes는 어플이 있어야 사용할 수 있습니다. ITFFF 에서 제공하는 Android 어플은 아래와 같습니다. IF는 IF Recipes를 설정하거나 변경할 수 있는 어플입니다. Do Button,Do Note,Do Camera는 각각 Do Recipes를 실행할 수 있는 어플입니다.","categories":[],"tags":[{"name":"do","slug":"do","permalink":"http://jacegem.github.io/blog/tags/do/"},{"name":"ifttt","slug":"ifttt","permalink":"http://jacegem.github.io/blog/tags/ifttt/"},{"name":"sms","slug":"sms","permalink":"http://jacegem.github.io/blog/tags/sms/"},{"name":"google","slug":"google","permalink":"http://jacegem.github.io/blog/tags/google/"},{"name":"drive","slug":"drive","permalink":"http://jacegem.github.io/blog/tags/drive/"},{"name":"spreadsheet","slug":"spreadsheet","permalink":"http://jacegem.github.io/blog/tags/spreadsheet/"}]},{"title":"[하스스톤] 선술집 - 블랙하트 선장의 보물 상자","slug":"2016/하스스톤-선술집-블랙하트-선장의-보물-상자","date":"2016-01-21T12:34:55.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/하스스톤-선술집-블랙하트-선장의-보물-상자/","link":"","permalink":"http://jacegem.github.io/blog/2016/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4-%EC%84%A0%EC%88%A0%EC%A7%91-%EB%B8%94%EB%9E%99%ED%95%98%ED%8A%B8-%EC%84%A0%EC%9E%A5%EC%9D%98-%EB%B3%B4%EB%AC%BC-%EC%83%81%EC%9E%90/","excerpt":"","text":"이번 선술집은 블랙하트 선장의 보물 상자입니다. 선장의 보물 상자는 누구에게나 열려 있습니다. 결국엔 당신이 갖겠지만요! 내 턴마다 보물 상자 안에 들어있는 무작위로 선택된 3장의 카드 중 하나를 골래 내 손으로 가져올 수 있습니다! 매 턴마다 3개의 카드가 주어지고 이 중에 하나를 선택하면 내 손 패에 추가됩니다. 게임을 시작하면 30장의 카드는 모두 해적으로 구성되어 있습니다. 혹시나 다른 카드가 있을까 하는 생각에 모두 바꾸어 보았지만, 반전은 없었습니다. 이번 선술집 전략 높은 등급의 카드를 선택합니다. 카드의 등급은, 전설 등급, 영웅 등급, 희귀 등급, 일반 등급으로 나누어 집니다. 생매장은 일반카드, 시린빛 점쟁이는 희귀카드, 고위 성전사는 영웅카드이므로, 이번 선택에서는 고위 성전사를 고릅니다. 자주(?) 전설카드가 등장합니다. 이때는 전설 카드를 선택하는 것이 일반적으로는 유리합니다. 사용할 수 있는 마나수정이 3개였지만, 전설카드를 선택하였습니다. 이번에도 선택이 너무 쉬웠습니다. 바로 리로이 젠킨스를 선택하고 진행하였습니다. 마나수정의 수를 고려하여 이번턴에 사용할 수 있는 카드를 고릅니다. 마나 수정이 2개인 턴일 경우에는 2마나 카드를 선택하는 것입니다. 이런 경우에 2마나 카드를 선택합니다. 3장의 카드가 모두 저코스트 라서 고민할 것이 별로 없었지만, 이 경우에는 기계 카드가 나올 확률이 적기 때문에 광기의 연금술사를 선택합니다. 마나가 많은 경우에는 높은 코스트를 가지고 있는 카드를 선택합니다. 이럴 때에는 7코스트 카드를 선택하는 것이 유리합니다. 선택한 영웅과 호흡이 잘 맞는 카드를 선택합니다. 이번 게임에서는 사제를 영웅으로 선택하여 진행하였습니다. 호흡이 잘 맞는 카드는 직업카드 입니다. 해당 영웅만이 사용할 수 있는 카드를 의미합니다. 세 카드가 모두 희귀 등급카드 였지만, 고민할 필요도 없이 바로 아키나이 영혼사제를 선택하면 됩니다. 사제와 호흡이 가장 잘 맞는 카드입니다. 빛샘까지 들어왔습니다. 체력걱정은 잠시 잊어도 될 것 같습니다. 후기 드디어 9마나가 되었고, 페일트리스를 사용하였습니다. 격려를 통해 전설을 소환합니다. 브란 브론즈비어드가 있을때에, 리로이 젠킨스를 던졌습니다. 전설의 역효과 입니다. 연금술사로 공격력과 생명력을 바꾸었지만, 이 역시 브란 브론즈비어가 있어서, 2번 발동되어, 원래의 상태가 되었습니다. 이렇게 필드를 잡아가고 있었는데, 일렉스트라자가 등장합니다. 그렇게 바로 15피가 되어버렸습니다. ㅠㅠ 혼란으로 어찌어찌 괴물녀석을 때려잡고 살아가지만, 반피가 된 채로 근근히 살아가던중에 구세주를 만납니다. 흐흐흐, 끝이다! 참고 https://namu.wiki/w/하스스톤%3A 워크래프트의 영웅들/카드일람/전설 등급","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/%EC%84%A0%EC%88%A0%EC%A7%91/"}]},{"title":"[영상] 영상을 제작할 때의 참고 사항","slug":"2016/영상-영상을-제작할-때의-참고-사항","date":"2016-01-14T11:31:55.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/영상-영상을-제작할-때의-참고-사항/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EC%98%81%EC%83%81-%EC%98%81%EC%83%81%EC%9D%84-%EC%A0%9C%EC%9E%91%ED%95%A0-%EB%95%8C%EC%9D%98-%EC%B0%B8%EA%B3%A0-%EC%82%AC%ED%95%AD/","excerpt":"","text":"영상을 제작할 때의 참고 사항 사진의 기본 원칙인 수평선과 수직선을 맞추고 여백을 잘 정리해야 한다. 흔들림이 없는 안정된 영상을 제작한다. 시청자들이 편안하게 볼 수 있는 높이에서 촬영한다. - eye level, High Angle, Low Angle 동일한 크기의 Shot, 동일한 움직임(pan-pan, zoom-in, zoom-out)을 피한다. - Panning의 방향은 왼쪽에서 오른쪽으로 Long Shot은 길게, Close-up은 짧게 촬영해 시청자들이 인지할 시간적 여유를 준다. 방향성과 화면 연결을 고려한다. 장면을 분할해서 촬영한다. 스플릿 편집을 고려한다. 시간을 조절할 영상을 촬영한다. 상징적 표현 기법을 활용한다. - 다양한 각도의 앵글, 클로즈업 프레임 인-아웃, 분리 컷인 리액션 컷, 인서트 컷 창조성이 원칙보다 우선이다. - 원칙을 파기하라. 마음과 몸을 편하게 가진다. 취재하는 내용을 미리 파악하기 위해 평소에 많이 준비한다. - 노오오오력 피사계 심도를 잘 이용한다. - ND Filter, Shutter Speed 자연스러운 화면을 만드려면 마이크를 감춘다. - 모르게 하라. 하던 일을 하면서 대화하면 자연스러운 인터뷰를 할 수 있다. - 배려 카메라 위치를 인터뷰할 사람과 멀리한다. - 숨겨라 인터뷰 할 때 배경을 단순화한다. - 강조 자연광을 살리고 가급적 조명을 사용하지 않으면서 그곳의 조명을 이용한다. - 간접 조명 동적인 대상을 Close-up으로 촬영하려면 피사체에서 멀리 떨어져서 촬영한다. - 동적인 영상을 크게 찍고 싶을수록 뒤에서 걸어오는 사람을 촬영할 때는 오는 사람의 오른쪽에서 촬영한다. 역광과 심도를 잘 조절한다. 수직선이 많은 곳에서는 Low Angle을 사용한다. - Low Angle 그림이 되지 않는 아이템일수록 잘 생각하면서 촬영한다. 평소에 볼 수 있는 시각 앵글에서 뉴스를 촬영한다. 카메라 Gain을 올리면 화면이 거칠어 사용할 수 없다는 생각에서 탈피해야 한다. 장비 작동 방법을 연습한다. 장비에 항상 테이프(기록 매체)와 배터리를 넣고 다녀야 한다 - 촬영기자의 경우 사건 사고 대비 항상 가상으로 촬영 콘티를 짜는 연습을 한다. - 습관 참고 책. 베가스 프로 9","categories":[],"tags":[{"name":"영상","slug":"영상","permalink":"http://jacegem.github.io/blog/tags/%EC%98%81%EC%83%81/"},{"name":"촬영","slug":"촬영","permalink":"http://jacegem.github.io/blog/tags/%EC%B4%AC%EC%98%81/"},{"name":"참고","slug":"참고","permalink":"http://jacegem.github.io/blog/tags/%EC%B0%B8%EA%B3%A0/"},{"name":"베가스","slug":"베가스","permalink":"http://jacegem.github.io/blog/tags/%EB%B2%A0%EA%B0%80%EC%8A%A4/"},{"name":"vegas","slug":"vegas","permalink":"http://jacegem.github.io/blog/tags/vegas/"}]},{"title":"[excel] 문자열 나누기 - 데이터 타입과 길이 분할","slug":"2016/excel-문자열-나누기-데이터-타입과-길이-분할","date":"2016-01-12T07:13:06.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/excel-문자열-나누기-데이터-타입과-길이-분할/","link":"","permalink":"http://jacegem.github.io/blog/2016/excel-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%98%EB%88%84%EA%B8%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC-%EA%B8%B8%EC%9D%B4-%EB%B6%84%ED%95%A0/","excerpt":"","text":"[excel] 문자열 나누기 - 데이터 타입과 길이 분할 VARCHAR2(80)과 같은 데이터 값을 분할하여 VARCHAR2, 80으로 만들기 위한 함수를 생성합니다. 처음 조건으로 ‘(’ 를 포함하고 있는가를 확인합니다. FIND 함수를 사용합니다. NUMBER와 같이 길이 정보가 없는 경우가 있기에 이를 구별할 필요가 있습니다. =FIND(&quot;(&quot;,E2) 해당 문자를 포함하고 있으면 인덱스를 반환하지만 없으면 #VALUE! 에러를 반환하게 됩니다. 에러를 처리하기 위해 ISNUMBER 함수를 사용하여 감싸줍니다. =ISNUMBER(FIND(&quot;(&quot;,E2)) ‘(’ 를 포함하고 있는 문자열인 경우에는 true, 아니면 false 를 반환합니다. 이 함수를 IF 함수로 감싸서, ‘(’ 문자를 포함하고 있는 경우와 아닌 경우를 나눠서 처리합니다. =IF(ISNUMBER(FIND(&quot;(&quot;,E2)), &quot;포함하는 경우&quot;, &quot;없는 경우&quot;) 각각 “포함하는 경우”, &quot;없는 경우&quot;를 구분하여 함수를 생성합니다. 포함하는 경우에는 ‘(’ 문자 이전까지의 문자를 반환하도록 합니다. VARCHAR2(80) 의 경우 VARCHAR2 가 반환되도록 하는 것이 목적입니다. =LEFT(E2, FIND(&quot;(&quot;,E2) -1) 포함하지 않는 경우에는 그 자체로 반환하면 됩니다. =E2 두 가지 경우에 대한 내용을 모두 IF 함수 안에 포함합니다. =IF(ISNUMBER(FIND(&quot;(&quot;,E2)), LEFT(E2, FIND(&quot;(&quot;,E2) -1), E2 ) 이 함수를 사용하여 타입 정보를 추출합니다. 뒤에 있는 길이 정보도 동일한 방식으로 추출합니다. 길이 정보는 뒤에 있는 ‘)’ 문자 이전까지의 정보를 추출하기 때문에 MID 함수를 사용하여 추출합니다. 길이 정보가 없는 경우에는 빈문자열을 반환하도록 처리합니다. =IF(ISNUMBER(FIND(&quot;(&quot;,E2)), MID(E2, FIND(&quot;(&quot;,E2)+1, LEN(E2)-FIND(&quot;(&quot;,E2)-1 ), &quot;&quot; ) 참고 http://www.tuning-java.com/267 http://seongsland.tistory.com/136 http://mainia.tistory.com/498","categories":[],"tags":[{"name":"excel","slug":"excel","permalink":"http://jacegem.github.io/blog/tags/excel/"},{"name":"substring","slug":"substring","permalink":"http://jacegem.github.io/blog/tags/substring/"},{"name":"type","slug":"type","permalink":"http://jacegem.github.io/blog/tags/type/"},{"name":"length","slug":"length","permalink":"http://jacegem.github.io/blog/tags/length/"},{"name":"엑셀","slug":"엑셀","permalink":"http://jacegem.github.io/blog/tags/%EC%97%91%EC%85%80/"},{"name":"문자열","slug":"문자열","permalink":"http://jacegem.github.io/blog/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"분할","slug":"분할","permalink":"http://jacegem.github.io/blog/tags/%EB%B6%84%ED%95%A0/"}]},{"title":"[c#] 대용량 숫자 값들 중에서 중복 확인","slug":"2016/c-대용량-숫자-값들-중에서-중복-확인","date":"2016-01-12T06:56:06.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/c-대용량-숫자-값들-중에서-중복-확인/","link":"","permalink":"http://jacegem.github.io/blog/2016/c-%EB%8C%80%EC%9A%A9%EB%9F%89-%EC%88%AB%EC%9E%90-%EA%B0%92%EB%93%A4-%EC%A4%91%EC%97%90%EC%84%9C-%EC%A4%91%EB%B3%B5-%ED%99%95%EC%9D%B8/","excerpt":"","text":"[c#] 대용량 숫자 값들 중에서 중복 확인 총 숫자 카운트 확인 배열 생성 배열에 할당 Array.Sort 이전값과 비교 위와 같은 순서로 진행합니다. 총 숫자 카운트를 확인합니다. 파일에 저장된 데이터를 읽습니다. 한줄에 하나씩의 데이터를 읽어오기 때문에, 줄 수를 카운트 합니다. 12345678string path = @&quot;c:\\test\\code\\&quot;; string[] filePaths = Directory.GetFiles(path);int lineCnt = 0;foreach (string file in filePaths)&#123; string[] lines = System.IO.File.ReadAllLines(file); lineCnt += lines.Length;&#125; 카운트 크기의 배열을 생성합니다. 1long[] codes = new long[lineCnt]; 다시 파일을 읽으면서 원하는 정보를 추출하여 할당합니다. 123456789101112int rowIdx = 0;long val = 0;long[] codes = new long[lineCnt];foreach (string file in filePaths) &#123; string[] lines = System.IO.File.ReadAllLines(file); foreach (string line in lines) &#123; string[] infos = line.Split(&#x27;\\t&#x27;); string firstVal = infos[0]; codes[rowIdx++] = long.Parse(code); &#125;&#125; 값을 할당한 배열을 정렬합니다. 12Array.Sort(codes); 정렬된 배열에서 중복값을 확인합니다. 이전값과 같은지 비교합니다. 1234567891011long last = -1;for (int i = 0; i &lt; rowIdx; i++) &#123; cd = codes[i]; if (last == cd) &#123; Console.WriteLine(&quot;중복:&quot;+cd); Console.ReadLine(); &#125; else &#123; last = cd; &#125;&#125; 참고 Sorting Arrays [C#] c# Stopwatch 사용 ( 시간체크, 동작시간 )","categories":[],"tags":[{"name":"c#","slug":"c","permalink":"http://jacegem.github.io/blog/tags/c/"},{"name":"array","slug":"array","permalink":"http://jacegem.github.io/blog/tags/array/"},{"name":"duplcate","slug":"duplcate","permalink":"http://jacegem.github.io/blog/tags/duplcate/"},{"name":"중복","slug":"중복","permalink":"http://jacegem.github.io/blog/tags/%EC%A4%91%EB%B3%B5/"}]},{"title":"블루투스 이어폰 알아보기","slug":"2016/블루투스-이어폰-알아보기","date":"2016-01-10T11:31:55.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/블루투스-이어폰-알아보기/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EB%B8%94%EB%A3%A8%ED%88%AC%EC%8A%A4-%EC%9D%B4%EC%96%B4%ED%8F%B0-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/","excerpt":"","text":"HBS-810과 비교하여 HBS-900, HB-850은 무게가 더 무거우며 HBS-810보다 이전 출시 모델이므로 비교에서 제외하였습니다. HBS의 경우 LG 제품이고 마지막에 있는 SBH모델을 SONY 제품입니다. 제품 HBS-500 HBS-760 HBS-810 SBH80 무게(g) 29 34.2 41 15.8 불루투스버전(ver) 4.1 4.1 4.1 3.0 줄감기 no no yes no 연속통화시간(h) 9 16 17 9 연속음악재생(h) 7.5 10.5 13 6 대기시간(h) 500 540 550 430 무게만 생각한다면 SBH80이 유리하다. 배터리 시간까지 생각한다면 결과는 달라진다. HBS-810과 같이 줄감기 기능이 있으면, 선이 얇아지고, 뺏을때에 꼬임현상이 발생한다고 한다. HBS-760을 가격을 확인하다 보면 놀라운 점을 발견할 수 있다. 색상 마다 가격이 다르다. 샤오미캠의 경우에 녹색이 비싸다는 것은 경험했지만, HBS-760처럼 색상마다 가격이 다르다는 것에 놀라움을 다시 경험했다. 한 오픈마켓의 가격을 보면 아래와 같다. 보라색이 가장 싸다. 검은색이 가장 비싸다. 색상 선호도를 의미하는 듯 하다. 잘 팔린다고 비싸게 파는 것일까?? 혹시 염료의 원가 차이가 있는것인가?? 기승전흑 보라 &lt; 파랑 = 빨강 &lt; 하양 &lt; 검정 가격 검정색을 기준으로 찾아보자. 배송비를 포함한 가격으로 알아본다. 제품 가격 HBS-760 5.7(기본) + 0.4(추가) + 0.25(배송) = 6.35 HBS-810 8.7(기본) + 1.0(추가) + 0.25(배송) = 9.95 2016.02.14 기준 다나와를 경우한 가격입니다. HBS-760 vs HBS-810 HBS-760 과 HBS-810. 두 가지 모델의 차이점은 줄감기 기능과 가격이다. 참고 LG TONE+ HBS-810 블루투스 구입 후 사용기 LG 블루투스 이어폰 HBS-810 사용 후기및 비교 LG TONE 시리즈 LG 블루투스이어폰, LG 톤플러스 전체 라인업 살펴보기 블루투스 이어폰 LG HBS 760 vs 810","categories":[{"name":"Product","slug":"Product","permalink":"http://jacegem.github.io/blog/categories/Product/"},{"name":"Earphone","slug":"Product/Earphone","permalink":"http://jacegem.github.io/blog/categories/Product/Earphone/"}],"tags":[{"name":"bluetooth","slug":"bluetooth","permalink":"http://jacegem.github.io/blog/tags/bluetooth/"},{"name":"earset","slug":"earset","permalink":"http://jacegem.github.io/blog/tags/earset/"},{"name":"headset","slug":"headset","permalink":"http://jacegem.github.io/blog/tags/headset/"},{"name":"earphone","slug":"earphone","permalink":"http://jacegem.github.io/blog/tags/earphone/"},{"name":"hbs-810","slug":"hbs-810","permalink":"http://jacegem.github.io/blog/tags/hbs-810/"},{"name":"hbs-760","slug":"hbs-760","permalink":"http://jacegem.github.io/blog/tags/hbs-760/"}]},{"title":"[algospot] MERCY","slug":"2016/Algospot-MERCY","date":"2016-01-10T04:48:56.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/Algospot-MERCY/","link":"","permalink":"http://jacegem.github.io/blog/2016/Algospot-MERCY/","excerpt":"","text":"[algospot] 알고스팟 - MERCY scala로 작성해보려 합니다. 먼저 튜토리얼을 확인해 봅니다. 스칼라의 경우에도, main() 함수가 있는 오브젝트의 이름은 항상 Main 이어야 한다. 123456789object Main &#123; def main(args: Array[String]): Unit = &#123; var cases = Integer.parseInt(readLine()) while (cases &gt; 0) &#123; println(&quot;Hello, &quot; + readLine() + &quot;!&quot;) cases -= 1 &#125; &#125;&#125; 위의 예시코드를 확인할 수 있습니다. Scala의 새 버전(2.11.1)에서는 scala.readLine()함수 대신 scala.io.StdIn.readLine()을 사용해야 한다고 합니다. 정수를 입력 받을 때는 scala.io.StdIn.readInt(). 코드를 살피던 중 위와 같은 댓글을 확인할 수 있었습니다. 버전차이로 인한 문제가 발생할 수 있을지도 모른다는 생각이었지만, 일단은 예시코드를 변형하여 답안을 제출하겠습니다. 123456789object Main &#123; def main(args: Array[String]): Unit = &#123; var cases = Integer.parseInt(readLine()) while (cases &gt; 0) &#123; println(&quot;Hello Algospot!&quot;) cases -= 1 &#125; &#125;&#125; MERCY 문제의 경우 Hello Algospot!를 출력하면 되기 때문에, 예시코드에서 출력부분만 바꾸어서 제출하였습니다. 버전 차이로 인한 오답이 될 줄 알았지만, 무사히 정답으로 처리되었습니다.","categories":[],"tags":[{"name":"algospot","slug":"algospot","permalink":"http://jacegem.github.io/blog/tags/algospot/"},{"name":"mercy","slug":"mercy","permalink":"http://jacegem.github.io/blog/tags/mercy/"},{"name":"algorithm","slug":"algorithm","permalink":"http://jacegem.github.io/blog/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://jacegem.github.io/blog/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"알고스팟","slug":"알고스팟","permalink":"http://jacegem.github.io/blog/tags/%EC%95%8C%EA%B3%A0%EC%8A%A4%ED%8C%9F/"}]},{"title":"티스토리 #1 스킨 수정하기","slug":"2016/티스토리-1-스킨-수정하기","date":"2016-01-09T00:37:27.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/티스토리-1-스킨-수정하기/","link":"","permalink":"http://jacegem.github.io/blog/2016/%ED%8B%B0%EC%8A%A4%ED%86%A0%EB%A6%AC-1-%EC%8A%A4%ED%82%A8-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/","excerpt":"","text":"티스토리 #1 스킨 수정하기 폰트 변경 CSS 편집화면으로 이동합니다. 관리 &gt; 꾸미기 &gt; HTML/CSS 편집 &gt; CSS font-family 값을 '나눔고딕',NanumGothic,'돋움',Dotum,helvetica,sans-serif,tahoma; 로 수정합니다. 또는 원하는 폰트로 변경하시면 됩니다. font-family:'나눔고딕',NanumGothic,'돋움',Dotum,helvetica,sans-serif,tahoma; 상단 프로파일 수정 HTML 편집화면으로 이동합니다. 관리 &gt; 꾸미기 &gt; HTML/CSS 편집 &gt; HTML 필명과 타이틀이 표시되는 부분을 수정합니다. 필명 위치에 타이틀이 표시되도록 하기 위하여 코드를 수정합니다. 1&lt;button type=&quot;button&quot; class=&quot;btn_name txt_condition&quot;&gt;[##_title_##] [##_blogger_##] 대신에 타이틀 표출을 위해 [##_title_##]로 변경합니다. 표출되는 색을 타이틀과 동일하도록 변경하기 위해 class에 txt_condition를 추가합니다. 1&lt;!-- &lt;p class=&quot;txt_condition&quot;&gt;[##_title_##]&lt;/p&gt; --&gt; 타이틀이 출력되는 위치 입니다. 보이고 싶지 않은 경우에는 해당 태그를 주석처리 합니다. 카테고리에 리스트 스크롤 추가 .area_menu .list_cat 클래스에 속성 두가지를 추가합니다. ovevflow:auto; height:80vh;","categories":[],"tags":[{"name":"티스토리","slug":"티스토리","permalink":"http://jacegem.github.io/blog/tags/%ED%8B%B0%EC%8A%A4%ED%86%A0%EB%A6%AC/"},{"name":"스킨","slug":"스킨","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%ED%82%A8/"},{"name":"tistory","slug":"tistory","permalink":"http://jacegem.github.io/blog/tags/tistory/"},{"name":"skin","slug":"skin","permalink":"http://jacegem.github.io/blog/tags/skin/"}]},{"title":"하스스톤 선술집 - 외길인생","slug":"2016/하스스톤-선술집-외길인생","date":"2016-01-07T15:02:43.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/하스스톤-선술집-외길인생/","link":"","permalink":"http://jacegem.github.io/blog/2016/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4-%EC%84%A0%EC%88%A0%EC%A7%91-%EC%99%B8%EA%B8%B8%EC%9D%B8%EC%83%9D/","excerpt":"","text":"외길인생 4가지 중에서 한 가지를 선택합니다. 선택한 한 가지를 따라가는 외길인생입니다. 해당 능력은 게임을 진행하는 동안 계속해서 적용되므로 알맞은 것은 선택해야 합니다. 능력에 맞는 덱 구성이 되어 있어야 합니다. 원하는 게 무엇입니까? 전투의 함성, 죽음의 메아리, 주문, 멀록, 무엇이든 골라보세요! 덱을 만들고, 편을 고르고, 게임을 시작합니다! 죽음의 메아리 보너스 : 죽음의 메아리 능력을 가진 내 하수인들이 +1/+1을 얻습니다. 주문 보너스 : 내가 주문을 시전할 때마다 방어도를 +3 얻습니다. 멀록 보너스 : 내 턴이 끝날 때마다 1/1 멀록을 1마리 소환합니다. 전투의 함성 보너스 : 전투의 함성 능력을 가진 내 하수인들이 +1/+1을 얻습니다. 죽음의 메아리 카드와 전투의 함성 카드는 일반 카드에 많이 있으니, 어떤 영웅으로 선택하여도 구성할 수 있습니다. 주문 보너스는 방어도를 얻기 때문에 전사로 덱을 구성하는 편이 유리합니다. 멀록 보너스는 성기사 또는 주술사로 덱을 구성하는 편이 유리합니다. 스마트폰으로 하스스톤을 즐기는 경우에는 턴 종료를 누른다고 별생각 없이 터치하다가 잘 못 선택하는 경우가 생기니 조심해야 합니다. 이번 선술집 보상 카드입니다. 꽝! 로또나 하러 가자.","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/%EC%84%A0%EC%88%A0%EC%A7%91/"},{"name":"hearthstone","slug":"hearthstone","permalink":"http://jacegem.github.io/blog/tags/hearthstone/"},{"name":"drinking","slug":"drinking","permalink":"http://jacegem.github.io/blog/tags/drinking/"},{"name":"game","slug":"game","permalink":"http://jacegem.github.io/blog/tags/game/"}]},{"title":"Unix/Linux Command df & du","slug":"2016/Unix-Linux-Command-df-du","date":"2016-01-07T11:33:54.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/Unix-Linux-Command-df-du/","link":"","permalink":"http://jacegem.github.io/blog/2016/Unix-Linux-Command-df-du/","excerpt":"","text":"디스크용량을 확인하기 위해 df, du 명령어를 사용합니다. df Reports information about space on file systems. 파일 시스템 용량에 관한 정보를 제공합니다. 파일시스템, 블록, 사용가능, %사용, Iused, %Iused, 마운트 위치 정보를 제공합니다. 파일 시스템 GB 블록 사용가능 %사용 Iused %Iused 마운트 위치 /dev/hd4 330.00 0.00 100% 184939 93% / /dev/hd2 20.00 17.53 13% 46301 2% /usr /dev/hd9var 5.00 4.90 2% 4581 1% /var 옵션 df -m : 메가바이트 단위로 정보를 확인합니다. df -g : 기가바이트 단위로 정보를 확인합니다. du Summarizes disk usage. 디스크 사용량을 요약해서 보여줍니다. 사용량 파일 368 ./log/log.log.2015-02-01.log 296 ./log/log.log.2015-02-02.log 8 ./log/log.log.2015-02-03.log ... 10608 . 옵션 du -a : 파일단위로 디스크 사용량을 보여줍니다. du -s : 현재 디렉토리의 총 디스크 사용량을 보여줍니다.","categories":[],"tags":[{"name":"unix","slug":"unix","permalink":"http://jacegem.github.io/blog/tags/unix/"},{"name":"linux","slug":"linux","permalink":"http://jacegem.github.io/blog/tags/linux/"},{"name":"command","slug":"command","permalink":"http://jacegem.github.io/blog/tags/command/"},{"name":"df","slug":"df","permalink":"http://jacegem.github.io/blog/tags/df/"},{"name":"du","slug":"du","permalink":"http://jacegem.github.io/blog/tags/du/"}]},{"title":"Writing Post with Hexo","slug":"2016/Writing-Post-with-Hexo","date":"2016-01-07T05:10:24.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/Writing-Post-with-Hexo/","link":"","permalink":"http://jacegem.github.io/blog/2016/Writing-Post-with-Hexo/","excerpt":"","text":"[hexo] Writing Post with Hexo HEXO로 포스팅하기 메모하기 ResophNotes를 사용해서 초안을 작성합니다. markdown 문법을 지원하기 때문에 어느 정도는 확인을 할 수 있습니다.(hexo 마크다운 문법과 정확히 일치하지는 않습니다.) 또는 메모장과 같은 다른 텍스트 편집기를 이용해서 작성하면 됩니다. 초안 생성 hexo 에서 초안 문서를 생성합니다. hexo new draft “title” 해당 문서 draft.md 에서 지정해 놓은 형식으로 _draft 폴더에 생성됩니다. 새로 생성되는 파일의 레이아웃에 대한 정의는 scaffold폴더에 있습니다. scaffold/draft.md source/_draft/title.md 새로 생성된 문서로 텍스트 편집기에서 작성한 내용을 복사합니다. 로컬에서 확인 파일을 생성하고 로컬 서버를 실행하여 초안 문서를 확인합니다 hexo generate hexo serve --draft 옵션인 --draft를 꼭 붙여서 실행해야 draft 문서도 확인할 수 있습니다. 브라우저를 통하여 localhost:4000으로 접속합니다. 화면을 살펴보면서 내용을 수정합니다. localhost:4000 root 경로를 /blog로 설정한 경우에는 localhost:4000으로 접속하면 /blog로 접속됩니다. publish 명령어를 통하여 발행합니다. hexo publish “title” 발행을 하면 _draft 폴더에 있는 파일은 post 폴더로 이동됩니다. source/_post/title.md 다시 한번 내용을 수정하면서 문법을 확인합니다. 문법 확인으로 한국어 맞춤법/문법 검사기를 사용합니다. deploy 배포할 파일을 생성한 다음 배포명령어를 실행하여 포스팅합니다. hexo generate hexo deploy 배포한 이후, 잠깐 시간이 지난 뒤에 수정된 내용이 적용된 것을 확인할 수 있습니다. clean 생성한 배포 파일을 삭제할 경우에는 clean 옵션을 사용합니다. hexo clean 단축 명령어 hexo new draft “title” hexo n draft “title” hexo generate hexo g hexo serve --draft hexo s --draft hexo publish “title” hexo p “title” hexo deploy hexo d hexo generate hexo deploy hexo d -g","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"writing","slug":"writing","permalink":"http://jacegem.github.io/blog/tags/writing/"},{"name":"post","slug":"post","permalink":"http://jacegem.github.io/blog/tags/post/"},{"name":"resophnotes","slug":"resophnotes","permalink":"http://jacegem.github.io/blog/tags/resophnotes/"},{"name":"draft","slug":"draft","permalink":"http://jacegem.github.io/blog/tags/draft/"},{"name":"publish","slug":"publish","permalink":"http://jacegem.github.io/blog/tags/publish/"},{"name":"deploy","slug":"deploy","permalink":"http://jacegem.github.io/blog/tags/deploy/"},{"name":"blog","slug":"blog","permalink":"http://jacegem.github.io/blog/tags/blog/"}]},{"title":"[sw] PowerCmd - A Better Command Prompt Replacement Tool","slug":"2016/sw-PowerCmd-A-Better-Command-Prompt-Replacement-Tool","date":"2016-01-07T01:49:13.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/sw-PowerCmd-A-Better-Command-Prompt-Replacement-Tool/","link":"","permalink":"http://jacegem.github.io/blog/2016/sw-PowerCmd-A-Better-Command-Prompt-Replacement-Tool/","excerpt":"","text":"PowerCmd 홈페이지 커맨드 창 사용의 불편한 점 중의 하나는 복사하기 붙여넣기가 지원되지 않는다는 것입니다. 익숙한 ctrl+c, ctrl+v 가 아닌, 다른 방식으로 진행하다 보니 자연스레 작업 효율이 떨어질 수 밖에 없습니다. ^V를 그만 보고 싶습니다. 문제점을 해결하기위한 대안으로 PowerCmd를 사용합니다. 탭 구분으로 여러개의 창을 관리할 수 있습니다. 마지막 사용 지점을 기억합니다. 커맨드창을 시작할 때마다 경로를 이동하는 불편을 없앨수 있습니다. ctrl+c, ctrl+v 로 복사하기, 붙여넣기를 할 수 있습니다. PowerCmd 한글화 PowerCmd 다운로드","categories":[],"tags":[{"name":"command","slug":"command","permalink":"http://jacegem.github.io/blog/tags/command/"},{"name":"sw","slug":"sw","permalink":"http://jacegem.github.io/blog/tags/sw/"},{"name":"powercmd","slug":"powercmd","permalink":"http://jacegem.github.io/blog/tags/powercmd/"},{"name":"prompt","slug":"prompt","permalink":"http://jacegem.github.io/blog/tags/prompt/"},{"name":"tool","slug":"tool","permalink":"http://jacegem.github.io/blog/tags/tool/"}]},{"title":"[highlight.js] Syntax Highlight - highlight.js","slug":"2016/highlight-js","date":"2016-01-07T01:32:37.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/highlight-js/","link":"","permalink":"http://jacegem.github.io/blog/2016/highlight-js/","excerpt":"","text":"Syntax Highlight - highlight.js 마크다운 편집기로 문서를 작성하고 html코드를 복사하여 포스팅 하고 있습니다. 블로그에서 소스코드에 대해 syntax highlight를 적용하기 위해 hightlight.js 를 적용하였습니다. 1234567class Hello&#123; public static void main(String args[]) &#123; System.out.println(&quot;안녕하세요?&quot;); &#125;&#125; 위의 자바 소스를 생성하면 아래와 같은 html 코드가 생성됩니다. 12345678&lt;pre&gt;&lt;code class=&quot;java&quot;&gt;class Hello &#123; public static void main(String args[]) &#123; System.out.println(&amp;quot;안녕하세요?&amp;quot;); &#125;&#125;&lt;/code&gt;&lt;/pre&gt; 이 코드를 가지고 highlight 할 수 있도록 설정합니다. highlight.js https://highlightjs.org/ 에 접속합니다. 해당 사이트에 접속한 후에 Get version 버튼을 클릭합니다. 두개의 CDN 주소를 확인할 수 있습니다. 둘 중 하나만 복사해서 적용합니다. cdnjs 12&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/default.min.css&quot;&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js&quot;&gt;&lt;/script&gt; jsdelivr 12&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/highlight.js/9.0.0/styles/default.min.css&quot;&gt;&lt;script src=&quot;//cdn.jsdelivr.net/highlight.js/9.0.0/highlight.min.js&quot;&gt;&lt;/script&gt; 티스토리 관리에서, 꾸미기 &gt; HTML/CSS 편집 메뉴를 선택합니다. 위에서 복사한 CDN 주소와 함께 &lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 코드를 &lt;body&gt; 태그 윗 부분에 추가합니다. 123&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/styles/monokai-sublime.min.css&quot;&gt;&lt;script src=&quot;//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.0.0/highlight.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;hljs.initHighlightingOnLoad();&lt;/script&gt; 위의 코드를 복사해서 붙여 넣습니다. 해당 소스를 붙여넣은 다음에 화면을 캡쳐하였습니다. 사용할 수 있는 스타일은 이곳에서 확인 가능합니다. 좌측 하단에 보이는 Language, style 을 클릭하면 언어및, 스타일이 변경되면서 모습을 확인할 수 있습니다. 각각 스타일 및 언어에 대해서 어떠한 형태로 나오는지는 메인화면에서 확인할 수 있습니다. 또는 데모사이트에서 확인 가능합니다. 141 languages and 65 styles (live demo) automatic language detection multi-language code highlighting available for node.js works with any markup compatible with any js framework 스타일 목록 https://github.com/isagalaev/highlight.js/tree/master/src/styles agate.min.css androidstudio.min.css arta.min.css ascetic.min.css atelier-cave-dark.min.css atelier-cave-light.min.css atelier-dune-dark.min.css atelier-dune-light.min.css atelier-estuary-dark.min.css atelier-estuary-light.min.css atelier-forest-dark.min.css atelier-forest-light.min.css atelier-heath-dark.min.css atelier-heath-light.min.css atelier-lakeside-dark.min.css atelier-lakeside-light.min.css atelier-plateau-dark.min.css atelier-plateau-light.min.css atelier-savanna-dark.min.css atelier-savanna-light.min.css atelier-seaside-dark.min.css atelier-seaside-light.min.css atelier-sulphurpool-dark.min.css atelier-sulphurpool-light.min.css brown-paper.min.css brown-papersq.png codepen-embed.min.css color-brewer.min.css dark.min.css darkula.min.css default.min.css docco.min.css far.min.css foundation.min.css github-gist.min.css github.min.css googlecode.min.css grayscale.min.css hopscotch.min.css hybrid.min.css idea.min.css ir-black.min.css kimbie.dark.min.css kimbie.light.min.css magula.min.css mono-blue.min.css monokai-sublime.min.css monokai.min.css obsidian.min.css paraiso-dark.min.css paraiso-light.min.css pojoaque.min.css pojoaque.jpg railscasts.min.css rainbow.min.css school-book.min.css school-book.png solarized-dark.min.css solarized-light.min.css sunburst.min.css tomorrow-night-blue.min.css tomorrow-night-bright.min.css tomorrow-night-eighties.min.css tomorrow-night.min.css tomorrow.min.css vs.min.css xcode.min.css zenburn.min.css CSS classes reference http://highlightjs.readthedocs.org/en/latest/css-classes-reference.html 참고 http://jsonobject.tistory.com/174 http://gseok.tistory.com/entry/TistoryTip-티스토리에서-code-highlighter-사용하기 http://prismjs.com/","categories":[],"tags":[{"name":"highlight","slug":"highlight","permalink":"http://jacegem.github.io/blog/tags/highlight/"},{"name":"syntax","slug":"syntax","permalink":"http://jacegem.github.io/blog/tags/syntax/"},{"name":"js","slug":"js","permalink":"http://jacegem.github.io/blog/tags/js/"}]},{"title":"[oracle] Undo tablespace","slug":"2016/oracle-Undo-tablespace","date":"2016-01-06T21:13:36.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/oracle-Undo-tablespace/","link":"","permalink":"http://jacegem.github.io/blog/2016/oracle-Undo-tablespace/","excerpt":"","text":"[오라클] Undo tablespace Undo tablespace는 사용자가 rollback 을 하는 경우에 사용하기 위한 데이터를 저장하는 곳입니다. Undo 파라미터 확인 show parameter undo; 새로운 undo tablespace 생성 CREATE UNDO TABLESPACE UNDOTBS2 DATAFILE '/home/oradata/undotbs2.dbf' SIZE 10M AUTOEXTEND ON MAXSIZE 100m; 자동 확장 설정 : AUTOEXTEND 확장 단위 설정 : ON NEXT 5M 무한 확장 설정 : MAXSIZE UNLIMITED AUTOEXTEND ON NEXT 5M MAXSIZE UNLIMITED 생성한 undo tablespace 확인 SELECT tablespace_name, contents, extent_management FROM dba_tablespaces WHERE contents = 'UNDO'; undo tablespace에 설정된 rollback segment 확인 SELECT segment_name, tablespace_name, status FROM dba_rollback_segs ORDER BY 2; undo tablespace 이름 변경 ALTER SYSTEM SET UNDO_TABLESPACE = UNDOTBS2; 기존 undo tablespace 삭제 DROP TABLESPACE UNDOTBS1; 참고 http://thankyeon.tistory.com/31 https://community.oracle.com/thread/454837?start=0&amp;tstart=0","categories":[],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://jacegem.github.io/blog/tags/oracle/"},{"name":"undo","slug":"undo","permalink":"http://jacegem.github.io/blog/tags/undo/"},{"name":"tablespace","slug":"tablespace","permalink":"http://jacegem.github.io/blog/tags/tablespace/"}]},{"title":"[scala] 섭씨 화씨 변환기","slug":"2016/scala-섭씨-화씨-변환기","date":"2016-01-06T07:07:17.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/scala-섭씨-화씨-변환기/","link":"","permalink":"http://jacegem.github.io/blog/2016/scala-%EC%84%AD%EC%94%A8-%ED%99%94%EC%94%A8-%EB%B3%80%ED%99%98%EA%B8%B0/","excerpt":"","text":"섭씨, 화씨 변환 공식은 아래와 같습니다. 섭씨 = (화씨 - 32) * 5 / 9 화씨 = 섭씨 * 9 / 5 + 32 변환을 해보면 아래와 같습니다. 왼쪽에 값을 입력한 후에 변환 버튼을 클릭하면 변환된 값이 오른쪽에 표시됩니다. 섭씨 → 화씨: 화씨 → 섭씨: function trans(){ var c = $('#c').val(); var f = $('#f').val(); var cf = c * 9 / 5 + 32 ; var fc = (f - 32) * 5 / 9; $('#cf').val(cf); $('#fc').val(fc); } scala object 파일을 생성합니다. import 구문을 추가합니다 12import swing._import event._ MainFrame 을 생성합니다. 12345object TempConverter extends SimpleSwingApplication&#123; def top = new MainFrame&#123; ... &#125;&#125; 소스 12345678910111213141516171819202122232425262728293031package week1import swing._import event._object TempConverter extends SimpleSwingApplication&#123; def top = new MainFrame&#123; title = &quot;섭씨 / 화씨 변환기&quot; object celsius extends TextField &#123; columns = 5&#125; object fahrenheit extends TextField &#123; columns = 5&#125; contents = new FlowPanel &#123; contents += celsius contents += new Label (&quot; Celsius = &quot;) contents += fahrenheit contents += new Label (&quot; Fahrenheit&quot;) border = Swing.EmptyBorder(15, 10, 10, 10) &#125; listenTo(celsius, fahrenheit) reactions += &#123; case EditDone(`fahrenheit`) =&gt; val f = fahrenheit.text.toInt val c = (f - 32) * 5 / 9 celsius.text = c.toString case EditDone(`celsius`) =&gt; val c = celsius.text.toInt val f = c * 9 / 5 + 32 fahrenheit.text = f.toString &#125; &#125;&#125; gist 실행화면","categories":[],"tags":[{"name":"scala","slug":"scala","permalink":"http://jacegem.github.io/blog/tags/scala/"},{"name":"섭씨","slug":"섭씨","permalink":"http://jacegem.github.io/blog/tags/%EC%84%AD%EC%94%A8/"},{"name":"화씨","slug":"화씨","permalink":"http://jacegem.github.io/blog/tags/%ED%99%94%EC%94%A8/"},{"name":"변환기","slug":"변환기","permalink":"http://jacegem.github.io/blog/tags/%EB%B3%80%ED%99%98%EA%B8%B0/"},{"name":"공식","slug":"공식","permalink":"http://jacegem.github.io/blog/tags/%EA%B3%B5%EC%8B%9D/"},{"name":"온도","slug":"온도","permalink":"http://jacegem.github.io/blog/tags/%EC%98%A8%EB%8F%84/"}]},{"title":"[하스스톤] 선술집 - 이제 누가 우두머리지","slug":"2016/하스스톤-선술집-이제-누가-우두머리지","date":"2016-01-05T12:20:16.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/하스스톤-선술집-이제-누가-우두머리지/","link":"","permalink":"http://jacegem.github.io/blog/2016/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4-%EC%84%A0%EC%88%A0%EC%A7%91-%EC%9D%B4%EC%A0%9C-%EB%88%84%EA%B0%80-%EC%9A%B0%EB%91%90%EB%A8%B8%EB%A6%AC%EC%A7%80/","excerpt":"","text":"[하스스톤] 선술집 - 이제 누가 우두머리지? [toc] 영웅의 능력을 사용하면 새로운 능력으로 변경됩니다. 마나만 있다면 계속해서 영웅 능력을 사용할 수 있습니다. 변경되는 영웅능력은 ** 랜덤** 이므로 운에 맡겨야 합니다. 이제 누가 우두머리지? 던전의 우두머리들이 당신을 돕겠다는군요! 덱을 만들어 게임을 시작하면 무작위 우두머리의 영웅 능력을 쓸 수 있습니다. 영웅 능력은 사용할 때마다 새로운 영웅 능력으로 바뀝니다. 영웅 능력들 척살 적 하수인의 생명력을 1로 바꿉니다. 가장 가끔 나오는 영웅 능력입니다. 독구름과 콤보로 사용할 때 최고의 효율을 얻을 수 있습니다. 문을 열어라 1/1 새끼용 3마리를 소환합니다. 하수인 소환과 관련된 카드를 같이 사용할때에 유용합니다. ** 단검 곡예사** 와 콤비로 사용합니다. 가동 무작위 골렘 하나를 가동시킵니다. 영웅 능력도 랜덤인데, 여기서 한번 더 랜덤의 운에 기대야 합니다. 너 박살낸다! 무작위 하수인 하나를 처치합니다. 상대편 하수인이 없으면 이 능력은 발동될 수 없습니다. 다들 모여!! 각 플레이어의 덱에서 하수인을 한씩 뽑아 전장에 놓습니다. 이 능력이 무조건 내 쪽에 유리하지만은 않습니다. 따라서 상황에 맞게 사용해야 합니다. 덱을 구성할 때에도, 코스트가 높은 하수인을 사용하는 것이 이 영웅 능력의 효과를 극대화 할 수 있는 방법입니다. 덱에 하수인 카드가 없다면, 이 능력을 발동되지 않습니다. 주문카드 보단 하수인 카드 위주의 덱 구성을 추천합니다. 착취 카드를 1장 뽑고, 마나 수정을 1개 획득합니다. 마나수정이 홀수인 경우에 해당 영웅 능력이 나오면 좋습니다. 코스트 낭비를 없애줍니다. 마나 수정을 1개 획득한다고 너무 깊게 생각한 나머지, 주문이나 하수인을 쓰면서 먼저 코스트를 0으로 만드는일은 없어야 합니다. 마나 수정이 모두 사라지면 영웅 능력을 사용할 수 없게 됩니다. 거미줄 감싸기 무작위 적 하수인 하나를 상대편의 손으로 돌려보냅니다. 적편에 높은 코스트 하수인 딱 버티고 있을 때 한줄기 단비같은 영웅능력입니다. 해골 하수인 2/1 해골 피조물을 둘 소환합니다. 문을 열어라와 비슷합니다만, 해골 하수인은 공력력이 2이고, 2개를 소환합니다. 마법 폭주 상대편 직업의 주문 카드 1장을 무작위로 내 손에 가져옵니다. 상대편의 영웅 캐릭터의 주문카드를 가져옵니다. 상대방의 영웅 능력과는 상관이 없습니다. 독구름 모든 적 하수인에게 피해를 1 줍니다. 하나라도 죽으면, 독액괴물을 소환합니다. 척살과 딱 콤비 입니다. 척살로 모든 하수인의 체력을 1 로 만들어 버린 다음에, 적 하수인의 수만큼 독액괴물을 소환할 수 있습니다. 2/2 하수인이라 쓸만합니다. 청지기의 권능 3/3 불꽃꼬리 수행사제를 하나 소환합니다. 3/3 하수인이므로, 덱에 포함되어 있는 2 마나 하수인보다 성능이 좋습니다. 야유하는 군중 도발 능력을 가진 1/1 구경꾼을 1명 소환합니다. 쓸만한 카드들 호수의 여인 내 영웅 능력의 비용이 (1)이 됩니다. 이번 선술집에서 필히 들고 가야할 하수인 입니다. 이 하수인이 한턴이라도 살아 남는다면, 전세는 역전하기 힘들어 집니다. 무클라의 용사 격려: 내 다른 하수인들에게 +1/+1 을 부여합니다. 호수의 여인과 최고의 조합입니다. 10마나 턴이라면, 10번의 영웅능력을 사용하고, 모든 하수인에 대해서, 영웅 능력을 사용할 때마다 +1/+1 의 효과를 얻을 수 있습니다. @하스스톤 선술집 - 이제 누가 우두머리지 서리 거인 이번 게임에서 내가 영웅 능력을 사용할 때마다 비용이 (1)씩 감소합니다. 한 턴에도 마나만 충분하다면 여러번의 영웅 능력을 사용할 수 있기 때문에, 서리 거인의 코스트를 빠르게 낮출 수 있습니다. 단검 곡예사 내 하수인이 소한된 후에, 무작위 저거 하나에게 피해를 1 줍니다. 영웅능력 ** 해골 하수인** 과 ** 문을 열어라** 영웅 능력과 조합으로 사용할 수 있습니다.","categories":[],"tags":[{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/%EC%84%A0%EC%88%A0%EC%A7%91/"},{"name":"우두머리","slug":"우두머리","permalink":"http://jacegem.github.io/blog/tags/%EC%9A%B0%EB%91%90%EB%A8%B8%EB%A6%AC/"},{"name":"영웅","slug":"영웅","permalink":"http://jacegem.github.io/blog/tags/%EC%98%81%EC%9B%85/"},{"name":"능력","slug":"능력","permalink":"http://jacegem.github.io/blog/tags/%EB%8A%A5%EB%A0%A5/"}]},{"title":"[scala] Hello World","slug":"2016/scala-hello-world","date":"2016-01-05T12:16:00.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/scala-hello-world/","link":"","permalink":"http://jacegem.github.io/blog/2016/scala-hello-world/","excerpt":"","text":"[scala] Hello World IDE http://scala-ide.org/ 에서 Scala IDE를 다운로드 하여 실행합니다. HelloWorld 12345object HelloWorld &#123; def main(args: Array[String]) &#123; println(&quot;Hello, world!&quot;) &#125;&#125; 코드를 작성하고 실행합니다. IDE에서 HelloWorld 프로젝트를 생성하고, HelloWorld Object 를 생성합니다. 코드를 작성하고 Scala Application으로 실행하면 결과를 확인할 수 있습니다. Hello, world! HelloWorld 오브젝트를 실행하면, 안에 있는 main 함수가 호출되고, 그 안에서 println문이 실행됩니다. Timer 1234567891011object Timer &#123; def oncePerSecond(cb: () =&gt; Unit) &#123; while (true) &#123; cb(); Thread sleep 1000 &#125; &#125; def timeFlies() &#123; println(&quot;time flies like an arrow...&quot;) &#125; def main(args: Array[String]) &#123; oncePerSecond(timeFlies) &#125;&#125; 코드를 작성하고 실행합니다. 기존 프로젝트에, Timer Object 만 추가하고 작성해도 됩니다. time flies like an arrow... time flies like an arrow... time flies like an arrow... 1초 마다 해당 문구열이 출력되는 것을 확인할 수 있습니다. main 함수에서, timeFiles 함수를 파라미터로 oncePerSecond를 호출합니다. oncePerSecond 함수에서는 파라미터로 전달받은 timeFiles함수를 cb 객체에 담습니다. while문 진입이후에는 cb 함수를 호출하고, 1초간 슬립을 하는 무한 루프를 돌게 됩니다. cb 함수 호출시에, println(&quot;time flies like an arrow...&quot;) 해당 문이 동작하게 되어, 같은 물자열이 계속 출력되게 됩니다. 참고 스칼라 학교 Effective Scala 자바 프로그래머를 위한 스칼라 튜토리얼","categories":[],"tags":[{"name":"hello","slug":"hello","permalink":"http://jacegem.github.io/blog/tags/hello/"},{"name":"scala","slug":"scala","permalink":"http://jacegem.github.io/blog/tags/scala/"},{"name":"world","slug":"world","permalink":"http://jacegem.github.io/blog/tags/world/"}]},{"title":"[hexo] add tags and categories","slug":"2016/hexo-add-tags-and-categories","date":"2016-01-05T11:48:27.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/hexo-add-tags-and-categories/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-add-tags-and-categories/","excerpt":"","text":"태그, 카테고리 추가하기 tag 추가 hexo new &quot;title&quot; 로 문서를 생성하면 기본 틀이 생성됩니다. tag 입력은 한줄로 입력할 때에는 tags: [tag1, tag2] 이와 같이 입력하며 여러 줄로 입력할 때에는 아래와 같습니다. 123tags: - tag1 - tag2 category 추가 category는 순서가 중요합니다. 123categories: - ca1 - ca2 위와 같이 작성하면 카테고리를 지정한 순서대로 하위 카테고리로 설정이 되기 때문에 아래와 같은 구조로 생성 됩니다. ca1 ca2 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"tag","slug":"tag","permalink":"http://jacegem.github.io/blog/tags/tag/"},{"name":"category","slug":"category","permalink":"http://jacegem.github.io/blog/tags/category/"}]},{"title":"[hexo] add adsense to hexo","slug":"2016/hexo-add-adsense-to-hexo","date":"2016-01-05T04:12:26.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/hexo-add-adsense-to-hexo/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-add-adsense-to-hexo/","excerpt":"","text":"[hexo] 애드센스 추가하기 adsense 추가 bootstrap 테마를 기준으로 adsense를 추가해보도록 하겠습니다. 상단에 추가하는 방법 블로그 레이아웃의 전체적인 구조는 layout.ejs 파일을 통해서 확인할 수 있습니다. layout.ejs파일을 수정하여 상에 애드센스를 추가합니다. theme &gt; bootstrap &gt; layout &gt; layout.ejs 1234567891011&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-8 blog-main&quot;&gt; &lt;!-- ad start --&gt; &lt;%- partial(&#x27;_custom_ad/google-adsense&#x27;) %&gt; &lt;!-- ad end --&gt; &lt;%- body %&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-3 col-sm-offset-1 blog-sidebar&quot;&gt; &lt;%- partial(&#x27;_partial/sidebar&#x27;, null, &#123;cache: !config.relative_link&#125;) %&gt; &lt;/div&gt;&lt;/div&gt; 중간에 있는 &lt;%- body %&gt; 이 부분이 본문이 표출되는 레이아웃 입니다. 따라서, &lt;%- body %&gt; 윗 부분에 애드센스를 추가합니다. 123&lt;!-- ad start --&gt;&lt;%- partial(&#x27;_custom_ad/google-adsense&#x27;) %&gt;&lt;!-- ad end --&gt; 위의 코드를 추가하였습니다. 실질적 동작을 위한 코드가 들어있는 파일을 추가합니다. theme &gt; bootstrap &gt; layout &gt; _custom_ad &gt; google-adsense.ejs 해당 파일에 애드센스에서 제공하는 코드를 입력합니다. 각 계정 및 광고 크기마다 다른 코드가 생성됩니다. 123456789101112&lt;div&gt;&lt;script async src=&quot;//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js&quot;&gt;&lt;/script&gt;&lt;!-- 반응형 --&gt;&lt;ins class=&quot;adsbygoogle&quot; style=&quot;display:block&quot; data-ad-client=&quot;ca-pub-[yours]&quot; data-ad-slot=&quot;[yours]&quot; data-ad-format=&quot;auto&quot;&gt;&lt;/ins&gt;&lt;script&gt;(adsbygoogle = window.adsbygoogle || []).push(&#123;&#125;);&lt;/script&gt;&lt;/div&gt; 위의 코드는 반응형으로 생성하였기 때문에, 다른 위치에서도 이 파일을 사용하여 애드센스를 추가합니다. 하단에 추가하는 방법 하단도 상단과 마찬가지로 &lt;%- body %&gt; 부분 밑에 코드를 추가함으로써 삽입이 가능합니다. 이 경우에는 댓글 부분 밑에 추가되기 때문에, 이를 변경하기 위해서 삽입 코드의 위치를 변경합니다. 태그 밑 부분에 출력하기 위해서 tag.ejs 파일을 수정합니다. themes &gt; bootstrap &gt; layout &gt; _partial &gt; post &gt; tag.ejs tag.ejs 파일의 맨 밑에 삽입 코드를 추가합니다. 123&lt;!-- ad start --&gt;&lt;%- partial(&#x27;_custom_ad/google-adsense&#x27;) %&gt;&lt;!-- ad end --&gt; 사이드에 추가하는 방법 사이드에 추가하기 위해서 sidebar.ejs 파일을 수정합니다. sidebar.ejs 파일 맨 맽에 코드를 추가합니다. themes &gt; bootstrap &gt; layout &gt; _partial &gt; sidebar.ejs 123&lt;!-- ad start --&gt;&lt;%- partial(&#x27;_custom_ad/google-adsense&#x27;) %&gt;&lt;!-- ad end --&gt; 반응형 광고 크기를 사용하였기 때문에, 하나의 코드로 여러군데에서 사용하였습니다. 각각 다른 광고 크기를 사용해야 한다면 추가되는 파일을 따로 생성해서 추가하도록 코드를 변경해야 합니다. 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"adsense","slug":"adsense","permalink":"http://jacegem.github.io/blog/tags/adsense/"},{"name":"layout","slug":"layout","permalink":"http://jacegem.github.io/blog/tags/layout/"},{"name":"ejs","slug":"ejs","permalink":"http://jacegem.github.io/blog/tags/ejs/"}]},{"title":"[ahk] Generate haroopad Shortcuts by AHK","slug":"2016/ahk-Generate-haroopad-Shortcuts-by-ahk","date":"2016-01-05T01:11:31.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/ahk-Generate-haroopad-Shortcuts-by-ahk/","link":"","permalink":"http://jacegem.github.io/blog/2016/ahk-Generate-haroopad-Shortcuts-by-ahk/","excerpt":"","text":"오토핫키로 하루패드 단축키 생성하기 뷰 단축키 설명 AHK 변경키 코드 SHIFT-CTRL-1 (에디터:뷰어)모드 F1 F1::Send +^1 SHIFT-CTRL-2 (뷰어:에디터)모드 F2 F2::Send +^2 SHIFT-CTRL-3 에디터 모드 F3 F3::Send +^3 SHIFT-CTRL-4 뷰어 모드 F4 F4::Send +^4 CTRL-F11 전체화면 모드 토글 F11 F11::Send ^{F11} CTRL-ALT-P 프리젠테이션 모드 F12 F12::Send ^!p 사용할 코드는 아래와 같습니다. 123456F1::Send +^1F2::Send +^2F3::Send +^3F4::Send +^4F11::Send ^&#123;F11&#125;F12::Send ^!p AHK를 실행하고, 트레이 아이콘에서, Window Spy를 실행합니다. Active Window Info 정보를 확인합니다. ahk_exe haroopad.exe 를 확용하여 해당 윈도우를 확인합니다. haroopad.ahk 파일명으로 파일을 생성합니다. 전체 코드 1234567891011#ifWinActive ahk_exe haroopad.exeF1::Send +^1F2::Send +^2F3::Send +^3F4::Send +^4F11::Send ^&#123;F11&#125;F12::Send ^!p#ifWinActive 하루패드에서만 단축키를 적용하기 위해서, #ifWindActive를 사용하였습니다. 유의 사항 대문자 P와 소문자 p는 다르므로, 정확히 작성해야 합니다.","categories":[],"tags":[{"name":"ahk","slug":"ahk","permalink":"http://jacegem.github.io/blog/tags/ahk/"},{"name":"autohotkey","slug":"autohotkey","permalink":"http://jacegem.github.io/blog/tags/autohotkey/"},{"name":"haroopad","slug":"haroopad","permalink":"http://jacegem.github.io/blog/tags/haroopad/"},{"name":"shortcut","slug":"shortcut","permalink":"http://jacegem.github.io/blog/tags/shortcut/"}]},{"title":"[hexo] install powerful blog framework hexo","slug":"2016/hexo-install-powerful-blog-framework-hexo","date":"2016-01-04T17:10:45.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/hexo-install-powerful-blog-framework-hexo/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-install-powerful-blog-framework-hexo/","excerpt":"","text":"파워풀 블로그 프레임워크 HEXO 설치하기 node.js 설치 Git Bash를 설치합니다. node js를 설치합니다. 윈도우 방화벽 설정을 허용합니다. 버전을 확인합니다. 12node -vnpm -v hexo 프레임워크를 설치합니다. 123npm install hexo-cli -gnpm install hexo-deployer-git --savehexo -v 실행 결과 123456789101112131415161718192021222324252627282930313233C:\\Temp&gt;npm install hexo-cli -gnpm WARN optional dep failed, continuing fsevents@1.0.6C:\\Users\\[USER]\\AppData\\Roaming\\npm\\hexo -&gt; C:\\Users\\[USER]\\AppData\\Roaming\\npm\\node_modules\\hexo-cli\\bin\\hexohexo-cli@0.2.0 C:\\Users\\[USER]\\AppData\\Roaming\\npm\\node_modules\\hexo-cli├── abbrev@1.0.7├── minimist@1.2.0├── bluebird@3.1.1├── tildify@1.1.2 (os-homedir@1.0.1)├── chalk@1.1.1 (supports-color@2.0.0, ansi-styles@2.1.0, escape-string-regexp@1.0.4, strip-ansi@3.0.0, has-ansi@2.0.0)├── hexo-util@0.5.1 (html-entities@1.2.0, highlight.js@9.0.0, camel-case@1.2.2)└── hexo-fs@0.1.5 (escape-string-regexp@1.0.4, graceful-fs@4.1.2, chokidar@1.4.2)C:\\Temp&gt;npm install hexo-deployer-git --savenpm WARN optional dep failed, continuing fsevents@1.0.6hexo-deployer-git@0.0.4 node_modules\\hexo-deployer-git├── chalk@0.5.1 (ansi-styles@1.1.0, escape-string-regexp@1.0.4, supports-color@0.2.0, strip-ansi@0.3.0, has-ansi@0.1.0)├── moment@2.11.0├── swig@1.4.2 (optimist@0.6.1, uglify-js@2.4.24)├── hexo-fs@0.1.5 (escape-string-regexp@1.0.4, graceful-fs@4.1.2, bluebird@3.1.1, chokidar@1.4.2)└── hexo-util@0.1.7 (ent@2.2.0, bluebird@2.10.2, highlight.js@8.9.1)C:\\Temp&gt;hexo -vhexo-cli: 0.2.0os: Windows_NT 6.1.7601 win32 x64http_parser: 2.5.0node: 4.1.0v8: 4.5.103.33uv: 1.7.4zlib: 1.2.8ares: 1.10.1-DEVmodules: 46openssl: 1.0.2d hexo 설치 블로그로 사용할 디렉토리를 생성합니다. 12mkdir blogcd blog 블로그를 초기화 합니다. 123hexo initnpm installhexo serve http://localhost:4000/ 로 접속하면 블로그 화면을 볼 수 있습니다. 참고 Setting up Hexo on Windows Github Pages와 Hexo github 생성 저장소를 생성합니다. 저장소 이름을 설정합니다. 해당 저장소에서 Settings &gt; GitHub Pages &gt; Automatic page generator &gt; Launch automatic page generator 를 클릭하여 적당한 템플릿을 선택하여 생성합니다. ssh-keygen을 실행하여 ssh 키를 생성합니다. 해당 실행파일은 C:\\Program Files\\Git\\usr\\bin 에 있습니다. 12345678C:\\Program Files\\Git\\usr\\bin&gt;ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/c/Users/[USER]/.ssh/id_rsa):Created directory &#x27;/c/Users/[USER]/.ssh&#x27;.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/[USER]/.ssh/id_rsa.Your public key has been saved in /c/Users/[USER]/.ssh/id_rsa.pub. .ssh/id_rsa 키를 저장하고 싶은 디렉토리를 입력합니다. 이어서 암호를 두 번 입력합니다. 이때 암호를 비워두면 키를 사용할 때 암호를 묻지 않습니다. id_rsa.pub 파일의 내용을 복사해서, github에 등록합니다. 저장소에서 Settings &gt; Deploy keys &gt; Deploy keys &gt; Add deploy key 를 클릭합니다. 복사한 내용을 등록하고 Allow write access를 선택한 다음 Add key를 눌러서 키를 등록합니다. 참고 https://help.github.com/articles/generating-ssh-keys/ https://git-scm.com/book/ko/v2/Git-서버-SSH-공개키-만들기 configuration 블로그를 위해 생성한 디렉토리의 _config.yml 파일을 수정합니다. URL을 변경합니다. 12url: https:/[YOUR_ID].github.iom/blogroot: /blog/ 뒤에 blog가 붙은 이유는, 해당 저장소의 이름을 blog로 지정하였기 때문입니다. Deployment 를 수정합니다. 1234deploy: type: git repository: git@github.com:[YOUR_ID]/blog.git branch: gh-pages 포스팅 ssh 에이전트를 실행합니다. 12ssh-agent -sclip &lt; id_rsa.pub 블로그를 위한 정적 파일을 생성하고 배포합니다. 123hexo cleanhexo generatehexo deploy 12FATAL Error: Host key verification failed.fatal: Could not read from remote repository. 위와 같은 에러가 발생하면 ssh -T git@github.com 을 실행하여 확인합니다. 123456C:\\Program Files\\Git\\usr\\bin&gt;ssh -T git@github.comThe authenticity of host &#x27;github.com ([IP])&#x27; can&#x27;t be established.RSA key fingerprint is SHA256:[fingerprint].Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &#x27;github.com,[IP]&#x27; (RSA) to the list of known hosts.Hi [YOUR_ID]/blog! You&#x27;ve successfully authenticated, but GitHub does not provide shell access. 참고 https://help.github.com/articles/generating-ssh-keys/ http://blog.star-flare.com/2014/11/23/hexo-setting-google-adsense/ https://github.com/hexojs/hexo/issues/1495 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"blog","slug":"blog","permalink":"http://jacegem.github.io/blog/tags/blog/"},{"name":"framework","slug":"framework","permalink":"http://jacegem.github.io/blog/tags/framework/"},{"name":"install","slug":"install","permalink":"http://jacegem.github.io/blog/tags/install/"},{"name":"nodejs","slug":"nodejs","permalink":"http://jacegem.github.io/blog/tags/nodejs/"}]},{"title":"[hexo] change theme","slug":"2016/hexo-change-theme","date":"2016-01-04T13:37:58.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/hexo-change-theme/","link":"","permalink":"http://jacegem.github.io/blog/2016/hexo-change-theme/","excerpt":"","text":"Hexo 테마 변경 theme 변경 여기에서 테마를 선택한 다음에 다운로드 받습니다. hexo blog 설치 경로 밑에 themes 폴더가 있고, 그 밑에 해당 파일을 복사합니다. (압축 파일이면 풀어 놓습니다.) 해당 폴더에는 기본 테마인 landscape가 있습니다. 복사해 넣은 테마로 적용하기 위해서 _config.yml를 수정합니다. 12#theme: landscapetheme: bootstrap 기존의 landscape 는 주석처리 하고, bootstrap을 추가합니다. 관련글 install-powerful-blog-framework-hexo hexo-change-theme hexo-add-adsense-to-hexo hexo-add-tags-and-categories","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"theme","slug":"theme","permalink":"http://jacegem.github.io/blog/tags/theme/"}]},{"title":"책.C++ Network Programming Vol.1","slug":"2016/C++-Network-Programming-Vol.1","date":"2015-02-05T01:11:31.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/C++-Network-Programming-Vol.1/","link":"","permalink":"http://jacegem.github.io/blog/2016/C++-Network-Programming-Vol.1/","excerpt":"","text":"[TOC] 책. C++ Network Programming Vol.1 운영체제 API 를 직접적으로 사용하여 프로그래밍 하는 것은 다음과 같은 문제점을 야기할 수 있습니다. 오류를 만들기 쉽습니다. 부적절한 디자인 기술 적용을 유발할 수 있습니다. 예제로 보는 Socket API의 문제점 ##ACE 소켓 Wrapper Facade 클래스 ACE Socket Wrapper Facades 구조 ACE Socket wrapper facade class는 다음과 같은 기능들을 제공한다. ACE_SOCK_* : 인터넷 영역 소켓 API함수들을 캡슐화 시킨 클래스 ACE_L_SOCK_* : Unix 영역(Local) 소켓 API함수들을 캡슐화 시킨 클래스 ACE Socket Wrapper Facades의 규칙 Socket API에서 능동적으로 연결하기 위한 connect()함수와 능동적으로 연결하기 위해서 accept()함수를, 마지막으로 통신을 위해서 read(), write()함수를 사용하는 것과 마찬가지로, active connection role 과 passive connection role, communication role을 가지고 있다. 능동적 접속 규칙active connection role(ACE_SOCK_Connector)은 원격지로 연결을 초기화하는 규칙을 가진다. 수동적 접속 규칙passive connection role(ACE_SOCK_Acceptor)은 원격지의 연결을 받아들이는 규칙을 가진다. 통신 규칙communication role(ACE_SOCK_Stream)은 연결이 된후 어플리케이션관 데이터를 교환하기 위한 규칙을 가진다. ACE 프로그래밍 가이드라인에 대한 문서는 $ACE_ROOT/docs/ACE-guidelines.html 을 참조. 특성값(Trait)은 템플릿 클래스의 행동을 설정하기 위하여 한 무리의 특징들을 정의하고 결합하기 위해 사용될 수 있는 C++ 일반적(generic) 프로그래밍 용어입니다. +-----------------+ +----------------+ | ACE_SOCK_Stream | | ACE_INET_Addr | +-----------------+ +----------------+ ^ ^ | | +-----------------\\ +----------------\\ | PEER_STREAM | | PEER_ADDR | +-----------------+ +----------------+ | | +---------------------------------------------------------------------+ | ACE_SOCK_Connector | +---------------------------------------------------------------------+ +---------------------------------------------------------------------+ | + connect (stream : ACE_SOCK_Stream&amp;, remote_addr : ACE_Addr &amp;, | | timeout : ACE_Time_Value *= 0) : int | | + complete (stream : ACE_SOCK_Stream&amp;, remote_addr : ACE_Addr *=0, | | timeout : ACE_Time_Value *= 0) : int | +---------------------------------------------------------------------+ PEER_ADDR : 이 특성값은 ACE 소켓 wrapper facade 클래스와 관련된 ACE_INET_Addr 주소 지정 클래스를 정의 PEER_STREAM : ACE_SOCK_Acceptor 와 ACE_SOCK_Connector 팩토리 클래스와 관련된 ACE_SOCK_Stream 데이터 전송 클래스를 정의 선형화(Linearization) : 배열, 연결 리스트, 그래프와 같은 고급 타입의 데이터와 raw 상태의 메모리 버퍼간의 변환을 다룹니다. 마샬링/역마샬링(Marshaling/demarshaling) : 상이한 컴파일러간 정렬 규칙 및 다른 바이트 순서 규칙을 가진 하드웨어 명령들의 환경 안에서 정확하게 동작하도록 합니다. 용어 용어 뜻 Accidental Complexity 우발적 복합성 inherent complexity 고유한 복잡성 ACE ADAPTIVE Communication Environment SAP service access point TLI Transport Layer Interface 참고 http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/C++/ACE/Documents/tutorialv1","categories":[],"tags":[{"name":"cpp","slug":"cpp","permalink":"http://jacegem.github.io/blog/tags/cpp/"},{"name":"c++","slug":"c","permalink":"http://jacegem.github.io/blog/tags/c/"},{"name":"network","slug":"network","permalink":"http://jacegem.github.io/blog/tags/network/"},{"name":"programming","slug":"programming","permalink":"http://jacegem.github.io/blog/tags/programming/"}]},{"title":"[md] markdown haroopad","slug":"2016/markdown-haroopad","date":"2014-06-08T01:11:31.000Z","updated":"2023-10-24T11:29:12.989Z","comments":true,"path":"2016/markdown-haroopad/","link":"","permalink":"http://jacegem.github.io/blog/2016/markdown-haroopad/","excerpt":"","text":"마크다운은 하루패드로 정착할 것 같습니다. 몇 가지 마크다운 프로그램들을 테스트 해보면서 안되는 구문들이 많았습니다. 취소선, 밑줄, 표 이 세가지가 기본적으로 잘 안되는 것들이었습니다. 하루패드에서는 모두 지원하면서 취소선, 밑줄, 표, 그리고 목차, 수식, 코드 까지 지원하더군요 목차 [TOC] 수식 Jα(x)=∑m=0∞(−1)mm! Γ(m+α+1)(x2)2m+αJ_\\alpha(x) = \\sum\\limits_{m=0}^\\infty \\frac{(-1)^m}{m! \\, \\Gamma(m + \\alpha + 1)}{\\left({\\frac{x}{2}}\\right)}^{2 m + \\alpha} Jα​(x)=m=0∑∞​m!Γ(m+α+1)(−1)m​(2x​)2m+α 표 | name | age | gender | money | |------------- | rhio | 384 | robot | $3,000 | | haroo | .3 | bird | $430 | | jedi | ? | undefined | $$x2x^2x2$$ | 코드 1234#include &lt;iostream&gt;int main(char *argv[]) &#123; return -2e3 + 12l; 아주 만족하면서, 사용법을 익히는 중입니다. 기회가 된다면 소스로 보고싶은 프로그램입니다. 123int main()&#123;&#125; Jα(x)=∑m=0∞(−1)mm! Γ(m+α+1)(x2)2m+αJ_\\alpha(x) = \\sum\\limits_{m=0}^\\infty \\frac{(-1)^m}{m! \\, \\Gamma(m + \\alpha + 1)}{\\left({\\frac{x}{2}}\\right)}^{2 m + \\alpha} Jα​(x)=m=0∑∞​m!Γ(m+α+1)(−1)m​(2x​)2m+α = = = a b c 자동완성 해제 asdf 1234#include &lt;iostream&gt;int main(char *argv[]) &#123; return -2e3 + 12l; @caption [TOC] 목차 두번째 목차 #haroo pad 취소선 x2(22)\\frac{x^2}{\\sqrt(2^2)} (​22)x2​ i18next Copyright © 2011 Jan Mühlemann (MIT) 123function syntax(a, b) &#123; return a + b;&#125; | name | age | gender | money | |------------- | rhio | 384 | robot | $3,000 | | haroo | .3 | bird | $430 | | jedi | ? | undefined | $$x2x^2x2$$ | $x^2$ x2x^2 x2 @Alt Text underline ul","categories":[],"tags":[{"name":"haroopad","slug":"haroopad","permalink":"http://jacegem.github.io/blog/tags/haroopad/"},{"name":"md","slug":"md","permalink":"http://jacegem.github.io/blog/tags/md/"},{"name":"markdown","slug":"markdown","permalink":"http://jacegem.github.io/blog/tags/markdown/"}]},{"title":"하루패드 사용팁","slug":"2016/하루패드 사용팁","date":"2014-06-05T01:11:31.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/하루패드 사용팁/","link":"","permalink":"http://jacegem.github.io/blog/2016/%ED%95%98%EB%A3%A8%ED%8C%A8%EB%93%9C%20%EC%82%AC%EC%9A%A9%ED%8C%81/","excerpt":"","text":"[toc] 하루패드 도움말 패널 보기 화면 좌측 하단의 버튼을 누르면 도움말이 왼쪽에 펼쳐집니다. 또는 우측 하단 버튼에서, 도움말을 선택해서 볼 수도 있습니다. 수학 표현식 사용하기 파일 &gt; 환경설정 수학표현식을 체크합니다. 수학표현식은 TeX 문법을 참고하면됩니다. x˙=σ(y−x)y˙=ρx−y−xzz˙=−βz+xy\\begin{aligned} \\dot{x} = \\sigma(y-x) \\\\ \\dot{y} = \\rho x - y - xz \\\\ \\dot{z} = -\\beta z + xy \\end{aligned} x˙=σ(y−x)y˙​=ρx−y−xzz˙=−βz+xy​ sin⁡x+ln⁡y+sgn⁡z24or24\\sin x + \\ln y +\\operatorname{sgn} z \\\\ \\frac{2}{4} or {2 \\over 4} sinx+lny+sgnz42​or42​ $$ 와 $$ 사이에 수학표현식을 적으면 되는데, 여러개의 수학표현식을 쓰면 옆으로 붙어서 나오게 됩니다. 여러개의 수학표현식을 한번에 적을 때에는 하나의 수학표현식이 끝난 후에 \\\\ 를 붙여서 구분 표시를 해주어야 합니다. $$ \\sin x + \\ln y +\\operatorname{sgn} z \\\\ \\frac{2}{4} or {2 \\over 4} $$ 잘못적은 정보가 있다면 알려주시기 바랍니다.~","categories":[],"tags":[{"name":"haroopad","slug":"haroopad","permalink":"http://jacegem.github.io/blog/tags/haroopad/"},{"name":"md","slug":"md","permalink":"http://jacegem.github.io/blog/tags/md/"},{"name":"markdown","slug":"markdown","permalink":"http://jacegem.github.io/blog/tags/markdown/"}]},{"title":"[wiki] 도쿠 위치 설치하기","slug":"2016/도쿠위키-설치하기","date":"2014-02-05T01:11:31.000Z","updated":"2023-10-24T11:29:12.993Z","comments":true,"path":"2016/도쿠위키-설치하기/","link":"","permalink":"http://jacegem.github.io/blog/2016/%EB%8F%84%EC%BF%A0%EC%9C%84%ED%82%A4-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/","excerpt":"","text":"도쿠 위치 설치하기 필요한 파일 dokuwiki 홈페이지에서 파일을 다운로드한다. (다운로드 페이지) 용량은 2.8M정도 입니다. XAMPP XAMPP 를 다운로드 합니다. XAMPP 를 설치합니다. xampp-win32-1.8.3-2-VC11-installer.exe 실행 dokuwiki 파일을 압축을 푼 다음에 설치한 XAMPP/htdocs 경로에 복사합니다. E:\\xampp\\htdocs\\wiki 웹 브라우저에서 localhost/wiki/install.php 로 접속 복사한 경로에 맞게 수정해서 설치 페이지로 접속합니다. 플러그인 설치 사용자 신규가입을 위해서 swiftmail 플러그인을 설치합니다. https://www.dokuwiki.org/plugin:swiftmail 에 접속해서 다운로드 합니다. 다운로드한 파일을 압축을 풀어서 플러그인 폴더에 복사합니다. E:\\xampp\\htdocs\\wiki\\lib\\plugins\\swiftmail 도쿠위키 관리 페이지에서, SMTP 메일 설정을 하면됩니다. 관리 &gt; 환경설정 &gt; 플러그인설정 &gt; Swiftmail 에서 설정을 합니다. Gmail 을 사용하였습니다. SMTP: smtp.gmail.com PORT: 465 암호화: TLS USER: 사용하는 이메일 PASS: 이메일 암호 오류들 Windows XP 에서 XAMPP 을 설치할 때에 에러 발생 XP에 설치할 경우에는 php 5.4 이하 버전으로 설치해야만 한다. 참고 http://z3moon.com/wiki/설치 https://www.oss.kr/41671 http://blog.naver.com/PostView.nhn?blogId=gdlab&amp;logNo=150003033037","categories":[{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Wiki","slug":"Application/Wiki","permalink":"http://jacegem.github.io/blog/categories/Application/Wiki/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"http://jacegem.github.io/blog/tags/wiki/"},{"name":"dokuwiki","slug":"dokuwiki","permalink":"http://jacegem.github.io/blog/tags/dokuwiki/"}]}],"categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://jacegem.github.io/blog/categories/Flutter/"},{"name":"Image","slug":"Flutter/Image","permalink":"http://jacegem.github.io/blog/categories/Flutter/Image/"},{"name":"Blog","slug":"Blog","permalink":"http://jacegem.github.io/blog/categories/Blog/"},{"name":"Book","slug":"Blog/Book","permalink":"http://jacegem.github.io/blog/categories/Blog/Book/"},{"name":"Seminar","slug":"Blog/Seminar","permalink":"http://jacegem.github.io/blog/categories/Blog/Seminar/"},{"name":"Programming","slug":"Programming","permalink":"http://jacegem.github.io/blog/categories/Programming/"},{"name":"General","slug":"Programming/General","permalink":"http://jacegem.github.io/blog/categories/Programming/General/"},{"name":"Conference","slug":"Conference","permalink":"http://jacegem.github.io/blog/categories/Conference/"},{"name":"AWS","slug":"Conference/AWS","permalink":"http://jacegem.github.io/blog/categories/Conference/AWS/"},{"name":"Application","slug":"Application","permalink":"http://jacegem.github.io/blog/categories/Application/"},{"name":"Game","slug":"Application/Game","permalink":"http://jacegem.github.io/blog/categories/Application/Game/"},{"name":"Javascript","slug":"Programming/Javascript","permalink":"http://jacegem.github.io/blog/categories/Programming/Javascript/"},{"name":"Spring","slug":"Programming/Spring","permalink":"http://jacegem.github.io/blog/categories/Programming/Spring/"},{"name":"Wiki","slug":"Application/Wiki","permalink":"http://jacegem.github.io/blog/categories/Application/Wiki/"},{"name":"Python","slug":"Programming/Python","permalink":"http://jacegem.github.io/blog/categories/Programming/Python/"},{"name":"Product","slug":"Product","permalink":"http://jacegem.github.io/blog/categories/Product/"},{"name":"Wearable","slug":"Product/Wearable","permalink":"http://jacegem.github.io/blog/categories/Product/Wearable/"},{"name":"Web","slug":"Application/Web","permalink":"http://jacegem.github.io/blog/categories/Application/Web/"},{"name":"Web","slug":"Programming/Web","permalink":"http://jacegem.github.io/blog/categories/Programming/Web/"},{"name":"IDE","slug":"Application/IDE","permalink":"http://jacegem.github.io/blog/categories/Application/IDE/"},{"name":"Download","slug":"Application/Download","permalink":"http://jacegem.github.io/blog/categories/Application/Download/"},{"name":"R","slug":"Programming/R","permalink":"http://jacegem.github.io/blog/categories/Programming/R/"},{"name":"VM","slug":"Application/VM","permalink":"http://jacegem.github.io/blog/categories/Application/VM/"},{"name":"ETC","slug":"Programming/ETC","permalink":"http://jacegem.github.io/blog/categories/Programming/ETC/"},{"name":"NAS","slug":"Application/NAS","permalink":"http://jacegem.github.io/blog/categories/Application/NAS/"},{"name":"Startup","slug":"Conference/Startup","permalink":"http://jacegem.github.io/blog/categories/Conference/Startup/"},{"name":"Database","slug":"Application/Database","permalink":"http://jacegem.github.io/blog/categories/Application/Database/"},{"name":"SQL","slug":"Programming/SQL","permalink":"http://jacegem.github.io/blog/categories/Programming/SQL/"},{"name":"VPN","slug":"Application/VPN","permalink":"http://jacegem.github.io/blog/categories/Application/VPN/"},{"name":"Cryptocurrency","slug":"Application/Cryptocurrency","permalink":"http://jacegem.github.io/blog/categories/Application/Cryptocurrency/"},{"name":"Microsoft","slug":"Conference/Microsoft","permalink":"http://jacegem.github.io/blog/categories/Conference/Microsoft/"},{"name":"Notebook","slug":"Product/Notebook","permalink":"http://jacegem.github.io/blog/categories/Product/Notebook/"},{"name":"Printer","slug":"Product/Printer","permalink":"http://jacegem.github.io/blog/categories/Product/Printer/"},{"name":"Ebook","slug":"Product/Ebook","permalink":"http://jacegem.github.io/blog/categories/Product/Ebook/"},{"name":"JSP","slug":"Programming/JSP","permalink":"http://jacegem.github.io/blog/categories/Programming/JSP/"},{"name":"ETC","slug":"Conference/ETC","permalink":"http://jacegem.github.io/blog/categories/Conference/ETC/"},{"name":"Protocol","slug":"Programming/Protocol","permalink":"http://jacegem.github.io/blog/categories/Programming/Protocol/"},{"name":"HTML","slug":"Programming/HTML","permalink":"http://jacegem.github.io/blog/categories/Programming/HTML/"},{"name":"CSS","slug":"Programming/CSS","permalink":"http://jacegem.github.io/blog/categories/Programming/CSS/"},{"name":"Service","slug":"Service","permalink":"http://jacegem.github.io/blog/categories/Service/"},{"name":"GitBook","slug":"Service/GitBook","permalink":"http://jacegem.github.io/blog/categories/Service/GitBook/"},{"name":"GIS","slug":"Application/GIS","permalink":"http://jacegem.github.io/blog/categories/Application/GIS/"},{"name":"Cloud","slug":"Service/Cloud","permalink":"http://jacegem.github.io/blog/categories/Service/Cloud/"},{"name":"Console","slug":"Application/Console","permalink":"http://jacegem.github.io/blog/categories/Application/Console/"},{"name":"Android","slug":"Programming/Android","permalink":"http://jacegem.github.io/blog/categories/Programming/Android/"},{"name":"Autohotkey","slug":"Programming/Autohotkey","permalink":"http://jacegem.github.io/blog/categories/Programming/Autohotkey/"},{"name":"Unity","slug":"Programming/Unity","permalink":"http://jacegem.github.io/blog/categories/Programming/Unity/"},{"name":"Elm","slug":"Programming/Elm","permalink":"http://jacegem.github.io/blog/categories/Programming/Elm/"},{"name":"Database","slug":"Programming/Database","permalink":"http://jacegem.github.io/blog/categories/Programming/Database/"},{"name":"Earphone","slug":"Product/Earphone","permalink":"http://jacegem.github.io/blog/categories/Product/Earphone/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"http://jacegem.github.io/blog/tags/flutter/"},{"name":"image","slug":"image","permalink":"http://jacegem.github.io/blog/tags/image/"},{"name":"성공하는","slug":"성공하는","permalink":"http://jacegem.github.io/blog/tags/%EC%84%B1%EA%B3%B5%ED%95%98%EB%8A%94/"},{"name":"사람들의","slug":"사람들의","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EB%9E%8C%EB%93%A4%EC%9D%98/"},{"name":"자기","slug":"자기","permalink":"http://jacegem.github.io/blog/tags/%EC%9E%90%EA%B8%B0/"},{"name":"시간","slug":"시간","permalink":"http://jacegem.github.io/blog/tags/%EC%8B%9C%EA%B0%84/"},{"name":"연구","slug":"연구","permalink":"http://jacegem.github.io/blog/tags/%EC%97%B0%EA%B5%AC/"},{"name":"Y세미나","slug":"Y세미나","permalink":"http://jacegem.github.io/blog/tags/Y%EC%84%B8%EB%AF%B8%EB%82%98/"},{"name":"데이터","slug":"데이터","permalink":"http://jacegem.github.io/blog/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0/"},{"name":"경제","slug":"경제","permalink":"http://jacegem.github.io/blog/tags/%EA%B2%BD%EC%A0%9C/"},{"name":"삶","slug":"삶","permalink":"http://jacegem.github.io/blog/tags/%EC%82%B6/"},{"name":"52주","slug":"52주","permalink":"http://jacegem.github.io/blog/tags/52%EC%A3%BC/"},{"name":"기록","slug":"기록","permalink":"http://jacegem.github.io/blog/tags/%EA%B8%B0%EB%A1%9D/"},{"name":"정규표현식","slug":"정규표현식","permalink":"http://jacegem.github.io/blog/tags/%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"},{"name":"문제","slug":"문제","permalink":"http://jacegem.github.io/blog/tags/%EB%AC%B8%EC%A0%9C/"},{"name":"regexone","slug":"regexone","permalink":"http://jacegem.github.io/blog/tags/regexone/"},{"name":"연습","slug":"연습","permalink":"http://jacegem.github.io/blog/tags/%EC%97%B0%EC%8A%B5/"},{"name":"AWS","slug":"AWS","permalink":"http://jacegem.github.io/blog/tags/AWS/"},{"name":"Community","slug":"Community","permalink":"http://jacegem.github.io/blog/tags/Community/"},{"name":"Day","slug":"Day","permalink":"http://jacegem.github.io/blog/tags/Day/"},{"name":"참관","slug":"참관","permalink":"http://jacegem.github.io/blog/tags/%EC%B0%B8%EA%B4%80/"},{"name":"게임","slug":"게임","permalink":"http://jacegem.github.io/blog/tags/%EA%B2%8C%EC%9E%84/"},{"name":"텐트","slug":"텐트","permalink":"http://jacegem.github.io/blog/tags/%ED%85%90%ED%8A%B8/"},{"name":"나무","slug":"나무","permalink":"http://jacegem.github.io/blog/tags/%EB%82%98%EB%AC%B4/"},{"name":"퍼즐","slug":"퍼즐","permalink":"http://jacegem.github.io/blog/tags/%ED%8D%BC%EC%A6%90/"},{"name":"threejs","slug":"threejs","permalink":"http://jacegem.github.io/blog/tags/threejs/"},{"name":"javascript","slug":"javascript","permalink":"http://jacegem.github.io/blog/tags/javascript/"},{"name":"vworld","slug":"vworld","permalink":"http://jacegem.github.io/blog/tags/vworld/"},{"name":"3d","slug":"3d","permalink":"http://jacegem.github.io/blog/tags/3d/"},{"name":"data","slug":"data","permalink":"http://jacegem.github.io/blog/tags/data/"},{"name":"file","slug":"file","permalink":"http://jacegem.github.io/blog/tags/file/"},{"name":"spring","slug":"spring","permalink":"http://jacegem.github.io/blog/tags/spring/"},{"name":"mybatis","slug":"mybatis","permalink":"http://jacegem.github.io/blog/tags/mybatis/"},{"name":"postgresql","slug":"postgresql","permalink":"http://jacegem.github.io/blog/tags/postgresql/"},{"name":"psql","slug":"psql","permalink":"http://jacegem.github.io/blog/tags/psql/"},{"name":"bytea","slug":"bytea","permalink":"http://jacegem.github.io/blog/tags/bytea/"},{"name":"도쿠위키","slug":"도쿠위키","permalink":"http://jacegem.github.io/blog/tags/%EB%8F%84%EC%BF%A0%EC%9C%84%ED%82%A4/"},{"name":"파일명","slug":"파일명","permalink":"http://jacegem.github.io/blog/tags/%ED%8C%8C%EC%9D%BC%EB%AA%85/"},{"name":"인코딩","slug":"인코딩","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%B8%EC%BD%94%EB%94%A9/"},{"name":"urlencode","slug":"urlencode","permalink":"http://jacegem.github.io/blog/tags/urlencode/"},{"name":"utf-8","slug":"utf-8","permalink":"http://jacegem.github.io/blog/tags/utf-8/"},{"name":"input","slug":"input","permalink":"http://jacegem.github.io/blog/tags/input/"},{"name":"localStorage","slug":"localStorage","permalink":"http://jacegem.github.io/blog/tags/localStorage/"},{"name":"checkbox","slug":"checkbox","permalink":"http://jacegem.github.io/blog/tags/checkbox/"},{"name":"ppt","slug":"ppt","permalink":"http://jacegem.github.io/blog/tags/ppt/"},{"name":"revealjs","slug":"revealjs","permalink":"http://jacegem.github.io/blog/tags/revealjs/"},{"name":"vscode","slug":"vscode","permalink":"http://jacegem.github.io/blog/tags/vscode/"},{"name":"presentation","slug":"presentation","permalink":"http://jacegem.github.io/blog/tags/presentation/"},{"name":"4차","slug":"4차","permalink":"http://jacegem.github.io/blog/tags/4%EC%B0%A8/"},{"name":"산업혁명","slug":"산업혁명","permalink":"http://jacegem.github.io/blog/tags/%EC%82%B0%EC%97%85%ED%98%81%EB%AA%85/"},{"name":"이야기","slug":"이야기","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%B4%EC%95%BC%EA%B8%B0/"},{"name":"big data","slug":"big-data","permalink":"http://jacegem.github.io/blog/tags/big-data/"},{"name":"platform","slug":"platform","permalink":"http://jacegem.github.io/blog/tags/platform/"},{"name":"book","slug":"book","permalink":"http://jacegem.github.io/blog/tags/book/"},{"name":"git","slug":"git","permalink":"http://jacegem.github.io/blog/tags/git/"},{"name":"react","slug":"react","permalink":"http://jacegem.github.io/blog/tags/react/"},{"name":"react-native","slug":"react-native","permalink":"http://jacegem.github.io/blog/tags/react-native/"},{"name":"native","slug":"native","permalink":"http://jacegem.github.io/blog/tags/native/"},{"name":"app","slug":"app","permalink":"http://jacegem.github.io/blog/tags/app/"},{"name":"ui","slug":"ui","permalink":"http://jacegem.github.io/blog/tags/ui/"},{"name":"ux","slug":"ux","permalink":"http://jacegem.github.io/blog/tags/ux/"},{"name":"design","slug":"design","permalink":"http://jacegem.github.io/blog/tags/design/"},{"name":"pattern","slug":"pattern","permalink":"http://jacegem.github.io/blog/tags/pattern/"},{"name":"learning","slug":"learning","permalink":"http://jacegem.github.io/blog/tags/learning/"},{"name":"python","slug":"python","permalink":"http://jacegem.github.io/blog/tags/python/"},{"name":"font","slug":"font","permalink":"http://jacegem.github.io/blog/tags/font/"},{"name":"amazfit","slug":"amazfit","permalink":"http://jacegem.github.io/blog/tags/amazfit/"},{"name":"bip","slug":"bip","permalink":"http://jacegem.github.io/blog/tags/bip/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jacegem.github.io/blog/tags/pyqt5/"},{"name":"pyinstaller","slug":"pyinstaller","permalink":"http://jacegem.github.io/blog/tags/pyinstaller/"},{"name":"React","slug":"React","permalink":"http://jacegem.github.io/blog/tags/React/"},{"name":"3D","slug":"3D","permalink":"http://jacegem.github.io/blog/tags/3D/"},{"name":"gis","slug":"gis","permalink":"http://jacegem.github.io/blog/tags/gis/"},{"name":"Cesium","slug":"Cesium","permalink":"http://jacegem.github.io/blog/tags/Cesium/"},{"name":"thread","slug":"thread","permalink":"http://jacegem.github.io/blog/tags/thread/"},{"name":"cesium","slug":"cesium","permalink":"http://jacegem.github.io/blog/tags/cesium/"},{"name":"viewer","slug":"viewer","permalink":"http://jacegem.github.io/blog/tags/viewer/"},{"name":"github","slug":"github","permalink":"http://jacegem.github.io/blog/tags/github/"},{"name":"카카오톡","slug":"카카오톡","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%B4%EC%B9%B4%EC%98%A4%ED%86%A1/"},{"name":"플러스친구","slug":"플러스친구","permalink":"http://jacegem.github.io/blog/tags/%ED%94%8C%EB%9F%AC%EC%8A%A4%EC%B9%9C%EA%B5%AC/"},{"name":"스마트채팅","slug":"스마트채팅","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%EB%A7%88%ED%8A%B8%EC%B1%84%ED%8C%85/"},{"name":"API","slug":"API","permalink":"http://jacegem.github.io/blog/tags/API/"},{"name":"firestore","slug":"firestore","permalink":"http://jacegem.github.io/blog/tags/firestore/"},{"name":"heroku","slug":"heroku","permalink":"http://jacegem.github.io/blog/tags/heroku/"},{"name":"flask","slug":"flask","permalink":"http://jacegem.github.io/blog/tags/flask/"},{"name":"반응형","slug":"반응형","permalink":"http://jacegem.github.io/blog/tags/%EB%B0%98%EC%9D%91%ED%98%95/"},{"name":"웹","slug":"웹","permalink":"http://jacegem.github.io/blog/tags/%EC%9B%B9/"},{"name":"디자인","slug":"디자인","permalink":"http://jacegem.github.io/blog/tags/%EB%94%94%EC%9E%90%EC%9D%B8/"},{"name":"한글화","slug":"한글화","permalink":"http://jacegem.github.io/blog/tags/%ED%95%9C%EA%B8%80%ED%99%94/"},{"name":"pro","slug":"pro","permalink":"http://jacegem.github.io/blog/tags/pro/"},{"name":"trello","slug":"trello","permalink":"http://jacegem.github.io/blog/tags/trello/"},{"name":"like","slug":"like","permalink":"http://jacegem.github.io/blog/tags/like/"},{"name":"keyboard","slug":"keyboard","permalink":"http://jacegem.github.io/blog/tags/keyboard/"},{"name":"shortcuts","slug":"shortcuts","permalink":"http://jacegem.github.io/blog/tags/shortcuts/"},{"name":"sts","slug":"sts","permalink":"http://jacegem.github.io/blog/tags/sts/"},{"name":"java","slug":"java","permalink":"http://jacegem.github.io/blog/tags/java/"},{"name":"mac","slug":"mac","permalink":"http://jacegem.github.io/blog/tags/mac/"},{"name":"shell","slug":"shell","permalink":"http://jacegem.github.io/blog/tags/shell/"},{"name":"leaflet","slug":"leaflet","permalink":"http://jacegem.github.io/blog/tags/leaflet/"},{"name":"heatmap","slug":"heatmap","permalink":"http://jacegem.github.io/blog/tags/heatmap/"},{"name":"PolylineDecorator","slug":"PolylineDecorator","permalink":"http://jacegem.github.io/blog/tags/PolylineDecorator/"},{"name":"opencv","slug":"opencv","permalink":"http://jacegem.github.io/blog/tags/opencv/"},{"name":"tutorial","slug":"tutorial","permalink":"http://jacegem.github.io/blog/tags/tutorial/"},{"name":"youtube","slug":"youtube","permalink":"http://jacegem.github.io/blog/tags/youtube/"},{"name":"download","slug":"download","permalink":"http://jacegem.github.io/blog/tags/download/"},{"name":"xamarin","slug":"xamarin","permalink":"http://jacegem.github.io/blog/tags/xamarin/"},{"name":"machine","slug":"machine","permalink":"http://jacegem.github.io/blog/tags/machine/"},{"name":"R","slug":"R","permalink":"http://jacegem.github.io/blog/tags/R/"},{"name":"vue","slug":"vue","permalink":"http://jacegem.github.io/blog/tags/vue/"},{"name":"for","slug":"for","permalink":"http://jacegem.github.io/blog/tags/for/"},{"name":"index","slug":"index","permalink":"http://jacegem.github.io/blog/tags/index/"},{"name":"start","slug":"start","permalink":"http://jacegem.github.io/blog/tags/start/"},{"name":"length","slug":"length","permalink":"http://jacegem.github.io/blog/tags/length/"},{"name":"check","slug":"check","permalink":"http://jacegem.github.io/blog/tags/check/"},{"name":"enter","slug":"enter","permalink":"http://jacegem.github.io/blog/tags/enter/"},{"name":"key","slug":"key","permalink":"http://jacegem.github.io/blog/tags/key/"},{"name":"class","slug":"class","permalink":"http://jacegem.github.io/blog/tags/class/"},{"name":"style","slug":"style","permalink":"http://jacegem.github.io/blog/tags/style/"},{"name":"Visual","slug":"Visual","permalink":"http://jacegem.github.io/blog/tags/Visual/"},{"name":"Studio","slug":"Studio","permalink":"http://jacegem.github.io/blog/tags/Studio/"},{"name":"model","slug":"model","permalink":"http://jacegem.github.io/blog/tags/model/"},{"name":"django","slug":"django","permalink":"http://jacegem.github.io/blog/tags/django/"},{"name":"clean","slug":"clean","permalink":"http://jacegem.github.io/blog/tags/clean/"},{"name":"coder","slug":"coder","permalink":"http://jacegem.github.io/blog/tags/coder/"},{"name":"tensorflow","slug":"tensorflow","permalink":"http://jacegem.github.io/blog/tags/tensorflow/"},{"name":"synology","slug":"synology","permalink":"http://jacegem.github.io/blog/tags/synology/"},{"name":"디렉토리","slug":"디렉토리","permalink":"http://jacegem.github.io/blog/tags/%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC/"},{"name":"삭제","slug":"삭제","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AD%EC%A0%9C/"},{"name":"startup","slug":"startup","permalink":"http://jacegem.github.io/blog/tags/startup/"},{"name":"스타트업","slug":"스타트업","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/"},{"name":"투자","slug":"투자","permalink":"http://jacegem.github.io/blog/tags/%ED%88%AC%EC%9E%90/"},{"name":"노하우","slug":"노하우","permalink":"http://jacegem.github.io/blog/tags/%EB%85%B8%ED%95%98%EC%9A%B0/"},{"name":"windows","slug":"windows","permalink":"http://jacegem.github.io/blog/tags/windows/"},{"name":"service","slug":"service","permalink":"http://jacegem.github.io/blog/tags/service/"},{"name":"react.js","slug":"react-js","permalink":"http://jacegem.github.io/blog/tags/react-js/"},{"name":"Postgresql","slug":"Postgresql","permalink":"http://jacegem.github.io/blog/tags/Postgresql/"},{"name":"query","slug":"query","permalink":"http://jacegem.github.io/blog/tags/query/"},{"name":"sql","slug":"sql","permalink":"http://jacegem.github.io/blog/tags/sql/"},{"name":"postgis","slug":"postgis","permalink":"http://jacegem.github.io/blog/tags/postgis/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://jacegem.github.io/blog/tags/Mybatis/"},{"name":"OpenVPN","slug":"OpenVPN","permalink":"http://jacegem.github.io/blog/tags/OpenVPN/"},{"name":"Windows","slug":"Windows","permalink":"http://jacegem.github.io/blog/tags/Windows/"},{"name":"OpenCV","slug":"OpenCV","permalink":"http://jacegem.github.io/blog/tags/OpenCV/"},{"name":"Minergate","slug":"Minergate","permalink":"http://jacegem.github.io/blog/tags/Minergate/"},{"name":"Microsoft","slug":"Microsoft","permalink":"http://jacegem.github.io/blog/tags/Microsoft/"},{"name":"Tech","slug":"Tech","permalink":"http://jacegem.github.io/blog/tags/Tech/"},{"name":"Summit","slug":"Summit","permalink":"http://jacegem.github.io/blog/tags/Summit/"},{"name":"Seoul","slug":"Seoul","permalink":"http://jacegem.github.io/blog/tags/Seoul/"},{"name":"tilelayer","slug":"tilelayer","permalink":"http://jacegem.github.io/blog/tags/tilelayer/"},{"name":"markdown","slug":"markdown","permalink":"http://jacegem.github.io/blog/tags/markdown/"},{"name":"div","slug":"div","permalink":"http://jacegem.github.io/blog/tags/div/"},{"name":"icon","slug":"icon","permalink":"http://jacegem.github.io/blog/tags/icon/"},{"name":"macbook","slug":"macbook","permalink":"http://jacegem.github.io/blog/tags/macbook/"},{"name":"LATEX","slug":"LATEX","permalink":"http://jacegem.github.io/blog/tags/LATEX/"},{"name":"KOYCERA","slug":"KOYCERA","permalink":"http://jacegem.github.io/blog/tags/KOYCERA/"},{"name":"scan","slug":"scan","permalink":"http://jacegem.github.io/blog/tags/scan/"},{"name":"kobo","slug":"kobo","permalink":"http://jacegem.github.io/blog/tags/kobo/"},{"name":"aura","slug":"aura","permalink":"http://jacegem.github.io/blog/tags/aura/"},{"name":"h20","slug":"h20","permalink":"http://jacegem.github.io/blog/tags/h20/"},{"name":"공장초기화","slug":"공장초기화","permalink":"http://jacegem.github.io/blog/tags/%EA%B3%B5%EC%9E%A5%EC%B4%88%EA%B8%B0%ED%99%94/"},{"name":"jsp","slug":"jsp","permalink":"http://jacegem.github.io/blog/tags/jsp/"},{"name":"list","slug":"list","permalink":"http://jacegem.github.io/blog/tags/list/"},{"name":"include","slug":"include","permalink":"http://jacegem.github.io/blog/tags/include/"},{"name":"rnn","slug":"rnn","permalink":"http://jacegem.github.io/blog/tags/rnn/"},{"name":"pyrebase","slug":"pyrebase","permalink":"http://jacegem.github.io/blog/tags/pyrebase/"},{"name":"type","slug":"type","permalink":"http://jacegem.github.io/blog/tags/type/"},{"name":"http","slug":"http","permalink":"http://jacegem.github.io/blog/tags/http/"},{"name":"content","slug":"content","permalink":"http://jacegem.github.io/blog/tags/content/"},{"name":"html","slug":"html","permalink":"http://jacegem.github.io/blog/tags/html/"},{"name":"checked","slug":"checked","permalink":"http://jacegem.github.io/blog/tags/checked/"},{"name":"css","slug":"css","permalink":"http://jacegem.github.io/blog/tags/css/"},{"name":"animation","slug":"animation","permalink":"http://jacegem.github.io/blog/tags/animation/"},{"name":"search","slug":"search","permalink":"http://jacegem.github.io/blog/tags/search/"},{"name":"form","slug":"form","permalink":"http://jacegem.github.io/blog/tags/form/"},{"name":"gitbook","slug":"gitbook","permalink":"http://jacegem.github.io/blog/tags/gitbook/"},{"name":"integration","slug":"integration","permalink":"http://jacegem.github.io/blog/tags/integration/"},{"name":"geoserver","slug":"geoserver","permalink":"http://jacegem.github.io/blog/tags/geoserver/"},{"name":"jsonp","slug":"jsonp","permalink":"http://jacegem.github.io/blog/tags/jsonp/"},{"name":"cql","slug":"cql","permalink":"http://jacegem.github.io/blog/tags/cql/"},{"name":"filter","slug":"filter","permalink":"http://jacegem.github.io/blog/tags/filter/"},{"name":"jquery","slug":"jquery","permalink":"http://jacegem.github.io/blog/tags/jquery/"},{"name":"upload","slug":"upload","permalink":"http://jacegem.github.io/blog/tags/upload/"},{"name":"system","slug":"system","permalink":"http://jacegem.github.io/blog/tags/system/"},{"name":"trading","slug":"trading","permalink":"http://jacegem.github.io/blog/tags/trading/"},{"name":"tag","slug":"tag","permalink":"http://jacegem.github.io/blog/tags/tag/"},{"name":"eclipse","slug":"eclipse","permalink":"http://jacegem.github.io/blog/tags/eclipse/"},{"name":"formatting","slug":"formatting","permalink":"http://jacegem.github.io/blog/tags/formatting/"},{"name":"span","slug":"span","permalink":"http://jacegem.github.io/blog/tags/span/"},{"name":"wiki","slug":"wiki","permalink":"http://jacegem.github.io/blog/tags/wiki/"},{"name":"dokuwiki","slug":"dokuwiki","permalink":"http://jacegem.github.io/blog/tags/dokuwiki/"},{"name":"snippet","slug":"snippet","permalink":"http://jacegem.github.io/blog/tags/snippet/"},{"name":"celery","slug":"celery","permalink":"http://jacegem.github.io/blog/tags/celery/"},{"name":"schedule","slug":"schedule","permalink":"http://jacegem.github.io/blog/tags/schedule/"},{"name":"conoha","slug":"conoha","permalink":"http://jacegem.github.io/blog/tags/conoha/"},{"name":"vps","slug":"vps","permalink":"http://jacegem.github.io/blog/tags/vps/"},{"name":"cloud","slug":"cloud","permalink":"http://jacegem.github.io/blog/tags/cloud/"},{"name":"console","slug":"console","permalink":"http://jacegem.github.io/blog/tags/console/"},{"name":"conemu","slug":"conemu","permalink":"http://jacegem.github.io/blog/tags/conemu/"},{"name":"특이점","slug":"특이점","permalink":"http://jacegem.github.io/blog/tags/%ED%8A%B9%EC%9D%B4%EC%A0%90/"},{"name":"axisj","slug":"axisj","permalink":"http://jacegem.github.io/blog/tags/axisj/"},{"name":"android","slug":"android","permalink":"http://jacegem.github.io/blog/tags/android/"},{"name":"autohotkey","slug":"autohotkey","permalink":"http://jacegem.github.io/blog/tags/autohotkey/"},{"name":"unity","slug":"unity","permalink":"http://jacegem.github.io/blog/tags/unity/"},{"name":"language","slug":"language","permalink":"http://jacegem.github.io/blog/tags/language/"},{"name":"elm","slug":"elm","permalink":"http://jacegem.github.io/blog/tags/elm/"},{"name":"plugin","slug":"plugin","permalink":"http://jacegem.github.io/blog/tags/plugin/"},{"name":"conference","slug":"conference","permalink":"http://jacegem.github.io/blog/tags/conference/"},{"name":"asset","slug":"asset","permalink":"http://jacegem.github.io/blog/tags/asset/"},{"name":"database","slug":"database","permalink":"http://jacegem.github.io/blog/tags/database/"},{"name":"development","slug":"development","permalink":"http://jacegem.github.io/blog/tags/development/"},{"name":"하스스톤","slug":"하스스톤","permalink":"http://jacegem.github.io/blog/tags/%ED%95%98%EC%8A%A4%EC%8A%A4%ED%86%A4/"},{"name":"선술집","slug":"선술집","permalink":"http://jacegem.github.io/blog/tags/%EC%84%A0%EC%88%A0%EC%A7%91/"},{"name":"일러스트레이터","slug":"일러스트레이터","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%BC%EB%9F%AC%EC%8A%A4%ED%8A%B8%EB%A0%88%EC%9D%B4%ED%84%B0/"},{"name":"단축키","slug":"단축키","permalink":"http://jacegem.github.io/blog/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"},{"name":"파일","slug":"파일","permalink":"http://jacegem.github.io/blog/tags/%ED%8C%8C%EC%9D%BC/"},{"name":"오브젝트","slug":"오브젝트","permalink":"http://jacegem.github.io/blog/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"},{"name":"편집","slug":"편집","permalink":"http://jacegem.github.io/blog/tags/%ED%8E%B8%EC%A7%91/"},{"name":"보기","slug":"보기","permalink":"http://jacegem.github.io/blog/tags/%EB%B3%B4%EA%B8%B0/"},{"name":"글자","slug":"글자","permalink":"http://jacegem.github.io/blog/tags/%EA%B8%80%EC%9E%90/"},{"name":"숫자키","slug":"숫자키","permalink":"http://jacegem.github.io/blog/tags/%EC%88%AB%EC%9E%90%ED%82%A4/"},{"name":"Extrude","slug":"Extrude","permalink":"http://jacegem.github.io/blog/tags/Extrude/"},{"name":"Bevel","slug":"Bevel","permalink":"http://jacegem.github.io/blog/tags/Bevel/"},{"name":"scribble","slug":"scribble","permalink":"http://jacegem.github.io/blog/tags/scribble/"},{"name":"effect","slug":"effect","permalink":"http://jacegem.github.io/blog/tags/effect/"},{"name":"stylize","slug":"stylize","permalink":"http://jacegem.github.io/blog/tags/stylize/"},{"name":"투명도","slug":"투명도","permalink":"http://jacegem.github.io/blog/tags/%ED%88%AC%EB%AA%85%EB%8F%84/"},{"name":"옵션","slug":"옵션","permalink":"http://jacegem.github.io/blog/tags/%EC%98%B5%EC%85%98/"},{"name":"illustratro","slug":"illustratro","permalink":"http://jacegem.github.io/blog/tags/illustratro/"},{"name":"illustrator","slug":"illustrator","permalink":"http://jacegem.github.io/blog/tags/illustrator/"},{"name":"perspective","slug":"perspective","permalink":"http://jacegem.github.io/blog/tags/perspective/"},{"name":"grid","slug":"grid","permalink":"http://jacegem.github.io/blog/tags/grid/"},{"name":"preset","slug":"preset","permalink":"http://jacegem.github.io/blog/tags/preset/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://jacegem.github.io/blog/tags/%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C/"},{"name":"사진","slug":"사진","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EC%A7%84/"},{"name":"배경","slug":"배경","permalink":"http://jacegem.github.io/blog/tags/%EB%B0%B0%EA%B2%BD/"},{"name":"캐릭터","slug":"캐릭터","permalink":"http://jacegem.github.io/blog/tags/%EC%BA%90%EB%A6%AD%ED%84%B0/"},{"name":"라이브","slug":"라이브","permalink":"http://jacegem.github.io/blog/tags/%EB%9D%BC%EC%9D%B4%EB%B8%8C/"},{"name":"트레이싱","slug":"트레이싱","permalink":"http://jacegem.github.io/blog/tags/%ED%8A%B8%EB%A0%88%EC%9D%B4%EC%8B%B1/"},{"name":"패스파인더","slug":"패스파인더","permalink":"http://jacegem.github.io/blog/tags/%ED%8C%A8%EC%8A%A4%ED%8C%8C%EC%9D%B8%EB%8D%94/"},{"name":"pathfinder","slug":"pathfinder","permalink":"http://jacegem.github.io/blog/tags/pathfinder/"},{"name":"툴","slug":"툴","permalink":"http://jacegem.github.io/blog/tags/%ED%88%B4/"},{"name":"참고","slug":"참고","permalink":"http://jacegem.github.io/blog/tags/%EC%B0%B8%EA%B3%A0/"},{"name":"사이트","slug":"사이트","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EC%9D%B4%ED%8A%B8/"},{"name":"커피","slug":"커피","permalink":"http://jacegem.github.io/blog/tags/%EC%BB%A4%ED%94%BC/"},{"name":"커피베이","slug":"커피베이","permalink":"http://jacegem.github.io/blog/tags/%EC%BB%A4%ED%94%BC%EB%B2%A0%EC%9D%B4/"},{"name":"임실","slug":"임실","permalink":"http://jacegem.github.io/blog/tags/%EC%9E%84%EC%8B%A4/"},{"name":"치즈","slug":"치즈","permalink":"http://jacegem.github.io/blog/tags/%EC%B9%98%EC%A6%88/"},{"name":"테마파크","slug":"테마파크","permalink":"http://jacegem.github.io/blog/tags/%ED%85%8C%EB%A7%88%ED%8C%8C%ED%81%AC/"},{"name":"언덕","slug":"언덕","permalink":"http://jacegem.github.io/blog/tags/%EC%96%B8%EB%8D%95/"},{"name":"15분","slug":"15분","permalink":"http://jacegem.github.io/blog/tags/15%EB%B6%84/"},{"name":"의지","slug":"의지","permalink":"http://jacegem.github.io/blog/tags/%EC%9D%98%EC%A7%80/"},{"name":"드로잉","slug":"드로잉","permalink":"http://jacegem.github.io/blog/tags/%EB%93%9C%EB%A1%9C%EC%9E%89/"},{"name":"words","slug":"words","permalink":"http://jacegem.github.io/blog/tags/words/"},{"name":"muscle","slug":"muscle","permalink":"http://jacegem.github.io/blog/tags/muscle/"},{"name":"dysfunction","slug":"dysfunction","permalink":"http://jacegem.github.io/blog/tags/dysfunction/"},{"name":"메모","slug":"메모","permalink":"http://jacegem.github.io/blog/tags/%EB%A9%94%EB%AA%A8/"},{"name":"노트","slug":"노트","permalink":"http://jacegem.github.io/blog/tags/%EB%85%B8%ED%8A%B8/"},{"name":"사용법","slug":"사용법","permalink":"http://jacegem.github.io/blog/tags/%EC%82%AC%EC%9A%A9%EB%B2%95/"},{"name":"마크다운","slug":"마크다운","permalink":"http://jacegem.github.io/blog/tags/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4/"},{"name":"예약","slug":"예약","permalink":"http://jacegem.github.io/blog/tags/%EC%98%88%EC%95%BD/"},{"name":"주제","slug":"주제","permalink":"http://jacegem.github.io/blog/tags/%EC%A3%BC%EC%A0%9C/"},{"name":"ahk","slug":"ahk","permalink":"http://jacegem.github.io/blog/tags/ahk/"},{"name":"script","slug":"script","permalink":"http://jacegem.github.io/blog/tags/script/"},{"name":"select","slug":"select","permalink":"http://jacegem.github.io/blog/tags/select/"},{"name":"selector","slug":"selector","permalink":"http://jacegem.github.io/blog/tags/selector/"},{"name":"toad","slug":"toad","permalink":"http://jacegem.github.io/blog/tags/toad/"},{"name":"regex","slug":"regex","permalink":"http://jacegem.github.io/blog/tags/regex/"},{"name":"comment","slug":"comment","permalink":"http://jacegem.github.io/blog/tags/comment/"},{"name":"jstl","slug":"jstl","permalink":"http://jacegem.github.io/blog/tags/jstl/"},{"name":"callback","slug":"callback","permalink":"http://jacegem.github.io/blog/tags/callback/"},{"name":"function","slug":"function","permalink":"http://jacegem.github.io/blog/tags/function/"},{"name":"do","slug":"do","permalink":"http://jacegem.github.io/blog/tags/do/"},{"name":"ifttt","slug":"ifttt","permalink":"http://jacegem.github.io/blog/tags/ifttt/"},{"name":"sms","slug":"sms","permalink":"http://jacegem.github.io/blog/tags/sms/"},{"name":"google","slug":"google","permalink":"http://jacegem.github.io/blog/tags/google/"},{"name":"drive","slug":"drive","permalink":"http://jacegem.github.io/blog/tags/drive/"},{"name":"spreadsheet","slug":"spreadsheet","permalink":"http://jacegem.github.io/blog/tags/spreadsheet/"},{"name":"영상","slug":"영상","permalink":"http://jacegem.github.io/blog/tags/%EC%98%81%EC%83%81/"},{"name":"촬영","slug":"촬영","permalink":"http://jacegem.github.io/blog/tags/%EC%B4%AC%EC%98%81/"},{"name":"베가스","slug":"베가스","permalink":"http://jacegem.github.io/blog/tags/%EB%B2%A0%EA%B0%80%EC%8A%A4/"},{"name":"vegas","slug":"vegas","permalink":"http://jacegem.github.io/blog/tags/vegas/"},{"name":"excel","slug":"excel","permalink":"http://jacegem.github.io/blog/tags/excel/"},{"name":"substring","slug":"substring","permalink":"http://jacegem.github.io/blog/tags/substring/"},{"name":"엑셀","slug":"엑셀","permalink":"http://jacegem.github.io/blog/tags/%EC%97%91%EC%85%80/"},{"name":"문자열","slug":"문자열","permalink":"http://jacegem.github.io/blog/tags/%EB%AC%B8%EC%9E%90%EC%97%B4/"},{"name":"분할","slug":"분할","permalink":"http://jacegem.github.io/blog/tags/%EB%B6%84%ED%95%A0/"},{"name":"c#","slug":"c","permalink":"http://jacegem.github.io/blog/tags/c/"},{"name":"array","slug":"array","permalink":"http://jacegem.github.io/blog/tags/array/"},{"name":"duplcate","slug":"duplcate","permalink":"http://jacegem.github.io/blog/tags/duplcate/"},{"name":"중복","slug":"중복","permalink":"http://jacegem.github.io/blog/tags/%EC%A4%91%EB%B3%B5/"},{"name":"bluetooth","slug":"bluetooth","permalink":"http://jacegem.github.io/blog/tags/bluetooth/"},{"name":"earset","slug":"earset","permalink":"http://jacegem.github.io/blog/tags/earset/"},{"name":"headset","slug":"headset","permalink":"http://jacegem.github.io/blog/tags/headset/"},{"name":"earphone","slug":"earphone","permalink":"http://jacegem.github.io/blog/tags/earphone/"},{"name":"hbs-810","slug":"hbs-810","permalink":"http://jacegem.github.io/blog/tags/hbs-810/"},{"name":"hbs-760","slug":"hbs-760","permalink":"http://jacegem.github.io/blog/tags/hbs-760/"},{"name":"algospot","slug":"algospot","permalink":"http://jacegem.github.io/blog/tags/algospot/"},{"name":"mercy","slug":"mercy","permalink":"http://jacegem.github.io/blog/tags/mercy/"},{"name":"algorithm","slug":"algorithm","permalink":"http://jacegem.github.io/blog/tags/algorithm/"},{"name":"알고리즘","slug":"알고리즘","permalink":"http://jacegem.github.io/blog/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"알고스팟","slug":"알고스팟","permalink":"http://jacegem.github.io/blog/tags/%EC%95%8C%EA%B3%A0%EC%8A%A4%ED%8C%9F/"},{"name":"티스토리","slug":"티스토리","permalink":"http://jacegem.github.io/blog/tags/%ED%8B%B0%EC%8A%A4%ED%86%A0%EB%A6%AC/"},{"name":"스킨","slug":"스킨","permalink":"http://jacegem.github.io/blog/tags/%EC%8A%A4%ED%82%A8/"},{"name":"tistory","slug":"tistory","permalink":"http://jacegem.github.io/blog/tags/tistory/"},{"name":"skin","slug":"skin","permalink":"http://jacegem.github.io/blog/tags/skin/"},{"name":"hearthstone","slug":"hearthstone","permalink":"http://jacegem.github.io/blog/tags/hearthstone/"},{"name":"drinking","slug":"drinking","permalink":"http://jacegem.github.io/blog/tags/drinking/"},{"name":"game","slug":"game","permalink":"http://jacegem.github.io/blog/tags/game/"},{"name":"unix","slug":"unix","permalink":"http://jacegem.github.io/blog/tags/unix/"},{"name":"linux","slug":"linux","permalink":"http://jacegem.github.io/blog/tags/linux/"},{"name":"command","slug":"command","permalink":"http://jacegem.github.io/blog/tags/command/"},{"name":"df","slug":"df","permalink":"http://jacegem.github.io/blog/tags/df/"},{"name":"du","slug":"du","permalink":"http://jacegem.github.io/blog/tags/du/"},{"name":"hexo","slug":"hexo","permalink":"http://jacegem.github.io/blog/tags/hexo/"},{"name":"writing","slug":"writing","permalink":"http://jacegem.github.io/blog/tags/writing/"},{"name":"post","slug":"post","permalink":"http://jacegem.github.io/blog/tags/post/"},{"name":"resophnotes","slug":"resophnotes","permalink":"http://jacegem.github.io/blog/tags/resophnotes/"},{"name":"draft","slug":"draft","permalink":"http://jacegem.github.io/blog/tags/draft/"},{"name":"publish","slug":"publish","permalink":"http://jacegem.github.io/blog/tags/publish/"},{"name":"deploy","slug":"deploy","permalink":"http://jacegem.github.io/blog/tags/deploy/"},{"name":"blog","slug":"blog","permalink":"http://jacegem.github.io/blog/tags/blog/"},{"name":"sw","slug":"sw","permalink":"http://jacegem.github.io/blog/tags/sw/"},{"name":"powercmd","slug":"powercmd","permalink":"http://jacegem.github.io/blog/tags/powercmd/"},{"name":"prompt","slug":"prompt","permalink":"http://jacegem.github.io/blog/tags/prompt/"},{"name":"tool","slug":"tool","permalink":"http://jacegem.github.io/blog/tags/tool/"},{"name":"highlight","slug":"highlight","permalink":"http://jacegem.github.io/blog/tags/highlight/"},{"name":"syntax","slug":"syntax","permalink":"http://jacegem.github.io/blog/tags/syntax/"},{"name":"js","slug":"js","permalink":"http://jacegem.github.io/blog/tags/js/"},{"name":"oracle","slug":"oracle","permalink":"http://jacegem.github.io/blog/tags/oracle/"},{"name":"undo","slug":"undo","permalink":"http://jacegem.github.io/blog/tags/undo/"},{"name":"tablespace","slug":"tablespace","permalink":"http://jacegem.github.io/blog/tags/tablespace/"},{"name":"scala","slug":"scala","permalink":"http://jacegem.github.io/blog/tags/scala/"},{"name":"섭씨","slug":"섭씨","permalink":"http://jacegem.github.io/blog/tags/%EC%84%AD%EC%94%A8/"},{"name":"화씨","slug":"화씨","permalink":"http://jacegem.github.io/blog/tags/%ED%99%94%EC%94%A8/"},{"name":"변환기","slug":"변환기","permalink":"http://jacegem.github.io/blog/tags/%EB%B3%80%ED%99%98%EA%B8%B0/"},{"name":"공식","slug":"공식","permalink":"http://jacegem.github.io/blog/tags/%EA%B3%B5%EC%8B%9D/"},{"name":"온도","slug":"온도","permalink":"http://jacegem.github.io/blog/tags/%EC%98%A8%EB%8F%84/"},{"name":"우두머리","slug":"우두머리","permalink":"http://jacegem.github.io/blog/tags/%EC%9A%B0%EB%91%90%EB%A8%B8%EB%A6%AC/"},{"name":"영웅","slug":"영웅","permalink":"http://jacegem.github.io/blog/tags/%EC%98%81%EC%9B%85/"},{"name":"능력","slug":"능력","permalink":"http://jacegem.github.io/blog/tags/%EB%8A%A5%EB%A0%A5/"},{"name":"hello","slug":"hello","permalink":"http://jacegem.github.io/blog/tags/hello/"},{"name":"world","slug":"world","permalink":"http://jacegem.github.io/blog/tags/world/"},{"name":"category","slug":"category","permalink":"http://jacegem.github.io/blog/tags/category/"},{"name":"adsense","slug":"adsense","permalink":"http://jacegem.github.io/blog/tags/adsense/"},{"name":"layout","slug":"layout","permalink":"http://jacegem.github.io/blog/tags/layout/"},{"name":"ejs","slug":"ejs","permalink":"http://jacegem.github.io/blog/tags/ejs/"},{"name":"haroopad","slug":"haroopad","permalink":"http://jacegem.github.io/blog/tags/haroopad/"},{"name":"shortcut","slug":"shortcut","permalink":"http://jacegem.github.io/blog/tags/shortcut/"},{"name":"framework","slug":"framework","permalink":"http://jacegem.github.io/blog/tags/framework/"},{"name":"install","slug":"install","permalink":"http://jacegem.github.io/blog/tags/install/"},{"name":"nodejs","slug":"nodejs","permalink":"http://jacegem.github.io/blog/tags/nodejs/"},{"name":"theme","slug":"theme","permalink":"http://jacegem.github.io/blog/tags/theme/"},{"name":"cpp","slug":"cpp","permalink":"http://jacegem.github.io/blog/tags/cpp/"},{"name":"c++","slug":"c","permalink":"http://jacegem.github.io/blog/tags/c/"},{"name":"network","slug":"network","permalink":"http://jacegem.github.io/blog/tags/network/"},{"name":"programming","slug":"programming","permalink":"http://jacegem.github.io/blog/tags/programming/"},{"name":"md","slug":"md","permalink":"http://jacegem.github.io/blog/tags/md/"}]}